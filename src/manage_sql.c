/* OpenVAS Manager
 * $Id$
 * Description: Manager Manage library: SQL backend.
 *
 * Authors:
 * Matthew Mundell <matthew.mundell@greenbone.net>
 * Timo Pollmeier <timo.pollmeier@greenbone.net>
 *
 * Copyright:
 * Copyright (C) 2009-2013 Greenbone Networks GmbH
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2,
 * or, at your option, any later version as published by the Free
 * Software Foundation
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 */

/**
 * @file  manage_sql.c
 * @brief The OpenVAS Manager management library (SQLite implementation).
 *
 * This file defines the SQLite specific portions of the OpenVAS manager
 * management library.
 */

#define _GNU_SOURCE

#include "manage_sql.h"
#include "lsc_user.h"
#include "sql.h"
#include "tracef.h"

#include <arpa/inet.h>
#include <assert.h>
#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <locale.h>
#include <pwd.h>
#include <sqlite3.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/time.h>

#include <openvas/base/openvas_string.h>
#include <openvas/base/openvas_file.h>
#include <openvas/misc/openvas_auth.h>
#include <openvas/misc/openvas_logging.h>
#include <openvas/misc/openvas_uuid.h>
#include <openvas/misc/resource_request.h>
#include <openvas/base/pwpolicy.h>
#include <openvas/omp/xml.h>

#ifdef S_SPLINT_S
#include "splint.h"
#endif


/* Internal types and preprocessor definitions. */

/**
 * @brief A user.
 */
typedef long long int user_t;

/**
 * @brief Database ROWID of 'Full and fast' config.
 */
#define CONFIG_ID_FULL_AND_FAST 1

/**
 * @brief Database ROWID of 'Full and fast ultimate' config.
 */
#define CONFIG_ID_FULL_AND_FAST_ULTIMATE 2

/**
 * @brief Database ROWID of 'Full and very deep' config.
 */
#define CONFIG_ID_FULL_AND_VERY_DEEP 3

/**
 * @brief Database ROWID of 'Full and very deep ultimate' config.
 */
#define CONFIG_ID_FULL_AND_VERY_DEEP_ULTIMATE 4

/**
 * @brief UUID of 'Full and fast' config.
 */
#define CONFIG_UUID_FULL_AND_FAST "daba56c8-73ec-11df-a475-002264764cea"

/**
 * @brief UUID of 'Full and fast ultimate' config.
 */
#define CONFIG_UUID_FULL_AND_FAST_ULTIMATE \
 "698f691e-7489-11df-9d8c-002264764cea"

/**
 * @brief UUID of 'Full and very deep' config.
 */
#define CONFIG_UUID_FULL_AND_VERY_DEEP "708f25c4-7489-11df-8094-002264764cea"

/**
 * @brief UUID of 'Full and very deep ultimate' config.
 */
#define CONFIG_UUID_FULL_AND_VERY_DEEP_ULTIMATE \
 "74db13d6-7489-11df-91b9-002264764cea"

/**
 * @brief UUID of 'Empty' config.
 */
#define CONFIG_UUID_EMPTY "085569ce-73ed-11df-83c3-002264764cea"

/**
 * @brief UUID of 'All' NVT selector.
 */
#define MANAGE_NVT_SELECTOR_UUID_ALL "54b45713-d4f4-4435-b20d-304c175ed8c5"

/**
 * @brief UUID of 'OpenVAS Default' port list.
 */
#define PORT_LIST_UUID_DEFAULT "c7e03b6c-3bbe-11e1-a057-406186ea4fc5"

/**
 * @brief UUID of 'All TCP' port list.
 */
#define PORT_LIST_UUID_ALL_TCP "fd591a34-56fd-11e1-9f27-406186ea4fc5"

/**
 * @brief UUID of 'All TCP and Nmap 5.51 Top 100 UDP' port list.
 */
#define PORT_LIST_UUID_ALL_TCP_NMAP_5_51_TOP_100 "730ef368-57e2-11e1-a90f-406186ea4fc5"

/**
 * @brief UUID of 'All TCP and Nmap 5.51 Top 1000 UDP' port list.
 */
#define PORT_LIST_UUID_ALL_TCP_NMAP_5_51_TOP_1000 "9ddce1ae-57e7-11e1-b13c-406186ea4fc5"

/**
 * @brief UUID of 'All privileged TCP' port list.
 */
#define PORT_LIST_UUID_ALL_PRIV_TCP "492b72f4-56fe-11e1-98a7-406186ea4fc5"

/**
 * @brief UUID of 'All privileged TCP and UDP' port list.
 */
#define PORT_LIST_UUID_ALL_PRIV_TCP_UDP "5f2029f6-56fe-11e1-bb94-406186ea4fc5"

/**
 * @brief UUID of 'All privileged TCP and UDP' port list.
 */
#define PORT_LIST_UUID_ALL_IANA_TCP_2012 "33d0cd82-57c6-11e1-8ed1-406186ea4fc5"

/**
 * @brief UUID of 'All privileged TCP and UDP' port list.
 */
#define PORT_LIST_UUID_ALL_IANA_TCP_UDP_2012 "4a4717fe-57d2-11e1-9a26-406186ea4fc5"

/**
 * @brief UUID of 'Nmap 5.51 top 2000 TCP top 100 UDP' port list.
 */
#define PORT_LIST_UUID_NMAP_5_51_TOP_2000_TOP_100 "ab33f6b0-57f8-11e1-96f5-406186ea4fc5"

/**
 * @brief UUID of 'Localhost' target.
 */
#define TARGET_UUID_LOCALHOST "b493b7a8-7489-11df-a3ec-002264764cea"

/**
 * @brief Trust constant for error.
 */
#define TRUST_ERROR 0

/**
 * @brief Trust constant for yes.
 */
#define TRUST_YES 1

/**
 * @brief Trust constant for no.
 */
#define TRUST_NO 2

/**
 * @brief Trust constant for unknown.
 */
#define TRUST_UNKNOWN 3

/**
 * @brief Location of a constituent of a trashcan resource.
 */
#define LOCATION_TABLE 0

/**
 * @brief Location of a constituent of a trashcan resource.
 */
#define LOCATION_TRASH 1

/**
 * @brief Number of milliseconds between timevals a and b (performs a-b).
 */
#define TIMEVAL_SUBTRACT_MS(a,b) ((((a).tv_sec - (b).tv_sec) * 1000) + \
                                  ((a).tv_usec - (b).tv_usec) / 1000)


/* Headers for symbols defined in manage.c which are private to libmanage. */

/**
 * @brief Flag to force authentication to succeed.  For scheduled tasks.
 */
int authenticate_allow_all;

const char *threat_message_type (const char *);

const char *message_type_threat (const char *);

int delete_reports (task_t);

int delete_slave_task (slave_t, const char *);


/* Port range headers. */

void
make_port_ranges_iana_tcp_2012 (port_list_t);

void
make_port_ranges_iana_tcp_udp_2012 (port_list_t);

void
make_port_ranges_all_tcp_nmap_5_51_top_100 (port_list_t);

void
make_port_ranges_all_tcp_nmap_5_51_top_1000 (port_list_t);

void
make_port_ranges_nmap_5_51_top_2000_top_100 (port_list_t);


/* Static headers. */

static void
init_preference_iterator (iterator_t*, config_t, const char*);

static const char*
preference_iterator_name (iterator_t*);

static const char*
preference_iterator_value (iterator_t*);

static void
nvt_selector_add (const char*, const char*, const char*, int);

static int
nvt_selector_families_growing (const char*);

static int
nvt_selector_family_count (const char*, int);

static int
nvt_selector_nvts_growing (const char*);

static int
nvt_selector_nvts_growing_2 (const char*, int);

static void
nvt_selector_remove_selector (const char*, const char*, int);

static int
insert_rc_into_config (config_t, const char*, const char*, char*);

static void
update_config_caches (config_t);

static void
update_all_config_caches ();

static void
set_target_hosts (target_t, const char *);

static gchar*
select_config_nvts (config_t, const char*, int, const char*);

int
family_count ();

const char*
task_threat_level (task_t, int);

static const char*
task_previous_threat_level (task_t);

static char*
task_owner_uuid (task_t);

static int
insert_nvt_selectors (const char *, const array_t*);

static int
validate_param_value (report_format_t, report_format_param_t param, const char *,
                      const char *);

int
delete_task_lock (task_t, int);

gchar*
clean_hosts (const char *, int*);

void
ensure_predefined_port_lists_exist ();

int
create_port_list_unique (const char *, const char *, const char *,
                         port_list_t *);

static int
user_owns_result (const char *);

int
valid_type (const char*);

static gboolean
find_user (const char *, user_t *user);


/* Variables. */

/**
 * @brief Memory cache of NVT information from the database.
 */
nvtis_t* nvti_cache = NULL;

/**
 * @brief Name of the database file.
 */
gchar* task_db_name = NULL;

/**
 * @brief Whether a transaction has been opened and not committed yet.
 */
static gboolean in_transaction;

/**
 * @brief Time of reception of the currently processed message.
 */
static struct timeval last_msg;


/* General helpers. */

/**
 * @brief Get the threat of a CVSS.
 *
 * @param  cvss  CVSS.
 *
 * @return Static threat name.
 */
static const char *
cvss_threat (double cvss)
{
  if (cvss < 0.0 || cvss > 10.0)
    return "";
  if (cvss <= 2.0)
    return "Low";
  if (cvss <= 5.0)
    return "Medium";
  return "High";
}

/**
 * @brief Test whether a string equal to a given string exists in an array.
 *
 * @param[in]  array   Array of gchar* pointers.
 * @param[in]  string  String.
 *
 * @return 1 if a string equal to \arg string exists in \arg array, else 0.
 */
static int
member (GPtrArray *array, const char *string)
{
  const gchar *item;
  int index = 0;
  while ((item = (gchar*) g_ptr_array_index (array, index++)))
    if (strcmp (item, string) == 0) return 1;
  return 0;
}

/**
 * @brief Test whether a user owns a resource.
 *
 * @param[in]  resource  Type of resource, for example "task".
 * @param[in]  uuid      UUID of resource.
 *
 * @return 1 if user owns resource, else 0.
 */
static int
user_owns_uuid (const char *resource, const char *uuid)
{
  int ret;

  assert (current_credentials.uuid);

  if (strcmp (resource, "result") == 0)
    return user_owns_result (uuid);

  ret = sql_int (0, 0,
                 "SELECT count(*) FROM %ss"
                 " WHERE uuid = '%s'"
                 " AND ((owner IS NULL) OR (owner ="
                 " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                 resource,
                 uuid,
                 current_credentials.uuid);

  return ret;
}

/**
 * @brief Parse an action specifier.
 *
 * @param[in]  actions_string  Specifier.
 *
 * @return Actions.
 */
static int
parse_actions (const char *actions_string)
{
  int actions;
  actions = 0;
  if (strchr (actions_string, 'g'))
    actions |= MANAGE_ACTION_GET;
  if (strchr (actions_string, 'm'))
    actions |= MANAGE_ACTION_MODIFY;
  if (strchr (actions_string, 'u'))
    actions |= MANAGE_ACTION_USE;
  return actions;
}

/**
 * @brief Test whether a user may access a resource for a set of actions.
 *
 * @param[in]  resource  Type of resource, for example "task".
 * @param[in]  uuid      UUID of resource.
 * @param[in]  actions_string   Actions.
 *
 * @return 1 if user may access resource, else 0.
 */
static int
user_has_access_uuid (const char *resource, const char *uuid,
                      const char *actions_string)
{
  int ret, actions;

  assert (current_credentials.uuid);

  ret = user_owns_uuid (resource, uuid);
  if (ret)
    return ret;

  if (actions_string == NULL || strlen (actions_string) == 0)
    return 0;

  actions = parse_actions (actions_string);

  if (actions == 0)
    return 0;

  if (strcmp (resource, "result") == 0)
    return sql_int (0, 0,
                    "SELECT count(*) FROM results, report_results, reports"
                    " WHERE results.uuid = '%s'"
                    " AND report_results.result = results.ROWID"
                    " AND report_results.report = reports.ROWID"
                    " AND ((reports.owner IS NULL) OR (reports.owner ="
                    " (SELECT users.ROWID FROM users WHERE users.uuid = '%s'))"
                    "  OR reports.task IN"
                    "     (SELECT task FROM task_users WHERE user ="
                    "      (SELECT ROWID FROM users"
                    "       WHERE users.uuid = '%s')"
                    "      AND actions & %u = %u));",
                    uuid,
                    current_credentials.uuid,
                    current_credentials.uuid,
                    actions,
                    actions);

  if (strcmp (resource, "report") == 0)
    return sql_int (0, 0,
                    "SELECT count(*) FROM tasks"
                    " WHERE ROWID = (SELECT task FROM %ss WHERE uuid = '%s')"
                    " AND"
                    " ((owner IS NULL) OR (owner ="
                    "  (SELECT users.ROWID FROM users WHERE users.uuid = '%s'))"
                    "  OR ROWID IN"
                    "     (SELECT task FROM task_users WHERE user ="
                    "      (SELECT ROWID FROM users"
                    "       WHERE users.uuid = '%s')"
                    "      AND actions & %u = %u));",
                    resource,
                    uuid,
                    current_credentials.uuid,
                    current_credentials.uuid,
                    actions,
                    actions);

  if (strcmp (resource, "lsc_credential") == 0)
    return sql_int (0, 0,
                    "SELECT count(*) FROM tasks, targets"
                    " WHERE tasks.target = targets.ROWID"
                    " AND (targets.lsc_credential ="
                    "      (SELECT %ss.ROWID FROM %ss WHERE uuid = '%s')"
                    "      OR"
                    "      targets.smb_lsc_credential ="
                    "      (SELECT %ss.ROWID FROM %ss WHERE uuid = '%s'))"
                    " AND"
                    " ((tasks.owner IS NULL) OR (tasks.owner ="
                    "  (SELECT users.ROWID FROM users WHERE users.uuid = '%s'))"
                    "  OR tasks.ROWID IN"
                    "     (SELECT task FROM task_users WHERE user ="
                    "      (SELECT users.ROWID FROM users"
                    "       WHERE users.uuid = '%s')"
                    "      AND actions & %u = %u));",
                    resource,
                    resource,
                    uuid,
                    resource,
                    resource,
                    uuid,
                    current_credentials.uuid,
                    current_credentials.uuid,
                    actions,
                    actions);

  if (strcmp (resource, "task"))
    return sql_int (0, 0,
                    "SELECT count(*) FROM tasks"
                    " WHERE %s = (SELECT ROWID FROM %ss WHERE uuid = '%s')"
                    " AND"
                    " ((owner IS NULL) OR (owner ="
                    "  (SELECT users.ROWID FROM users WHERE users.uuid = '%s'))"
                    "  OR ROWID IN"
                    "     (SELECT task FROM task_users WHERE user ="
                    "      (SELECT ROWID FROM users"
                    "       WHERE users.uuid = '%s')"
                    "      AND actions & %u = %u));",
                    resource,
                    resource,
                    uuid,
                    current_credentials.uuid,
                    current_credentials.uuid,
                    actions,
                    actions);

  ret = sql_int (0, 0,
                 "SELECT count(*) FROM %ss"
                 " WHERE uuid = '%s'"
                 " AND ((owner IS NULL) OR (owner ="
                 " (SELECT users.ROWID FROM users WHERE users.uuid = '%s'))"
                 " OR ROWID IN"
                 " (SELECT %s FROM %s_users WHERE user ="
                 "  (SELECT ROWID FROM users"
                 "   WHERE users.uuid = '%s')"
                 "  AND actions & %u = %u));",
                 resource,
                 uuid,
                 current_credentials.uuid,
                 resource,
                 resource,
                 current_credentials.uuid,
                 actions,
                 actions);

  return ret;
}

/**
 * @brief Test whether a user owns a resource.
 *
 * @param[in]  resource  Type of resource, for example "task".
 * @param[in]  uuid      UUID of resource.
 *
 * @return 1 if user owns resource, else 0.
 */
static int
user_owns_trash_uuid (const char *resource, const char *uuid)
{
  int ret;

  assert (current_credentials.uuid);

  ret = sql_int (0, 0,
                 "SELECT count(*) FROM %ss_trash"
                 " WHERE uuid = '%s'"
                 " AND ((owner IS NULL) OR (owner ="
                 " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                 resource,
                 uuid,
                 current_credentials.uuid);

  return ret;
}

/**
 * @brief Test whether a user owns a resource.
 *
 * @param[in]  resource  Type of resource, for example "report_format".
 * @param[in]  field     Field to compare with value.
 * @param[in]  value     Identifier value of resource.
 *
 * @return 1 if user owns resource, else 0.
 */
static int
user_owns (const char *resource, const char *field, const char *value)
{
  int ret;

  assert (current_credentials.uuid);

  ret = sql_int (0, 0,
                 "SELECT count(*) FROM %ss"
                 " WHERE %s = '%s'"
                 " AND ((owner IS NULL) OR (owner ="
                 " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                 resource,
                 field,
                 value,
                 current_credentials.uuid);

  return ret;
}

/**
 * @brief Test whether a user owns a result.
 *
 * @param[in]  uuid      UUID of result.
 *
 * @return 1 if user owns result, else 0.
 */
static int
user_owns_result (const char *uuid)
{
  int ret;

  assert (current_credentials.uuid);

  ret = sql_int (0, 0,
                 "SELECT count(*) FROM results, report_results, reports"
                 " WHERE results.uuid = '%s'"
                 " AND report_results.result = results.ROWID"
                 " AND report_results.report = reports.ROWID"
                 " AND ((reports.owner IS NULL) OR (reports.owner ="
                 " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                 uuid,
                 current_credentials.uuid);

  return ret;
}

/**
 * @brief Ensure a string is in an array.
 *
 * @param[in]  array   Array.
 * @param[in]  string  String.  Copied into array.
 */
static void
array_add_new_string (array_t *array, const gchar *string)
{
  guint index;
  for (index = 0; index < array->len; index++)
    if (strcmp (g_ptr_array_index (array, index), string) == 0)
      return;
  array_add (array, g_strdup (string));
}

/**
 * @brief Find a resource in the trashcan given a UUID.
 *
 * @param[in]   type      Type of resource.
 * @param[in]   uuid      UUID of resource.
 * @param[out]  resource  Resource return, 0 if succesfully failed to find resource.
 *
 * @return FALSE on success (including if failed to find resource), TRUE on error.
 */
static gboolean
find_trash (const char *type, const char *uuid, resource_t *resource)
{
  gchar *quoted_uuid = sql_quote (uuid);
  if (user_owns_trash_uuid (type, quoted_uuid) == 0)
    {
      g_free (quoted_uuid);
      *resource = 0;
      return FALSE;
    }
  switch (sql_int64 (resource, 0, 0,
                     "SELECT ROWID FROM %ss_trash WHERE uuid = '%s';",
                     type,
                     quoted_uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *resource = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        g_free (quoted_uuid);
        return TRUE;
        break;
    }

  g_free (quoted_uuid);
  return FALSE;
}

/**
 * @brief Convert an OTP time into seconds since epoch.
 *
 * Use UTC as timezone.
 *
 * @param[in]  text_time  Time as text in ctime format.
 *
 * @return Time since epoch.
 */
static int
parse_otp_time (const char *text_time)
{
  int epoch_time;
  struct tm tm;
  gchar *tz;

  /* Scanner sends UTC in ctime format: "Wed Jun 30 21:49:08 1993". */

  /* Store current TZ. */
  tz = getenv ("TZ") ? g_strdup (getenv ("TZ")) : NULL;

  if (setenv ("TZ", "UTC", 1) == -1)
    {
      g_warning ("%s: Failed to switch to UTC", __FUNCTION__);
      setenv ("TZ", tz, 1);
      g_free (tz);
      return 0;
    }

  if (strptime ((char*) text_time, "%a %b %d %H:%M:%S %Y", &tm) == NULL)
    {
      g_warning ("%s: Failed to parse time", __FUNCTION__);
      setenv ("TZ", tz, 1);
      g_free (tz);
      return 0;
    }
  epoch_time = mktime (&tm);
  if (epoch_time == -1)
    {
      g_warning ("%s: Failed to make time", __FUNCTION__);
      setenv ("TZ", tz, 1);
      g_free (tz);
      return 0;
    }

  /* Revert to stored TZ. */
  if (tz)
    {
      if (setenv ("TZ", tz, 1) == -1)
        {
          g_warning ("%s: Failed to switch to original TZ", __FUNCTION__);
          g_free (tz);
          return 0;
        }
    }
  else
    unsetenv ("TZ");

  g_free (tz);
  return epoch_time;
}

/**
 * @brief Convert a ctime into seconds since epoch.
 *
 * Use the current timezone.
 *
 * @param[in]  text_time  Time as text in ctime format.
 *
 * @return Time since epoch.
 */
static int
parse_ctime (const char *text_time)
{
  int epoch_time;
  struct tm tm;

  /* ctime format: "Wed Jun 30 21:49:08 1993". */

  if (strptime ((char*) text_time, "%a %b %d %H:%M:%S %Y", &tm) == NULL)
    {
      g_warning ("%s: Failed to parse time", __FUNCTION__);
      return 0;
    }
  epoch_time = mktime (&tm);
  if (epoch_time == -1)
    {
      g_warning ("%s: Failed to make time", __FUNCTION__);
      return 0;
    }

  return epoch_time;
}

/**
 * @brief Convert an ISO time into seconds since epoch.
 *
 * For backward compatibility, if the conversion fails try parse in ctime
 * format.
 *
 * @param[in]  text_time  Time as text in ISO format: 2011-11-03T09:23:28+02:00.
 *
 * @return Time since epoch.  0 on error.
 */
static int
parse_iso_time (const char *text_time)
{
  int epoch_time;
  struct tm tm;

  if (strptime ((char*) text_time, "%FT%T%z", &tm) == NULL)
    {
      gchar *tz;

      if (strptime ((char*) text_time, "%FT%TZ", &tm) == NULL)
        return parse_ctime (text_time);

      /* Store current TZ. */
      tz = getenv ("TZ") ? g_strdup (getenv ("TZ")) : NULL;

      if (setenv ("TZ", "UTC", 1) == -1)
        {
          g_warning ("%s: Failed to switch to UTC", __FUNCTION__);
          setenv ("TZ", tz, 1);
          g_free (tz);
          return 0;
        }

      if (strptime ((char*) text_time, "%FT%TZ", &tm) == NULL)
        {
          assert (0);
          g_warning ("%s: Failed to parse time", __FUNCTION__);
          setenv ("TZ", tz, 1);
          g_free (tz);
          return 0;
        }

      epoch_time = mktime (&tm);
      if (epoch_time == -1)
        {
          g_warning ("%s: Failed to make time", __FUNCTION__);
          setenv ("TZ", tz, 1);
          g_free (tz);
          return 0;
        }

      /* Revert to stored TZ. */
      if (tz)
        {
          if (setenv ("TZ", tz, 1) == -1)
            {
              g_warning ("%s: Failed to switch to original TZ", __FUNCTION__);
              g_free (tz);
              return 0;
            }
        }
      else
        unsetenv ("TZ");

      g_free (tz);
    }
  else
    {
      epoch_time = mktime (&tm);
      if (epoch_time == -1)
        {
          g_warning ("%s: Failed to make time", __FUNCTION__);
          return 0;
        }
    }

  return epoch_time;
}

/**
 * @brief Create an ISO time from seconds since epoch.
 *
 * @param[in]  epoch_time  Time in seconds from epoch.
 *
 * @return Pointer to ISO time in static memory, or NULL on error.
 */
char *
iso_time (time_t *epoch_time)
{
  struct tm *tm;
  static char time_string[100];

  tm = localtime (epoch_time);
  if (timezone == 0)
    {
      if (strftime (time_string, 98, "%FT%TZ", tm) == 0)
        return NULL;
    }
  else
    {
      int len;

      if (strftime (time_string, 98, "%FT%T%z", tm) == 0)
        return NULL;

      /* Insert the ISO 8601 colon by hand. */
      len = strlen (time_string);
      time_string[len + 1] = '\0';
      time_string[len] = time_string[len - 1];
      time_string[len - 1] = time_string[len - 2];
      time_string[len - 2] = ':';
    }

  return time_string;
}

/**
 * @brief Create an ISO time from seconds since epoch, given a timezone.
 *
 * @param[in]  epoch_time  Time in seconds from epoch.
 * @param[in]  timezone    Timezone.
 *
 * @return Pointer to ISO time in static memory, or NULL on error.
 */
char *
iso_time_tz (time_t *epoch_time, const char *timezone)
{
  gchar *tz;
  char *ret;

  if (timezone == NULL)
    return iso_time (epoch_time);

  /* Store current TZ. */
  tz = getenv ("TZ") ? g_strdup (getenv ("TZ")) : NULL;

  if (setenv ("TZ", timezone, 1) == -1)
    {
      g_warning ("%s: Failed to switch to timezone", __FUNCTION__);
      setenv ("TZ", tz, 1);
      g_free (tz);
      return iso_time (epoch_time);
    }

  tzset ();
  ret = iso_time (epoch_time);

  /* Revert to stored TZ. */
  if (tz)
    {
      if (setenv ("TZ", tz, 1) == -1)
        {
          g_warning ("%s: Failed to switch to original TZ", __FUNCTION__);
          g_free (tz);
          return ret;
        }
    }
  else
    unsetenv ("TZ");

  g_free (tz);
  return ret;
}

/**
 * @brief Get the current offset from UTC of a timezone.
 *
 * @param[in]  zone  Timezone, or NULL for UTC.
 *
 * @return Seconds east of UTC.
 */
long
current_offset (const char *zone)
{
  gchar *tz;
  long offset;
  time_t now;
  struct tm *now_broken;

  if (zone == NULL)
    return 0;

  /* Store current TZ. */
  tz = getenv ("TZ") ? g_strdup (getenv ("TZ")) : NULL;

  if (setenv ("TZ", zone, 1) == -1)
    {
      g_warning ("%s: Failed to switch to timezone", __FUNCTION__);
      setenv ("TZ", tz, 1);
      g_free (tz);
      return 0;
    }

  tzset ();

  time (&now);
  now_broken = localtime (&now);
  if (setenv ("TZ", "UTC", 1) == -1)
    {
      g_warning ("%s: Failed to switch to UTC", __FUNCTION__);
      setenv ("TZ", tz, 1);
      g_free (tz);
      return 0;
    }
  tzset ();
  offset = - (now - mktime (now_broken));

  /* Revert to stored TZ. */
  if (tz)
    {
      if (setenv ("TZ", tz, 1) == -1)
        {
          g_warning ("%s: Failed to switch to original TZ", __FUNCTION__);
          g_free (tz);
          return 0;
        }
    }
  else
    unsetenv ("TZ");

  g_free (tz);
  return offset;
}

/**
 * @brief Get the offset from UTC of a timezone at a particular time.
 *
 * @param[in]  zone  Timezone, or NULL for UTC.
 * @param[in]  time  Time.
 *
 * @return Seconds east of UTC.
 */
long
time_offset (const char *zone, time_t time)
{
  gchar *tz;
  struct tm *time_broken;
  int mins;
  char buf[100];

  if (zone == NULL || strcmp (zone, "UTC") == 0)
    return 0;

  /* Store current TZ. */
  tz = getenv ("TZ") ? g_strdup (getenv ("TZ")) : NULL;

  if (setenv ("TZ", zone, 1) == -1)
    {
      g_warning ("%s: Failed to switch to timezone", __FUNCTION__);
      setenv ("TZ", tz, 1);
      g_free (tz);
      return 0;
    }

  tzset ();

  time_broken = localtime (&time);
  if (strftime (buf, 100, "%z", time_broken) == 0)
    {
      g_warning ("%s: Failed to format timezone", __FUNCTION__);
      setenv ("TZ", tz, 1);
      g_free (tz);
      return 0;
    }

  if (strlen (buf) > 3)
    {
      mins = atoi (buf);
      mins /= 100;
      mins *= 60;
      mins += atoi (buf + 3);
    }
  else
    mins = 0;

  /* Revert to stored TZ. */
  if (tz)
    {
      if (setenv ("TZ", tz, 1) == -1)
        {
          g_warning ("%s: Failed to switch to original TZ", __FUNCTION__);
          g_free (tz);
          return mins * 60;
        }
    }
  else
    unsetenv ("TZ");

  g_free (tz);
  return mins * 60;
}

/**
 * @brief Find a string in an array.
 *
 * @param[in]  array   Array.
 * @param[in]  string  String.
 *
 * @return The string from the array if found, else NULL.
 */
static gchar*
array_find_string (array_t *array, const gchar *string)
{
  guint index;
  for (index = 0; index < array->len; index++)
    {
      gchar *ele;
      ele = (gchar*) g_ptr_array_index (array, index);
      if (ele && (strcmp (ele, string) == 0))
        return ele;
    }
  return NULL;
}

/**
 * @brief Compares two string for g_ptr_array_sort.
 *
 * @param[in]  arg_one  Pointer to first string.
 * @param[in]  arg_two  Pointer to second string.
 *
 * @return -1, 0 or 1 if first given result is less than, equal to or greater
 *         than second.
 */
static gint
compare_strings (gconstpointer arg_one, gconstpointer arg_two)
{
  gchar *one = *((gchar**) arg_one);
  gchar *two = *((gchar**) arg_two);
  return strcmp (one, two);
}

/**
 * @brief Find a string in a glib style string vector.
 *
 * @param[in]  vector  Vector.
 * @param[in]  string  String.
 *
 * @return The string from the vector if found, else NULL.
 */
static const gchar*
vector_find_string (const gchar **vector, const gchar *string)
{
  if (vector == NULL)
    return NULL;
  while (*vector)
    if (strcmp (*vector, string) == 0)
      return *vector;
    else
      vector++;
  return NULL;
}


/* Filter utilities. */

/**
 * @brief Keyword type.
 */
typedef enum
{
  KEYWORD_TYPE_NUMBER,
  KEYWORD_TYPE_STRING
} keyword_type_t;

/**
 * @brief Comparison returns.
 */
typedef enum
{
  KEYWORD_RELATION_APPROX,
  KEYWORD_RELATION_COLUMN_ABOVE,
  KEYWORD_RELATION_COLUMN_APPROX,
  KEYWORD_RELATION_COLUMN_EQUAL,
  KEYWORD_RELATION_COLUMN_BELOW
} keyword_relation_t;

/**
 * @brief Keyword.
 */
struct keyword
{
  gchar *column;                 ///< The column prefix, or NULL.
  int equal;                     ///< Whether the keyword is like "=example".
  int number;                    ///< The number, if the keyword is a number.
  int quoted;                    ///< Whether the keyword was quoted.
  gchar *string;                 ///< The keyword string, outer quotes removed.
  keyword_type_t type;           ///< Type of keyword.
  keyword_relation_t relation;   ///< The relation.
};

/**
 * @brief Keyword type.
 */
typedef struct keyword keyword_t;

/**
 * @brief Free a keyword.
 *
 * @param[in]  keyword  Filter keyword.
 */
static void
keyword_free (keyword_t* keyword)
{
  g_free (keyword->string);
  g_free (keyword->column);
}

/**
 * @brief Parse a filter keyword.
 *
 * @param[in]  keyword  Filter keyword.
 */
static void
parse_keyword (keyword_t* keyword)
{
  gchar *string;

  if (keyword->column == NULL)
    {
      keyword->relation = KEYWORD_RELATION_APPROX;
      keyword->type = KEYWORD_TYPE_STRING;
      return;
    }

  /* The type. */

  string = keyword->string;
  if (*string && *string == '-' && strlen (string) > 1) string++;
  while (*string && isdigit (*string)) string++;
  if (*string)
    {
      struct tm date;
      gchar next;
      memset (&date, 0, sizeof (date));
      next = *(string + 1);
      if (next == '\0' && *string == 's')
        {
          time_t now;
          now = time (NULL);
          keyword->number = now + atoi (keyword->string);
          keyword->type = KEYWORD_TYPE_NUMBER;
        }
      else if (next == '\0' && *string == 'm')
        {
          time_t now;
          now = time (NULL);
          keyword->number = now + (atoi (keyword->string) * 60);
          keyword->type = KEYWORD_TYPE_NUMBER;
        }
      else if (next == '\0' && *string == 'h')
        {
          time_t now;
          now = time (NULL);
          keyword->number = now + (atoi (keyword->string) * 3600);
          keyword->type = KEYWORD_TYPE_NUMBER;
        }
      else if (next == '\0' && *string == 'd')
        {
          time_t now;
          now = time (NULL);
          keyword->number = now + (atoi (keyword->string) * 86400);
          keyword->type = KEYWORD_TYPE_NUMBER;
        }
      else if (next == '\0' && *string == 'w')
        {
          time_t now;
          now = time (NULL);
          keyword->number = now + atoi (keyword->string) * 604800;
          keyword->type = KEYWORD_TYPE_NUMBER;
        }
      else if (next == '\0' && *string == 'M')
        {
          time_t now;
          now = time (NULL);
          keyword->number = add_months (now, atoi (keyword->string));
          keyword->type = KEYWORD_TYPE_NUMBER;
        }
      else if (next == '\0' && *string == 'y')
        {
          time_t now;
          now = time (NULL);
          keyword->number = add_months (now, atoi (keyword->string) * 12);
          keyword->type = KEYWORD_TYPE_NUMBER;
        }
      else if (strptime (keyword->string, "%Y-%m-%dT%H:%M", &date))
        {
          keyword->number = mktime (&date);
          keyword->type = KEYWORD_TYPE_NUMBER;
        }
      else if (strptime (keyword->string, "%Y-%m-%d", &date))
        {
          keyword->number = mktime (&date);
          keyword->type = KEYWORD_TYPE_NUMBER;
        }
      else
        keyword->type = KEYWORD_TYPE_STRING;
    }
  else
    {
      keyword->number = atoi (keyword->string);
      keyword->type = KEYWORD_TYPE_NUMBER;
    }
}

/**
 * @brief Check whether a keyword has any effect in the filter.
 *
 * Some keywords are redundant, like a second sort= keyword.
 *
 * @param[in]  array    Array of existing keywords.
 * @param[in]  keyword  Keyword under consideration.
 *
 * @return 0 no, 1 yes.
 */
static int
keyword_applies (array_t *array, const keyword_t *keyword)
{
  if (keyword->column
      && ((strcmp (keyword->column, "sort") == 0)
          || (strcmp (keyword->column, "sort-reverse") == 0))
      && (keyword->relation == KEYWORD_RELATION_COLUMN_EQUAL))
    {
      int index;

      index = array->len;
      while (index--)
        {
          keyword_t *item;
          item = (keyword_t*) g_ptr_array_index (array, index);
          if (item->column
              && ((strcmp (item->column, "sort") == 0)
                  || (strcmp (item->column, "sort-reverse") == 0)))
            return 0;
        }
      return 1;
    }

  if (keyword->column
      && (strcmp (keyword->column, "first") == 0))
    {
      int index;

      index = array->len;
      while (index--)
        {
          keyword_t *item;
          item = (keyword_t*) g_ptr_array_index (array, index);
          if (item->column && (strcmp (item->column, "first") == 0))
            return 0;
        }
    }

  if (keyword->column
      && (strcmp (keyword->column, "rows") == 0))
    {
      int index;

      index = array->len;
      while (index--)
        {
          keyword_t *item;
          item = (keyword_t*) g_ptr_array_index (array, index);
          if (item->column && (strcmp (item->column, "rows") == 0))
            return 0;
        }
    }

  if (keyword->column
      && (strcmp (keyword->column, "apply_overrides") == 0))
    {
      int index;

      index = array->len;
      while (index--)
        {
          keyword_t *item;
          item = (keyword_t*) g_ptr_array_index (array, index);
          if (item->column && (strcmp (item->column, "apply_overrides") == 0))
            return 0;
        }
    }

  return 1;
}

/**
 * @brief Free a split filter.
 *
 * @param[in]  split  Split filter.
 */
static void
filter_free (array_t *split)
{
  keyword_t **point;
  for (point = (keyword_t**) split->pdata; *point; point++)
    keyword_free (*point);
  array_free (split);
}

/**
 * @brief Split the filter term into parts.
 *
 * @param[in]  given_filter  Filter term.
 *
 * @return Array of strings, the parts.
 */
static array_t *
split_filter (const gchar* given_filter)
{
  int in_quote, between;
  array_t *parts;
  const gchar *current_part, *filter;
  keyword_t *keyword;

  filter = given_filter;
  parts = make_array ();
  in_quote = 0;
  between = 1;
  keyword = NULL;
  current_part = filter;  /* To silence compiler warning. */
  while (*filter)
    {
      switch (*filter)
        {
          case '=':
            if (between)
              {
                /* Empty index.  Start a part. */
                keyword = g_malloc0 (sizeof (keyword_t));
                keyword->equal = 1;
                current_part = filter + 1;
                between = 0;
                break;
              }
          case '~':
          case '>':
          case '<':
            if (between)
              {
                /* Empty index.  Just start a part for now. */
                keyword = g_malloc0 (sizeof (keyword_t));
                current_part = filter;
                between = 0;
                break;
              }
            if (in_quote)
              break;
            /* End of an index. */
            if (keyword == NULL)
              {
                assert (0);
                break;
              }
            if (keyword->column)
              /* Already had an index char. */
              break;
            if (filter <= (current_part - 1))
              {
                assert (0);
                break;
              }
            keyword->column = g_strndup (current_part,
                                         filter - current_part);
            current_part = filter + 1;
            switch (*filter)
              {
                case '=':
                  keyword->relation = KEYWORD_RELATION_COLUMN_EQUAL;
                  break;
                case '~':
                  keyword->relation = KEYWORD_RELATION_COLUMN_APPROX;
                  break;
                case '>':
                  keyword->relation = KEYWORD_RELATION_COLUMN_ABOVE;
                  break;
                case '<':
                  keyword->relation = KEYWORD_RELATION_COLUMN_BELOW;
                  break;
              }
            break;

          case ' ':
          case '\t':
          case '\n':
          case '\r':
            if (in_quote || between)
              break;
            /* End of a part. */
            if (keyword == NULL)
              {
                assert (0);
                break;
              }
            keyword->string = g_strndup (current_part, filter - current_part);
            parse_keyword (keyword);
            if (keyword_applies (parts, keyword))
              array_add (parts, keyword);
            keyword = NULL;
            between = 1;
            break;

          case '"':
            if (in_quote)
              {
                /* End of a quoted part. */
                if (keyword == NULL)
                  {
                    assert (0);
                    break;
                  }
                keyword->quoted = 1;
                keyword->string = g_strndup (current_part,
                                             filter - current_part);
                parse_keyword (keyword);
                if (keyword_applies (parts, keyword))
                  array_add (parts, keyword);
                keyword = NULL;
                in_quote = 0;
                between = 1;
              }
            else if (between)
              {
                /* Start of a quoted part. */
                keyword = g_malloc0 (sizeof (keyword_t));
                in_quote = 1;
                current_part = filter + 1;
                between = 0;
              }
            else if (keyword->column && filter == current_part)
              {
                /* A quoted index. */
                in_quote = 1;
                current_part++;
              }
            else if (keyword->equal && filter == current_part)
              {
                /* A quoted exact term, like ="abc". */
                in_quote = 1;
                current_part++;
              }
            /* Else just a quote in a keyword, like ab"cd. */
            break;

          default:
            if (between)
              {
                /* Start of a part. */
                keyword = g_malloc0 (sizeof (keyword_t));
                current_part = filter;
                between = 0;
              }
            break;
        }
      filter++;
    }
  if (between == 0)
    {
      if (keyword == NULL)
        assert (0);
      else
        {
          keyword->quoted = in_quote;
          keyword->string = g_strdup (current_part);
          parse_keyword (keyword);
          if (keyword_applies (parts, keyword))
            array_add (parts, keyword);
          keyword = NULL;
        }
    }
  assert (keyword == NULL);

  {
    int index, first, max, sort;
    keyword_t *keyword;

    index = parts->len;
    first = max = sort = 0;
    while (index--)
      {
        keyword_t *item;
        item = (keyword_t*) g_ptr_array_index (parts, index);
        if (item->column && (strcmp (item->column, "first") == 0))
          first = 1;
        else if (item->column && (strcmp (item->column, "rows") == 0))
          max = 1;
        else if (item->column
                 && ((strcmp (item->column, "sort") == 0)
                     || (strcmp (item->column, "sort-reverse") == 0)))
          sort = 1;
      }

    if (first == 0)
      {
        keyword = g_malloc0 (sizeof (keyword_t));
        keyword->column = g_strdup ("first");
        keyword->string = g_strdup ("1");
        keyword->type = KEYWORD_TYPE_STRING;
        keyword->relation = KEYWORD_RELATION_COLUMN_EQUAL;
        array_add (parts, keyword);
      }

    if (max == 0)
      {
        keyword = g_malloc0 (sizeof (keyword_t));
        keyword->column = g_strdup ("rows");
        /* If there was a filter, make max_return default to Rows Per
         * Page.  This keeps the pre-filters OMP behaviour when the filter
         * is empty, but is more convenenient for clients that set the
         * filter. */
        if (strlen (given_filter))
          keyword->string = g_strdup ("-2");
        else
          keyword->string = g_strdup ("-1");
        keyword->type = KEYWORD_TYPE_STRING;
        keyword->relation = KEYWORD_RELATION_COLUMN_EQUAL;
        array_add (parts, keyword);
      }

    if (sort == 0)
      {
        keyword = g_malloc0 (sizeof (keyword_t));
        keyword->column = g_strdup ("sort");
        keyword->string = g_strdup ("name");
        keyword->type = KEYWORD_TYPE_STRING;
        keyword->relation = KEYWORD_RELATION_COLUMN_EQUAL;
        array_add (parts, keyword);
      }
  }

  array_add (parts, NULL);

  return parts;
}

/**
 * @brief Get info from a filter.
 *
 * @param[in]   filter      Filter.
 * @param[out]  first       Number of first item.
 * @param[out]  max         Max number of rows.
 * @param[out]  sort_field  Sort field.
 * @param[out]  sort_order  Sort order.
 */
void
manage_filter_controls (const gchar *filter, int *first, int *max,
                        gchar **sort_field, int *sort_order)
{
  keyword_t **point;
  array_t *split;

  if (filter == NULL)
    {
      if (first)
        *first = 1;
      if (max)
        *max = -1;
      if (sort_field)
        *sort_field = g_strdup ("name");
      if (sort_order)
        *sort_order = 1;
      return;
    }

  split = split_filter (filter);
  point = (keyword_t**) split->pdata;
  if (first)
    {
      *first = 1;
      while (*point)
        {
          keyword_t *keyword;

          keyword = *point;
          if (keyword->column && (strcmp (keyword->column, "first") == 0))
            {
              *first = atoi (keyword->string);
              if (*first < 0)
                *first = 0;
              break;
            }
          point++;
        }
    }

  point = (keyword_t**) split->pdata;
  if (max)
    {
      *max = -1;
      while (*point)
        {
          keyword_t *keyword;

          keyword = *point;
          if (keyword->column && (strcmp (keyword->column, "rows") == 0))
            {
              *max = atoi (keyword->string);
              if (*max == -2)
                setting_value_int ("5f5a8712-8017-11e1-8556-406186ea4fc5",
                                   max);
              else if (*max < 1)
                *max = -1;
              break;
            }
          point++;
        }
    }

  point = (keyword_t**) split->pdata;
  if (sort_field || sort_order)
    {
      if (sort_field) *sort_field = NULL;
      if (sort_order) *sort_order = 1;
      while (*point)
        {
          keyword_t *keyword;

          keyword = *point;
          if (keyword->column
              && (strcmp (keyword->column, "sort") == 0))
            {
              if (sort_field) *sort_field = g_strdup (keyword->string);
              if (sort_order) *sort_order = 1;
              break;
            }
          if (keyword->column
              && (strcmp (keyword->column, "sort-reverse") == 0))
            {
              if (sort_field) *sort_field = g_strdup (keyword->string);
              if (sort_order) *sort_order = 0;
              break;
            }
          point++;
        }
      if (sort_field && (*sort_field == NULL))
        *sort_field = g_strdup ("name");
    }

  filter_free (split);
  return;
}

/**
 * @brief Get an int column from a filter split.
 *
 * @param[in]  point   Filter split.
 * @param[in]  column  Name of column.
 * @param[out] val     Value of column.
 *
 * @return 0 success, 1 fail.
 */
int
filter_control_int (keyword_t **point, const char *column, int *val)
{
  if (val)
    while (*point)
      {
        keyword_t *keyword;

        keyword = *point;
        if (keyword->column
            && (strcmp (keyword->column, column) == 0))
          {
            *val = atoi (keyword->string);
            return 0;
          }
        point++;
      }
  return 1;
}

/**
 * @brief Get a string column from a filter split.
 *
 * @param[in]  point   Filter split.
 * @param[in]  column  Name of column.
 * @param[out] string  Value of column, freshly allocated.
 *
 * @return 0 success, 1 fail.
 */
int
filter_control_str (keyword_t **point, const char *column, gchar **string)
{
  if (string)
    while (*point)
      {
        keyword_t *keyword;

        keyword = *point;
        if (keyword->column
            && (strcmp (keyword->column, column) == 0))
          {
            *string = g_strdup (keyword->string);
            return 0;
          }
        point++;
      }
  return 1;
}

/**
 * @brief Get info from a filter for report.
 *
 * @param[in]   filter      Filter.
 * @param[out]  first       Number of first item.
 * @param[out]  max         Max number of rows.
 * @param[out]  sort_field  Sort field.
 * @param[out]  sort_order  Sort order.
 * @param[out]  result_hosts_only  Whether to show only hosts with results.
 * @param[out]  min_cvss_base      Minimum CVSS base of included results.  All
 *                                 results if NULL.
 * @param[out]  levels         String describing threat levels (message types)
 *                             to include in count (for example, "hmlgd" for
 *                             High, Medium, Low, loG and Debug).  All levels if
 *                             NULL.
 * @param[out]  delta_states   String describing delta states to include in count
 *                             (for example, "sngc" Same, New, Gone and Changed).
 *                             All levels if NULL.
 * @param[out]  search_phrase      Phrase that results must include.  All results
 *                                 if NULL or "".
 * @param[out]  search_phrase_exact  Whether search phrase is exact.
 * @param[out]  autofp             Whether to apply auto FP filter.
 * @param[out]  show_closed_cves   Whether to include the Closed CVEs host detail.
 * @param[out]  notes              Whether to include notes.
 * @param[out]  overrides          Whether to include overrides.
 */
void
manage_report_filter_controls (const gchar *filter, int *first, int *max,
                               gchar **sort_field, int *sort_order,
                               int *result_hosts_only, gchar **min_cvss_base,
                               gchar **levels, gchar **delta_states,
                               gchar **search_phrase, int *search_phrase_exact,
                               int *autofp, int *show_closed_cves, int *notes,
                               int *overrides)
{
  keyword_t **point;
  array_t *split;
  int val;
  gchar *string;

  if (filter == NULL)
    return;

  split = split_filter (filter);
  point = (keyword_t**) split->pdata;
  if (first)
    {
      *first = 1;
      while (*point)
        {
          keyword_t *keyword;

          keyword = *point;
          if (keyword->column && (strcmp (keyword->column, "first") == 0))
            {
              *first = atoi (keyword->string);
              if (*first < 0)
                *first = 0;
              break;
            }
          point++;
        }
      /* Switch from 1 to 0 indexing. */

      (*first)--;
    }

  point = (keyword_t**) split->pdata;
  if (max)
    {
      *max = 100;
      while (*point)
        {
          keyword_t *keyword;

          keyword = *point;
          if (keyword->column && (strcmp (keyword->column, "rows") == 0))
            {
              *max = atoi (keyword->string);
              if (*max == -2)
                setting_value_int ("5f5a8712-8017-11e1-8556-406186ea4fc5",
                                   max);
              else if (*max < 1)
                *max = -1;
              break;
            }
          point++;
        }
    }

  point = (keyword_t**) split->pdata;
  if (sort_field || sort_order)
    {
      if (sort_field) *sort_field = NULL;
      if (sort_order) *sort_order = 1;
      while (*point)
        {
          keyword_t *keyword;

          keyword = *point;
          if (keyword->column
              && (strcmp (keyword->column, "sort") == 0))
            {
              if (sort_field) *sort_field = g_strdup (keyword->string);
              if (sort_order) *sort_order = 1;
              break;
            }
          if (keyword->column
              && (strcmp (keyword->column, "sort-reverse") == 0))
            {
              if (sort_field) *sort_field = g_strdup (keyword->string);
              if (sort_order) *sort_order = 0;
              break;
            }
          point++;
        }
      if (sort_field && (*sort_field == NULL))
        *sort_field = g_strdup ("name");
    }

  if (search_phrase)
    {
      GString *phrase;
      phrase = g_string_new ("");
      point = (keyword_t**) split->pdata;
      if (search_phrase_exact)
        *search_phrase_exact = 0;
      while (*point)
        {
          keyword_t *keyword;

          keyword = *point;
          if (keyword->column == NULL)
            {
              if (search_phrase_exact && keyword->equal)
                /* If one term is "exact" then the search is "exact", because
                 * for reports the filter terms are combined into a single
                 * search term. */
                *search_phrase_exact = 1;
              g_string_append_printf (phrase, "%s ", keyword->string);
            }
          point++;
        }
      *search_phrase = g_strchomp (phrase->str);
      g_string_free (phrase, FALSE);
    }

  if (result_hosts_only)
    {
      if (filter_control_int ((keyword_t **) split->pdata,
                              "result_hosts_only",
                              &val))
        *result_hosts_only = 1;
      else
        *result_hosts_only = val;
    }

  if (autofp)
    {
      if (filter_control_int ((keyword_t **) split->pdata,
                              "autofp",
                              &val))
        *autofp = 0;
      else
        *autofp = val;
    }

  if (show_closed_cves)
    {
      if (filter_control_int ((keyword_t **) split->pdata,
                              "show_closed_cves",
                              &val))
        *show_closed_cves = 0;
      else
        *show_closed_cves = val;
    }

  if (notes)
    {
      if (filter_control_int ((keyword_t **) split->pdata,
                              "notes",
                              &val))
        *notes = 1;
      else
        *notes = val;
    }

  if (overrides)
    {
      if (filter_control_int ((keyword_t **) split->pdata,
                              "overrides",
                              &val))
        *overrides = 1;
      else
        *overrides = val;
    }

  if (delta_states)
    {
      if (filter_control_str ((keyword_t **) split->pdata,
                              "delta_states",
                              &string))
        *delta_states = NULL;
      else
        *delta_states = string;
    }

  if (levels)
    {
      if (filter_control_str ((keyword_t **) split->pdata,
                              "levels",
                              &string))
        *levels = NULL;
      else
        *levels = string;
    }

  if (min_cvss_base)
    {
      if (filter_control_str ((keyword_t **) split->pdata,
                              "min_cvss_base",
                              &string))
        *min_cvss_base = NULL;
      else
        *min_cvss_base = string;
    }

  filter_free (split);
  return;
}

/**
 * @brief Append relation to filter.
 *
 * @param[in]  clean     Filter.
 * @param[in]  keyword   Keyword
 * @param[in]  relation  Relation char.
 */
static void
append_relation (GString *clean, keyword_t *keyword, const char relation)
{
  if ((strcmp (keyword->column, "rows") == 0)
      && (strcmp (keyword->string, "-2") == 0))
    {
      int max;
      setting_value_int ("5f5a8712-8017-11e1-8556-406186ea4fc5",
                         &max);
      g_string_append_printf (clean,
                              " %s%c%i",
                              keyword->column,
                              relation,
                              max);
    }
  else if (keyword->quoted)
    g_string_append_printf (clean,
                            " %s%c\"%s\"",
                            keyword->column,
                            relation,
                            keyword->string);
  else
    g_string_append_printf (clean,
                            " %s%c%s",
                            keyword->column,
                            relation,
                            keyword->string);
}

/**
 * @brief Clean a filter.
 *
 * @param[in]  filter  Filter.
 *
 * @return Cleaned filter.
 */
gchar *
manage_clean_filter (const gchar *filter)
{
  GString *clean;
  keyword_t **point;
  array_t *split;

  if (filter == NULL)
    return g_strdup ("");

  clean = g_string_new ("");
  split = split_filter (filter);
  point = (keyword_t**) split->pdata;
  while (*point)
    {
      keyword_t *keyword;

      keyword = *point;
      if (keyword->column)
        switch (keyword->relation)
          {
            case KEYWORD_RELATION_COLUMN_EQUAL:
              append_relation (clean, keyword, '=');
              break;
            case KEYWORD_RELATION_COLUMN_APPROX:
              append_relation (clean, keyword, '~');
              break;
            case KEYWORD_RELATION_COLUMN_ABOVE:
              append_relation (clean, keyword, '>');
              break;
            case KEYWORD_RELATION_COLUMN_BELOW:
              append_relation (clean, keyword, '<');
              break;

            case KEYWORD_RELATION_APPROX:
              if (keyword->quoted)
                g_string_append_printf (clean, " \"%s\"", keyword->string);
              else
                g_string_append_printf (clean, " %s", keyword->string);
              break;
          }
      else
        if (keyword->quoted)
          g_string_append_printf (clean, " %s\"%s\"",
                                  keyword->equal ? "=" : "",
                                  keyword->string);
        else
          g_string_append_printf (clean, " %s%s",
                                  keyword->equal ? "=" : "",
                                  keyword->string);
      point++;
    }
  filter_free (split);
  return g_strstrip (g_string_free (clean, FALSE));
}

/**
 * @brief Return SQL join words for filter_clause.
 *
 * @param[in]  first         Whether keyword is first.
 * @param[in]  last_was_and  Whether last keyword was "and".
 * @param[in]  last_was_not  Whether last keyword was "not".
 *
 * @return SQL join words.
 */
static const char *
get_join (int first, int last_was_and, int last_was_not)
{
  const char *pre;
  if (first)
    {
      if (last_was_not)
        pre = "NOT ";
      else
        pre = "";
    }
  else
    {
      if (last_was_and)
        {
          if (last_was_not)
            pre = " AND NOT ";
          else
            pre = " AND ";
        }
      else
        {
          if (last_was_not)
            pre = " OR NOT ";
          else
            pre = " OR ";
        }
    }
  return pre;
}

/**
 * @brief Return SQL WHERE clause for restricting a SELECT to a filter term.
 *
 * @param[in]  type     Resource type.
 * @param[in]  filter   Filter term.
 * @param[out] trash    Whether the trash table is being queried.
 * @param[in]  columns  Columns in the SQL statement.
 * @param[out] order_return  If given then order clause.
 * @param[out] first_return  If given then first row.
 * @param[out] max_return    If given then max rows.
 *
 * @return WHERE clause for filter if one is required, else NULL.
 */
static gchar *
filter_clause (const char* type, const char* filter, const char **columns,
               int trash, gchar **order_return, int *first_return,
               int *max_return)
{
  GString *clause, *order;
  keyword_t **point;
  int first_keyword, first_order, last_was_and, last_was_not;
  array_t *split;

  if (filter == NULL)
    filter = "";

  while (*filter && isspace (*filter)) filter++;

  /* Add SQL to the clause for each keyword or phrase. */

  if (max_return)
    *max_return = -1;

  clause = g_string_new ("");
  order = g_string_new ("");
  split = split_filter (filter);
  point = (keyword_t**) split->pdata;
  first_keyword = 1;
  last_was_and = 0;
  last_was_not = 0;
  first_order = 1;
  while (*point)
    {
      gchar *quoted_keyword, *quoted_column;
      int index;
      keyword_t *keyword;

      keyword = *point;

      if ((keyword->column == NULL)
          && (strlen (keyword->string) == 0))
        {
          point++;
          continue;
        }

      if ((keyword->column == NULL)
          && (strcasecmp (keyword->string, "or") == 0))
        {
          point++;
          continue;
        }

      if ((keyword->column == NULL)
          && (strcasecmp (keyword->string, "and") == 0))
        {
          last_was_and = 1;
          point++;
          continue;
        }

      if ((keyword->column == NULL)
          && (strcasecmp (keyword->string, "not") == 0))
        {
          last_was_not = 1;
          point++;
          continue;
        }

      /* Check for ordering parts, like sort=name or sort-reverse=string. */

      if (keyword->column && (strcasecmp (keyword->column, "sort") == 0))
        {
          if (strcmp (keyword->string, "ROWID")
              && (vector_find_string (columns, keyword->string) == 0))
            {
              point++;
              continue;
            }

          if (first_order)
            {
              if ((strcmp (type, "task") == 0)
                  && (strcmp (keyword->string, "threat") == 0))
                g_string_append_printf (order,
                                        " ORDER BY %s"
                                        " COLLATE collate_threat"
                                        " ASC",
                                        keyword->string);
              else if ((strcmp (type, "note")
                   && strcmp (type, "override"))
                  || (strcmp (keyword->string, "nvt")
                      && strcmp (keyword->string, "name")))
                g_string_append_printf (order, " ORDER BY %s COLLATE NOCASE ASC",
                                        keyword->string);
              else
                /* Special case for notes text sorting. */
                g_string_append_printf (order,
                                        " ORDER BY nvt ASC, %ss%s.text COLLATE NOCASE ASC",
                                        type,
                                        trash ? "_trash" : "");
              first_order = 0;
            }
          else
            /* To help the client split_filter restricts the filter to one
             * sorting term, preventing this from happening. */
            g_string_append_printf (order, ", %s ASC",
                                    keyword->string);
          point++;
          continue;
        }
      else if (keyword->column
               && (strcasecmp (keyword->column, "sort-reverse") == 0))
        {
          if (strcmp (keyword->string, "ROWID")
              && (vector_find_string (columns, keyword->string) == 0))
            {
              point++;
              continue;
            }

          if (first_order)
            {
              if ((strcmp (type, "task") == 0)
                  && (strcmp (keyword->string, "threat") == 0))
                g_string_append_printf (order,
                                        " ORDER BY %s"
                                        " COLLATE collate_threat"
                                        " DESC",
                                        keyword->string);
              else if ((strcmp (type, "note")
                   && strcmp (type, "override"))
                  || (strcmp (keyword->string, "nvt")
                      && strcmp (keyword->string, "name")))
                g_string_append_printf (order, " ORDER BY %s COLLATE NOCASE DESC",
                                        keyword->string);
              else
                /* Special case for notes text sorting. */
                g_string_append_printf (order,
                                        " ORDER BY nvt ASC, %ss%s.text COLLATE NOCASE ASC",
                                        type,
                                        trash ? "_trash" : "");
              first_order = 0;
            }
          else
            /* To help the client split_filter restricts the filter to one
             * sorting term, preventing this from happening. */
            g_string_append_printf (order, ", %s DESC",
                                    keyword->string);
          point++;
          continue;
        }
      else if (keyword->column
               && (strcasecmp (keyword->column, "first") == 0))
        {
          if (first_return)
            {
              /* Subtract 1 to switch from 1 to 0 indexing. */
              *first_return = atoi (keyword->string) - 1;
              if (*first_return < 0)
                *first_return = 0;
            }

          point++;
          continue;
        }
      else if (keyword->column
               && (strcasecmp (keyword->column, "rows") == 0))
        {
          if (max_return)
            *max_return = atoi (keyword->string);

          point++;
          continue;
        }

      /* Add SQL to the clause for each column name. */

      if (keyword->relation == KEYWORD_RELATION_COLUMN_EQUAL)
        {
          if (vector_find_string (columns, keyword->column) == 0)
            {
              last_was_and = 0;
              last_was_not = 0;
              point++;
              continue;
            }

          if ((strlen (keyword->column) > 3)
              && (strcmp (keyword->column + strlen (keyword->column) - 3, "_id")
                  == 0)
              && strcasecmp (keyword->column, "nvt_id"))
            {
              gchar *type_term;

              type_term = g_strndup (keyword->column,
                                     strlen (keyword->column) - 3);
              if (valid_type (type_term) == 0)
                {
                  g_free (type_term);
                  last_was_and = 0;
                  last_was_not = 0;
                  point++;
                  continue;
                }

              quoted_keyword = sql_quote (keyword->string);
              g_string_append_printf (clause,
                                      "%s((SELECT ROWID FROM %ss"
                                      "    WHERE %ss.uuid = '%s')"
                                      "   = %ss.%s",
                                      get_join (first_keyword, last_was_and,
                                                last_was_not),
                                      type_term,
                                      type_term,
                                      quoted_keyword,
                                      type,
                                      type_term);
              g_free (type_term);
            }
          else
            {
              quoted_keyword = sql_quote (keyword->string);
              quoted_column = sql_quote (keyword->column);
              if (strcmp (quoted_keyword, ""))
                g_string_append_printf (clause,
                                        "%s(CAST (%s AS TEXT) = '%s'",
                                        get_join (first_keyword, last_was_and,
                                                  last_was_not),
                                        quoted_column,
                                        quoted_keyword);
              else
                g_string_append_printf (clause,
                                        "%s((%s IS NULL OR CAST (%s AS TEXT) = '%s')",
                                        get_join (first_keyword, last_was_and,
                                                  last_was_not),
                                        quoted_column,
                                        quoted_column,
                                        quoted_keyword);
              g_free (quoted_column);
            }
        }
      else if (keyword->relation == KEYWORD_RELATION_COLUMN_APPROX)
        {
          if (vector_find_string (columns, keyword->column) == 0)
            {
              last_was_and = 0;
              last_was_not = 0;
              point++;
              continue;
            }

          quoted_keyword = sql_quote (keyword->string);
          quoted_column = sql_quote (keyword->column);
          g_string_append_printf (clause,
                                  "%s(CAST (%s AS TEXT) LIKE '%%%%%s%%%%'",
                                  get_join (first_keyword, last_was_and,
                                            last_was_not),
                                  quoted_column,
                                  quoted_keyword);
          g_free (quoted_column);
        }
      else if (keyword->relation == KEYWORD_RELATION_COLUMN_ABOVE)
        {
          if (vector_find_string (columns, keyword->column) == 0)
            {
              last_was_and = 0;
              last_was_not = 0;
              point++;
              continue;
            }

          quoted_keyword = sql_quote (keyword->string);
          quoted_column = sql_quote (keyword->column);
          if (keyword->type == KEYWORD_TYPE_NUMBER)
            g_string_append_printf (clause,
                                    "%s(CAST (%s AS INTEGER) > %i",
                                    get_join (first_keyword, last_was_and,
                                              last_was_not),
                                    quoted_column,
                                    keyword->number);
          else
            g_string_append_printf (clause,
                                    "%s(CAST (%s AS TEXT) > '%s'",
                                    get_join (first_keyword, last_was_and,
                                              last_was_not),
                                    quoted_column,
                                    quoted_keyword);
          g_free (quoted_column);
        }
      else if (keyword->relation == KEYWORD_RELATION_COLUMN_BELOW)
        {
          if (vector_find_string (columns, keyword->column) == 0)
            {
              last_was_and = 0;
              last_was_not = 0;
              point++;
              continue;
            }

          quoted_keyword = sql_quote (keyword->string);
          quoted_column = sql_quote (keyword->column);
          if (keyword->type == KEYWORD_TYPE_NUMBER)
            g_string_append_printf (clause,
                                    "%s(CAST (%s AS INTEGER) < %i",
                                    get_join (first_keyword, last_was_and,
                                              last_was_not),
                                    quoted_column,
                                    keyword->number);
          else
            g_string_append_printf (clause,
                                    "%s(CAST (%s AS TEXT) > '%s'",
                                    get_join (first_keyword, last_was_and,
                                              last_was_not),
                                    quoted_column,
                                    quoted_keyword);
          g_free (quoted_column);
        }
      else if (keyword->equal)
        {
          const char *column;

          /* Keyword like "=example". */

          g_string_append_printf (clause,
                                  "%s(",
                                  (first_keyword
                                    ? ""
                                    : (last_was_and ? " AND " : " OR ")));

          quoted_keyword = sql_quote (keyword->string);
          if (last_was_not)
            for (index = 0;
                 (column = columns[index]) != NULL;
                 index++)
              {
                quoted_column = sql_quote (column);
                g_string_append_printf (clause,
                                        "%s"
                                        "(%s IS NULL"
                                        " OR CAST (%s AS TEXT)"
                                        " != '%s')",
                                        (index ? " AND " : ""),
                                        quoted_column,
                                        quoted_column,
                                        quoted_keyword);
                g_free (quoted_column);
              }
          else
            for (index = 0;
                 (column = columns[index]) != NULL;
                 index++)
              {
                quoted_column = sql_quote (column);
                g_string_append_printf (clause,
                                        "%sCAST (%s AS TEXT)"
                                        " = '%s'",
                                        (index ? " OR " : ""),
                                        quoted_column,
                                        quoted_keyword);
                g_free (quoted_column);
              }
        }
      else
        {
          const char *column;

          g_string_append_printf (clause,
                                  "%s(",
                                  (first_keyword
                                    ? ""
                                    : (last_was_and ? " AND " : " OR ")));

          quoted_keyword = sql_quote (keyword->string);
          if (last_was_not)
            for (index = 0;
                 (column = columns[index]) != NULL;
                 index++)
              {
                quoted_column = sql_quote (column);
                g_string_append_printf (clause,
                                        "%s"
                                        "(%s IS NULL"
                                        " OR CAST (%s AS TEXT)"
                                        " NOT LIKE '%%%%%s%%%%')",
                                        (index ? " AND " : ""),
                                        quoted_column,
                                        quoted_column,
                                        quoted_keyword);
                g_free (quoted_column);
              }
          else
            for (index = 0;
                 (column = columns[index]) != NULL;
                 index++)
              {
                quoted_column = sql_quote (column);
                g_string_append_printf (clause,
                                        "%sCAST (%s AS TEXT)"
                                        " LIKE '%%%%%s%%%%'",
                                        (index ? " OR " : ""),
                                        quoted_column,
                                        quoted_keyword);
                g_free (quoted_column);
              }
        }

      g_string_append (clause, ")");
      g_free (quoted_keyword);
      first_keyword = 0;

      last_was_and = 0;
      last_was_not = 0;
      point++;
    }
  filter_free (split);

  if (order_return)
    *order_return = g_string_free (order, FALSE);

  if (max_return)
    {
      if (*max_return == -2)
        setting_value_int ("5f5a8712-8017-11e1-8556-406186ea4fc5",
                           max_return);
      else if (*max_return < 1)
        *max_return = -1;
    }

  if (strlen (clause->str))
    return g_string_free (clause, FALSE);

  g_string_free (clause, TRUE);
  return NULL;
}


/* Resources. */

/**
 * @brief Filter columns for GET iterator.
 */
#define ANON_GET_ITERATOR_FILTER_COLUMNS "uuid", \
 "created", "modified"

/**
 * @brief Filter columns for GET iterator.
 */
#define GET_ITERATOR_FILTER_COLUMNS "uuid", "name", "comment", \
 "created", "modified"

/**
 * @brief Columns for GET iterator.
 */
#define ANON_GET_ITERATOR_COLUMNS                            \
  "ROWID, uuid, '', '', iso_time (creation_time),"           \
  " iso_time (modification_time), creation_time AS created," \
  " modification_time AS modified"

/**
 * @brief Columns for GET iterator.
 */
#define GET_ITERATOR_COLUMNS_PREFIX(prefix)                           \
  prefix "ROWID, " prefix "uuid, " prefix "name, " prefix "comment,"  \
  " iso_time (" prefix "creation_time),"                              \
  " iso_time (" prefix "modification_time),"                          \
  " " prefix "creation_time AS created,"                              \
  " " prefix "modification_time AS modified"

/**
 * @brief Columns for GET iterator.
 */
#define GET_ITERATOR_COLUMNS GET_ITERATOR_COLUMNS_PREFIX("")

/**
 * @brief Number of columns for GET iterator.
 */
#define GET_ITERATOR_COLUMN_COUNT 8

/**
 * @brief Check whether a resource type name is valid.
 *
 * @param[in]  type  Type of resource.
 *
 * @return 1 yes, 0 no.
 */
int
valid_type (const char* type)
{
  return (strcasecmp (type, "agent") == 0)
         || (strcasecmp (type, "alert") == 0)
         || (strcasecmp (type, "config") == 0)
         || (strcasecmp (type, "lsc_credential") == 0)
         || (strcasecmp (type, "filter") == 0)
         || (strcasecmp (type, "note") == 0)
         || (strcasecmp (type, "override") == 0)
         || (strcasecmp (type, "port_list") == 0)
         || (strcasecmp (type, "report") == 0)
         || (strcasecmp (type, "report_format") == 0)
         || (strcasecmp (type, "result") == 0)
         || (strcasecmp (type, "schedule") == 0)
         || (strcasecmp (type, "slave") == 0)
         || (strcasecmp (type, "target") == 0)
         || (strcasecmp (type, "task") == 0)
         || (strcasecmp (type, "info") == 0);
}

/**
 * @brief Return pretty name of type.
 *
 * @param[in]  type  Database name.
 *
 * @return 1 yes, 0 no.
 */
const char *
type_pretty_name (const char* type)
{
  if (strcasecmp (type, "agent") == 0)
    return "Agent";
  if (strcasecmp (type, "alert") == 0)
    return "Alert";
  if (strcasecmp (type, "config") == 0)
    return "Config";
  if (strcasecmp (type, "lsc_credential") == 0)
    return "Credential";
  if (strcasecmp (type, "filter") == 0)
    return "Filter";
  if (strcasecmp (type, "note") == 0)
    return "Note";
  if (strcasecmp (type, "override") == 0)
    return "Override";
  if (strcasecmp (type, "port_list") == 0)
    return "Port List";
  if (strcasecmp (type, "report") == 0)
    return "Report";
  if (strcasecmp (type, "report_format") == 0)
    return "Report Format";
  if (strcasecmp (type, "result") == 0)
    return "Result";
  if (strcasecmp (type, "schedule") == 0)
    return "Schedule";
  if (strcasecmp (type, "slave") == 0)
    return "Slave";
  if (strcasecmp (type, "target") == 0)
    return "Target";
  if (strcasecmp (type, "task") == 0)
    return "Task";
  if (strcasecmp (type, "info") == 0)
    return "SecInfo";
  return "";
}

/**
 * @brief Return DB name of type.
 *
 * @param[in]  type  Database or pretty name.
 *
 * @return Database name of type if possible, else NULL.
 */
const char *
type_db_name (const char* type)
{
  if (type == NULL)
    return NULL;

  if (valid_type (type))
    return type;

  if (strcasecmp (type, "Agent") == 0)
    return "agent";
  if (strcasecmp (type, "Alert") == 0)
    return "alert";
  if (strcasecmp (type, "Config") == 0)
    return "config";
  if (strcasecmp (type, "Credential") == 0)
    return "lsc_credential";
  if (strcasecmp (type, "Filter") == 0)
    return "filter";
  if (strcasecmp (type, "Note") == 0)
    return "note";
  if (strcasecmp (type, "Override") == 0)
    return "override";
  if (strcasecmp (type, "Port List") == 0)
    return "port_list";
  if (strcasecmp (type, "Report") == 0)
    return "report";
  if (strcasecmp (type, "Report Format") == 0)
    return "report_format";
  if (strcasecmp (type, "Result") == 0)
    return "result";
  if (strcasecmp (type, "Schedule") == 0)
    return "schedule";
  if (strcasecmp (type, "Slave") == 0)
    return "slave";
  if (strcasecmp (type, "Target") == 0)
    return "target";
  if (strcasecmp (type, "Task") == 0)
    return "task";
  if (strcasecmp (type, "SecInfo") == 0)
    return "info";
  return NULL;
}

/**
 * @brief Check whether a type has a name and comment.
 *
 * @param[in]  type          Type of resource.
 *
 * @return 1 yes, 0 no.
 */
int
type_named (const char *type)
{
  return strcasecmp (type, "note")
         && strcasecmp (type, "override");
}

/**
 * @brief Check whether a type has a users table.
 *
 * @param[in]  type          Type of resource.
 *
 * @return 1 yes, 0 no.
 */
int
type_has_users (const char *type)
{
  return strcasecmp (type, "task") == 0;
}

/**
 * @brief Check whether a resource type has an owner.
 *
 * @param[in]  type  Type of resource.
 *
 * @return 1 yes, 0 no.
 */
int
type_owned (const char* type)
{
  return strcasecmp (type, "info");
}

/**
 * @brief Check whether the trash is in the real table.
 *
 * @param[in]  type  Type of resource.
 *
 * @return 1 yes, 0 no.
 */
static int
type_trash_in_table (const char *type)
{
  return strcasecmp (type, "task") == 0;
}

/**
 * @brief Find a resource given a UUID.
 *
 * @param[in]   type       Type of resource.
 * @param[in]   uuid       UUID of resource.
 * @param[out]  resource   Resource return, 0 if succesfully failed to find resource.
 *
 * @return FALSE on success (including if failed to find resource), TRUE on error.
 */
gboolean
find_resource (const char* type, const char* uuid, resource_t* resource)
{
  gchar *quoted_uuid;
  quoted_uuid = sql_quote (uuid);
  if (user_owns_uuid (type, quoted_uuid) == 0)
    {
      g_free (quoted_uuid);
      *resource = 0;
      return FALSE;
    }
  // TODO should really check type
  switch (sql_int64 (resource, 0, 0,
                     "SELECT ROWID FROM %ss WHERE uuid = '%s';",
                     type,
                     quoted_uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *resource = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        g_free (quoted_uuid);
        return TRUE;
        break;
    }

  g_free (quoted_uuid);
  return FALSE;
}

/**
 * @brief Find a resource for a set of actions, given a UUID.
 *
 * @param[in]   type       Type of resource.
 * @param[in]   uuid       UUID of resource.
 * @param[out]  resource   Resource return, 0 if succesfully failed to find resource.
 * @param[in]   actions    Actions.
 *
 * @return FALSE on success (including if failed to find resource), TRUE on error.
 */
gboolean
find_resource_for_actions (const char* type, const char* uuid,
                           resource_t* resource, const char *actions)
{
  gchar *quoted_uuid = sql_quote (uuid);
  if (user_has_access_uuid (type, quoted_uuid, actions) == 0)
    {
      g_free (quoted_uuid);
      *resource = 0;
      return FALSE;
    }
  // TODO should really check type
  switch (sql_int64 (resource, 0, 0,
                     "SELECT ROWID FROM %ss WHERE uuid = '%s';",
                     type, quoted_uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *resource = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        g_free (quoted_uuid);
        return TRUE;
        break;
    }

  g_free (quoted_uuid);
  return FALSE;
}

/**
 * @brief Create a resource from an existing resource.
 *
 * @param[in]  type          Type of resource.
 * @param[in]  name          Name of new resource.  NULL to copy from existing.
 * @param[in]  comment       Comment on new resource.  NULL to copy from existing.
 * @param[in]  resource_id   UUID of existing resource.
 * @param[in]  columns       Extra columns in resource.
 * @param[out] new_resource  New resource.
 *
 * @return 0 success, 1 resource exists already, 2 failed to find existing
 *         resource, -1 error.
 */
int
copy_resource (const char *type, const char *name, const char *comment,
               const char *resource_id, const char *columns,
               resource_t* new_resource)
{
  gchar *quoted_name, *quoted_uuid, *uniquify;
  int named;
  user_t owner;

  assert (current_credentials.uuid);

  if (resource_id == NULL)
    return -1;

  sql ("BEGIN IMMEDIATE;");

  if (find_user (current_credentials.username, &owner)
      || owner == 0)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  named = type_named (type);

  if (named && name && strlen (name))
    {
      quoted_name = sql_quote (name);
      if (sql_int (0, 0,
                   "SELECT COUNT(*) FROM %ss WHERE name = '%s'"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                   type,
                   quoted_name,
                   current_credentials.uuid))
        {
          sql ("ROLLBACK;");
          g_free (quoted_name);
          return 1;
        }
    }
  else
    quoted_name = NULL;

  quoted_uuid = sql_quote (resource_id);
  if (sql_int (0, 0,
               "SELECT COUNT(*) FROM %ss"
               " WHERE uuid = '%s'"
               " AND ((owner IS NULL) OR (owner = %llu))",
               type,
               quoted_uuid,
               owner)
      == 0)
    {
      sql ("ROLLBACK;");
      g_free (quoted_name);
      g_free (quoted_uuid);
      return 2;
    }

  /* Copy the existing resource. */

  uniquify = g_strdup_printf ("uniquify ('%s', name, %llu, ' Clone')",
                              type, owner);
  if (named && comment && strlen (comment))
    {
      gchar *quoted_comment;
      quoted_comment = sql_nquote (comment, strlen (comment));
      sql ("INSERT INTO %ss"
           " (uuid, owner, name, comment, creation_time, modification_time%s%s)"
           " SELECT make_uuid (),"
           " (SELECT ROWID FROM users where users.uuid = '%s'),"
           " %s%s%s, '%s', now (), now ()%s%s"
           " FROM %ss WHERE uuid = '%s';",
           type,
           columns ? ", " : "",
           columns ? columns : "",
           current_credentials.uuid,
           quoted_name ? "'" : "",
           quoted_name ? quoted_name : uniquify,
           quoted_name ? "'" : "",
           quoted_comment,
           columns ? ", " : "",
           columns ? columns : "",
           type,
           quoted_uuid);
      g_free (quoted_comment);
    }
  else if (named)
    sql ("INSERT INTO %ss"
         " (uuid, owner, name, comment, creation_time, modification_time%s%s)"
         " SELECT make_uuid (), %llu, %s%s%s, comment, now (), now ()%s%s"
         " FROM %ss WHERE uuid = '%s';",
         type,
         columns ? ", " : "",
         columns ? columns : "",
         owner,
         quoted_name ? "'" : "",
         quoted_name ? quoted_name : uniquify,
         quoted_name ? "'" : "",
         columns ? ", " : "",
         columns ? columns : "",
         type,
         quoted_uuid);
  else
    sql ("INSERT INTO %ss"
         " (uuid, owner, creation_time, modification_time%s%s)"
         " SELECT make_uuid (), %llu, now (), now ()%s%s"
         " FROM %ss WHERE uuid = '%s';",
         type,
         columns ? ", " : "",
         columns ? columns : "",
         owner,
         columns ? ", " : "",
         columns ? columns : "",
         type,
         quoted_uuid);


  if (new_resource)
    *new_resource = sqlite3_last_insert_rowid (task_db);

  sql ("COMMIT;");
  g_free (quoted_uuid);
  g_free (quoted_name);
  g_free (uniquify);
  return 0;
}

/**
 * @brief Initialise a target iterator, limited to the current user's targets.
 *
 * @param[in]  iterator        Iterator.
 * @param[in]  type            Type of resource.
 * @param[in]  get             GET data.
 * @param[in]  columns         Columns for SQL.
 * @param[in]  trash_columns   Columns for SQL trash case.
 * @param[in]  filter_columns  Columns for filter.
 * @param[in]  resource        Resource.
 * @param[in]  distinct        Whether the query should be distinct.  Skipped
 *                             for trash and single resource.
 * @param[in]  extra_tables    Join tables.  Skipped for trash and single
 *                             resource.
 * @param[in]  extra_where     Extra WHERE clauses.  Skipped for single
 *                             resource.
 *
 * @return 0 success, 2 failed to find filter.
 */
static int
init_user_get_iterator (iterator_t* iterator, const char *type,
                        const get_data_t *get, const char *columns,
                        const char *trash_columns, const char **filter_columns,
                        resource_t resource, int distinct,
                        const char *extra_tables, const char *extra_where)
{
  gchar *clause, *order, *filter;
  int first, max;

  assert (current_credentials.uuid);
  assert (get);

  if (get->filt_id && strcmp (get->filt_id, "0"))
    {
      filter = filter_term (get->filt_id);
      if (filter == NULL)
        return 2;
    }
  else
    filter = NULL;

  clause = filter_clause (type, filter ? filter : get->filter, filter_columns,
                          get->trash, &order, &first, &max);

  g_free (filter);

  if (resource && get->trash)
    init_iterator (iterator,
                   "SELECT %s"
                   " FROM %ss%s"
                   " WHERE ROWID = %llu"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                   "%s;",
                   trash_columns ? trash_columns : columns,
                   type,
                   type_trash_in_table (type) ? "" : "_trash",
                   resource,
                   current_credentials.uuid,
                   order);
  else if (get->trash)
    init_iterator (iterator,
                   "SELECT %s"
                   " FROM %ss%s"
                   " WHERE ((owner IS NULL) OR (owner ="
                   " (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                   "%s"
                   "%s;",
                   trash_columns ? trash_columns : columns,
                   type,
                   type_trash_in_table (type) ? "" : "_trash",
                   current_credentials.uuid,
                   extra_where ? extra_where : "",
                   order);
  else if (resource)
    init_iterator (iterator,
                   "SELECT %s"
                   " FROM %ss"
                   " WHERE ROWID = %llu"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                   "%s;",
                   columns,
                   type,
                   resource,
                   current_credentials.uuid,
                   order);
  else
    init_iterator (iterator,
                   "SELECT%s %s"
                   " FROM %ss%s"
                   " WHERE ((%ss.owner IS NULL) OR (%ss.owner ="
                   " (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                   "%s%s%s%s%s"
                   " LIMIT %i OFFSET %i;",
                   distinct ? " DISTINCT" : "",
                   columns,
                   type,
                   extra_tables ? extra_tables : "",
                   type,
                   type,
                   current_credentials.uuid,
                   clause ? " AND (" : "",
                   clause ? clause : "",
                   clause ? ")" : "",
                   extra_where ? extra_where : "",
                   order,
                   max,
                   first);

  g_free (clause);
  return 0;
}

/**
 * @brief Initialise a GET iterator, including observed resources.
 *
 * @param[in]  iterator        Iterator.
 * @param[in]  type            Type of resource.
 * @param[in]  get             GET data.
 * @param[in]  columns         Columns for SQL.
 * @param[in]  trash_columns   Columns for SQL trash case.
 * @param[in]  filter_columns  Columns for filter.
 * @param[in]  used_by         Type that uses these resources, or NULL.
 * @param[in]  distinct        Whether the query should be distinct.  Skipped
 *                             for trash and single resource.
 * @param[in]  extra_tables    Join tables.  Skipped for trash and single
 *                             resource.
 * @param[in]  extra_where     Extra WHERE clauses.  Skipped for single
 *                             resource.
 * @param[in]  owned           Only get items owned by the current user.
 *
 * @return 0 success, 1 failed to find resource, 2 failed to find filter, -1
 *         error.
 */
static int
init_get_iterator (iterator_t* iterator, const char *type,
                   const get_data_t *get, const char *columns,
                   const char *trash_columns, const char **filter_columns,
                   const char *used_by, int distinct, const char *extra_tables,
                   const char *extra_where, int owned)
{
  int first, max, actions;
  gchar *clause, *order, *used_by_clause, *filter, *owned_and_used_by_clause;
  resource_t resource = 0;

  assert (used_by ? current_credentials.uuid : "1");
  assert (get);

  if (columns == NULL)
    {
      assert (0);
      return -1;
    }

  if (get->id && owned && (current_credentials.uuid == NULL))
    {
      gchar *quoted_uuid = sql_quote (get->id);
      switch (sql_int64 (&resource, 0, 0,
                         "SELECT ROWID FROM %ss WHERE uuid = '%s';",
                         type, quoted_uuid))
        {
          case 0:
            break;
          case 1:        /* Too few rows in result of query. */
            g_free (quoted_uuid);
            return 1;
            break;
          default:       /* Programming error. */
            assert (0);
          case -1:
            g_free (quoted_uuid);
            return -1;
            break;
        }
      g_free (quoted_uuid);
    }
  else if (get->id && owned)
    {
      if (find_resource_for_actions (type, get->id, &resource, get->actions))
        return -1;
      if (resource == 0)
        return 1;
    }

  if (get->actions == NULL || strlen (get->actions) == 0)
    actions = 0;
  else
    actions = parse_actions (get->actions);

  if (get->filt_id && strcmp (get->filt_id, "0"))
    {
      filter = filter_term (get->filt_id);
      if (filter == NULL)
        return 2;
    }
  else
    filter = NULL;

  clause = filter_clause (type, filter ? filter : get->filter, filter_columns,
                          get->trash, &order, &first, &max);

  g_free (filter);

  if (used_by && actions)
    used_by_clause = g_strdup_printf ("  OR"
                                      "  (SELECT %ss.ROWID FROM %ss"
                                      "   WHERE %s = %ss.ROWID)"
                                      "  IN"
                                      "  (SELECT %s FROM %s_users"
                                      "   WHERE user ="
                                      "   (SELECT ROWID FROM users"
                                      "    WHERE users.uuid = '%s')"
                                      "   AND actions & %u = %u)",
                                      used_by,
                                      used_by,
                                      type,
                                      type,
                                      used_by,
                                      used_by,
                                      current_credentials.uuid,
                                      actions,
                                      actions);
  else
    used_by_clause = NULL;

  if (owned)
    {
      if (resource || (current_credentials.uuid == NULL))
        owned_and_used_by_clause
         = g_strdup_printf (" (1%s)",
                            used_by_clause ? used_by_clause : "1");
      else if (get->trash)
        owned_and_used_by_clause = g_strdup_printf (" ((owner IS NULL) OR (owner ="
                                                    "  (SELECT ROWID FROM users"
                                                    "   WHERE users.uuid = '%s'))"
                                                    " %s)",
                                                    current_credentials.uuid,
                                                    used_by_clause ? used_by_clause : "");
      else if (type_has_users (type))
        owned_and_used_by_clause
         = g_strdup_printf (" ((%ss.owner IS NULL) OR (%ss.owner ="
                            "  (SELECT ROWID FROM users"
                            "   WHERE users.uuid = '%s')"
                            "  OR (ROWID IN (SELECT %s FROM %s_users"
                            "                WHERE user ="
                            "                      (SELECT ROWID FROM users"
                            "                       WHERE users.uuid = '%s')"
                            "                AND actions & %u = %u)))"
                            " %s)",
                            type,
                            type,
                            current_credentials.uuid,
                            type,
                            type,
                            current_credentials.uuid,
                            actions,
                            actions,
                            used_by_clause ? used_by_clause : "");
      else
        owned_and_used_by_clause = g_strdup_printf (" ((%ss.owner IS NULL) OR (%ss.owner ="
                                                    "  (SELECT ROWID FROM users"
                                                    "   WHERE users.uuid = '%s'))"
                                                    " %s)",
                                                    type,
                                                    type,
                                                    current_credentials.uuid,
                                                    used_by_clause ? used_by_clause : "");

    }
  else if (used_by_clause)
   owned_and_used_by_clause = g_strdup (used_by_clause);
  else
   owned_and_used_by_clause = g_strdup (" 1");

  g_free (used_by_clause);

  if (resource && get->trash)
    init_iterator (iterator,
                   "SELECT %s"
                   " FROM %ss%s"
                   " WHERE ROWID = %llu"
                   " AND %s"
                   "%s;",
                   trash_columns ? trash_columns : columns,
                   type,
                   type_trash_in_table (type) ? "" : "_trash",
                   resource,
                   owned_and_used_by_clause,
                   order);
  else if (get->trash)
    init_iterator (iterator,
                   "SELECT %s"
                   " FROM %ss%s"
                   " WHERE"
                   "%s"
                   "%s"
                   "%s;",
                   trash_columns ? trash_columns : columns,
                   type,
                   type_trash_in_table (type) ? "" : "_trash",
                   owned_and_used_by_clause,
                   extra_where ? extra_where : "",
                   order);
  else if (resource)
    init_iterator (iterator,
                   "SELECT %s"
                   " FROM %ss"
                   " WHERE ROWID = %llu"
                   " AND %s"
                   "%s;",
                   columns,
                   type,
                   resource,
                   owned_and_used_by_clause,
                   order);
  else
    {
      init_iterator (iterator,
                   "SELECT%s %s"
                   " FROM %ss%s"
                   " WHERE"
                   " %s"
                   "%s%s%s%s%s"
                   " LIMIT %i OFFSET %i;",
                   distinct ? " DISTINCT" : "",
                   columns,
                   type,
                   extra_tables ? extra_tables : "",
                   owned_and_used_by_clause,
                   clause ? " AND (" : "",
                   clause ? clause : "",
                   clause ? ")" : "",
                   extra_where ? extra_where : "",
                   order,
                   max,
                   first);
    }

  g_free (owned_and_used_by_clause);
  g_free (order);
  g_free (clause);
  return 0;
}

/**
 * @brief Count number of a particular resource.
 *
 * @param[in]  type              Type of resource.
 * @param[in]  get               GET params.
 * @param[in]  iterator_columns  Iterator columns.
 * @param[in]  extra_columns     Extra columns.
 * @param[in]  distinct          Whether the query should be distinct.  Skipped
 *                               for trash and single resource.
 * @param[in]  extra_tables      Join tables.  Skipped for trash and single
 *                               resource.
 * @param[in]  extra_where       Extra WHERE clauses.  Skipped for trash and
 *                               single resource.
 * @param[in]  owned             Only count items owned by current user.
 *
 * @return Total number of resources in filtered set.
 */
static int
count (const char *type, const get_data_t *get,
       const char *iterator_columns, const char **extra_columns,
       int distinct, const char *extra_tables, const char *extra_where,
       int owned)
{
  int actions, ret;
  gchar *clause, *owned_clause;
  gchar *filter;

  assert (current_credentials.uuid);
  assert (get);

  if (get->filt_id && strcmp (get->filt_id, "0"))
    {
      filter = filter_term (get->filt_id);
      if (filter == NULL)
        return -1;
    }
  else
    filter = NULL;

  clause = filter_clause (type, filter ? filter : get->filter, extra_columns,
                          get->trash, NULL, NULL, NULL);
  if (owned)
    owned_clause = g_strdup_printf ("((%ss.owner IS NULL) OR (%ss.owner ="
                                    " (SELECT ROWID FROM users"
                                    " WHERE users.uuid = '%s')))",
                                    type,
                                    type,
                                    current_credentials.uuid);
  else
    owned_clause = g_strdup ("1");

  if (type_has_users (type) == 0
      || get->actions == NULL
      || strlen (get->actions) == 0
      || (actions = parse_actions (get->actions)) == 0)
    {
      ret = sql_int (0, 0,
                     "SELECT count (%s%ss.ROWID), %s"
                     " FROM %ss%s"
                     " WHERE %s"
                     "%s%s%s;",
                     distinct ? "DISTINCT " : "",
                     type,
                     iterator_columns,
                     type,
                     extra_tables ? extra_tables : "",
                     owned_clause,
                     clause ? " AND " : "",
                     clause ? clause : "",
                     extra_where ? extra_where : "");
      g_free (owned_clause);
      g_free (clause);
      return ret;
    }

  ret = sql_int (0, 0,
                 "SELECT count (%s%ss.ROWID), %s"
                 " FROM %ss%s"
                 " WHERE (%s OR"
                 "  (ROWID IN"
                 "   (SELECT %s FROM %s_users WHERE user ="
                 "    (SELECT ROWID FROM users"
                 "     WHERE users.uuid = '%s')"
                 "    AND actions & %u = %u)))"
                 "%s%s%s;",
                 distinct ? "DISTINCT " : "",
                 type,
                 iterator_columns,
                 type,
                 extra_tables ? extra_tables : "",
                 owned_clause,
                 type,
                 type,
                 current_credentials.uuid,
                 actions,
                 actions,
                 clause ? " AND " : "",
                 clause ? clause : "",
                 extra_where ? extra_where : "");

  g_free (owned_clause);
  g_free (clause);
  return ret;
}


/* Creation. */

/**
 * @brief Create all tables.
 */
static void
create_tables ()
{
  sql ("CREATE TABLE IF NOT EXISTS agents (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, comment, installer TEXT, installer_64 TEXT, installer_filename, installer_signature_64 TEXT, installer_trust INTEGER, installer_trust_time, howto_install TEXT, howto_use TEXT, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS agents_trash (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, comment, installer TEXT, installer_64 TEXT, installer_filename, installer_signature_64 TEXT, installer_trust INTEGER, installer_trust_time, howto_install TEXT, howto_use TEXT, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS config_preferences (id INTEGER PRIMARY KEY, config INTEGER, type, name, value);");
  sql ("CREATE TABLE IF NOT EXISTS config_preferences_trash (id INTEGER PRIMARY KEY, config INTEGER, type, name, value);");
  sql ("CREATE TABLE IF NOT EXISTS configs (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, nvt_selector, comment, family_count INTEGER, nvt_count INTEGER, families_growing INTEGER, nvts_growing INTEGER, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS configs_trash (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, nvt_selector, comment, family_count INTEGER, nvt_count INTEGER, families_growing INTEGER, nvts_growing INTEGER, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS alert_condition_data (id INTEGER PRIMARY KEY, alert INTEGER, name, data);");
  sql ("CREATE TABLE IF NOT EXISTS alert_condition_data_trash (id INTEGER PRIMARY KEY, alert INTEGER, name, data);");
  sql ("CREATE TABLE IF NOT EXISTS alert_event_data (id INTEGER PRIMARY KEY, alert INTEGER, name, data);");
  sql ("CREATE TABLE IF NOT EXISTS alert_event_data_trash (id INTEGER PRIMARY KEY, alert INTEGER, name, data);");
  sql ("CREATE TABLE IF NOT EXISTS alert_method_data (id INTEGER PRIMARY KEY, alert INTEGER, name, data);");
  sql ("CREATE TABLE IF NOT EXISTS alert_method_data_trash (id INTEGER PRIMARY KEY, alert INTEGER, name, data);");
  sql ("CREATE TABLE IF NOT EXISTS alerts (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, comment, event INTEGER, condition INTEGER, method INTEGER, filter INTEGER, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS alerts_trash (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, comment, event INTEGER, condition INTEGER, method INTEGER, filter INTEGER, filter_location INTEGER, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS filters (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, comment, type, term, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS filters_trash (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, comment, type, term, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS lsc_credentials (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, login, password, comment, public_key TEXT, private_key TEXT, rpm TEXT, deb TEXT, exe TEXT, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS lsc_credentials_trash (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, login, password, comment, public_key TEXT, private_key TEXT, rpm TEXT, deb TEXT, exe TEXT, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS meta (id INTEGER PRIMARY KEY, name UNIQUE, value);");
  sql ("CREATE TABLE IF NOT EXISTS notes (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, nvt, creation_time, modification_time, text, hosts, port, threat, task INTEGER, result INTEGER, end_time);");
  sql ("CREATE TABLE IF NOT EXISTS notes_trash (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, nvt, creation_time, modification_time, text, hosts, port, threat, task INTEGER, result INTEGER, end_time);");
  sql ("CREATE TABLE IF NOT EXISTS nvt_preferences (id INTEGER PRIMARY KEY, name, value);");
  /* nvt_selectors types: 0 all, 1 family, 2 NVT (NVT_SELECTOR_TYPE_* in manage.h). */
  sql ("CREATE TABLE IF NOT EXISTS nvt_selectors (id INTEGER PRIMARY KEY, name, exclude INTEGER, type INTEGER, family_or_nvt, family);");
  sql ("CREATE INDEX IF NOT EXISTS nvt_selectors_by_name ON nvt_selectors (name);");
  sql ("CREATE INDEX IF NOT EXISTS nvt_selectors_by_family_or_nvt ON nvt_selectors (type, family_or_nvt);");
  sql ("CREATE TABLE IF NOT EXISTS nvts (id INTEGER PRIMARY KEY, uuid, oid, version, name, comment, summary, description, copyright, cve, bid, xref, tag, sign_key_ids, category INTEGER, family, cvss_base, risk_factor, creation_time, modification_time);");
  sql ("CREATE INDEX IF NOT EXISTS nvts_by_oid ON nvts (oid);");
  sql ("CREATE INDEX IF NOT EXISTS nvts_by_name ON nvts (name);");
  sql ("CREATE INDEX IF NOT EXISTS nvts_by_family ON nvts (family);");
  sql ("CREATE TABLE IF NOT EXISTS overrides (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, nvt, creation_time, modification_time, text, hosts, port, threat, new_threat, task INTEGER, result INTEGER, end_time);");
  sql ("CREATE TABLE IF NOT EXISTS overrides_trash (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, nvt, creation_time, modification_time, text, hosts, port, threat, new_threat, task INTEGER, result INTEGER, end_time);");
  /* Overlapping port ranges will cause problems, at least for the port
   * counting.  OMP CREATE_PORT_LIST and CREATE_PORT_RANGE check for this,
   * but whoever creates a predefined port list must check this manually. */
  sql ("CREATE TABLE IF NOT EXISTS port_lists (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, comment, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS port_lists_trash (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, comment, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS port_ranges (id INTEGER PRIMARY KEY, uuid UNIQUE, port_list INTEGER, type, start, end, comment, exclude);");
  sql ("CREATE TABLE IF NOT EXISTS port_ranges_trash (id INTEGER PRIMARY KEY, uuid UNIQUE, port_list INTEGER, type, start, end, comment, exclude);");
  sql ("CREATE TABLE IF NOT EXISTS report_host_details (id INTEGER PRIMARY KEY, report_host INTEGER, source_type, source_name, source_description, name, value);");
  sql ("CREATE INDEX IF NOT EXISTS report_host_details_by_report_host_and_name_and_value ON report_host_details (report_host, name, value);");
  sql ("CREATE TABLE IF NOT EXISTS report_hosts (id INTEGER PRIMARY KEY, report INTEGER, host, start_time, end_time, attack_state, current_port, max_port);");
  sql ("CREATE INDEX IF NOT EXISTS report_hosts_by_host ON report_hosts (host);");
  sql ("CREATE INDEX IF NOT EXISTS report_hosts_by_report ON report_hosts (report);");
  sql ("CREATE TABLE IF NOT EXISTS report_format_param_options (id INTEGER PRIMARY KEY, report_format_param, value);");
  sql ("CREATE TABLE IF NOT EXISTS report_format_param_options_trash (id INTEGER PRIMARY KEY, report_format_param, value);");
  sql ("CREATE TABLE IF NOT EXISTS report_format_params (id INTEGER PRIMARY KEY, report_format, name, type INTEGER, value, type_min, type_max, type_regex, fallback);");
  sql ("CREATE TABLE IF NOT EXISTS report_format_params_trash (id INTEGER PRIMARY KEY, report_format, name, type INTEGER, value, type_min, type_max, type_regex, fallback);");
  sql ("CREATE TABLE IF NOT EXISTS report_formats (id INTEGER PRIMARY KEY, uuid, owner INTEGER, name, extension, content_type, summary, description, signature, trust INTEGER, trust_time, flags INTEGER, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS report_formats_trash (id INTEGER PRIMARY KEY, uuid, owner INTEGER, name, extension, content_type, summary, description, signature, trust INTEGER, trust_time, flags INTEGER, original_uuid, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS report_results (id INTEGER PRIMARY KEY, report INTEGER, result INTEGER);");
  sql ("CREATE INDEX IF NOT EXISTS report_results_by_report ON report_results (report);");
  sql ("CREATE INDEX IF NOT EXISTS report_results_by_result ON report_results (result);");
  sql ("CREATE TABLE IF NOT EXISTS reports (id INTEGER PRIMARY KEY, uuid, owner INTEGER, hidden INTEGER, task INTEGER, date INTEGER, start_time, end_time, nbefile, comment, scan_run_status INTEGER, slave_progress, slave_task_uuid, highs, mediums, lows, logs, fps, override_highs, override_mediums, override_lows, override_logs, override_fps);");
  sql ("CREATE TABLE IF NOT EXISTS results (id INTEGER PRIMARY KEY, uuid, task INTEGER, subnet, host, port, nvt, type, description, report)");
  sql ("CREATE INDEX IF NOT EXISTS results_by_host ON results (host);");
  sql ("CREATE INDEX IF NOT EXISTS results_by_report_host ON results (report, host);");
  sql ("CREATE INDEX IF NOT EXISTS results_by_task ON results (task);");
  sql ("CREATE INDEX IF NOT EXISTS results_by_type ON results (type);");
  sql ("CREATE TABLE IF NOT EXISTS schedules (id INTEGER PRIMARY KEY, uuid, owner INTEGER, name, comment, first_time, period, period_months, duration, timezone, initial_offset, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS schedules_trash (id INTEGER PRIMARY KEY, uuid, owner INTEGER, name, comment, first_time, period, period_months, duration, timezone, initial_offset, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS slaves (id INTEGER PRIMARY KEY, uuid, owner INTEGER, name, comment, host, port, login, password, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS slaves_trash (id INTEGER PRIMARY KEY, uuid, owner INTEGER, name, comment, host, port, login, password, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS settings (id INTEGER PRIMARY KEY, uuid, owner INTEGER, name, comment, value);");
  /* port_range in the following two is actually a port list.  Migrating a
   * column rename is lots of work. */
  sql ("CREATE TABLE IF NOT EXISTS targets (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, hosts, comment, lsc_credential INTEGER, ssh_port, smb_lsc_credential INTEGER, port_range, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS targets_trash (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, hosts, comment, lsc_credential INTEGER, ssh_port, smb_lsc_credential INTEGER, port_range, ssh_location INTEGER, smb_location INTEGER, port_list_location INTEGER, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS task_files (id INTEGER PRIMARY KEY, task INTEGER, name, content);");
  sql ("CREATE TABLE IF NOT EXISTS task_alerts (id INTEGER PRIMARY KEY, task INTEGER, alert INTEGER, alert_location INTEGER);");
  sql ("CREATE TABLE IF NOT EXISTS task_preferences (id INTEGER PRIMARY KEY, task INTEGER, name, value);");
  sql ("CREATE TABLE IF NOT EXISTS tasks   (id INTEGER PRIMARY KEY, uuid, owner INTEGER, name, hidden INTEGER, time, comment, description, run_status INTEGER, start_time, end_time, config INTEGER, target INTEGER, schedule INTEGER, schedule_next_time, slave INTEGER, config_location INTEGER, target_location INTEGER, schedule_location INTEGER, slave_location INTEGER, upload_result_count INTEGER, creation_time, modification_time);");
  sql ("CREATE TABLE IF NOT EXISTS task_users (id INTEGER PRIMARY KEY, task INTEGER, user INTEGER, actions INTEGER);");
  sql ("CREATE TABLE IF NOT EXISTS users   (id INTEGER PRIMARY KEY, uuid UNIQUE, name, password, timezone);");

  sql ("ANALYZE;");
}

/**
 * @brief Create all tables, using the version 4 schema.
 */
static void
create_tables_version_4 ()
{
  sql ("CREATE TABLE IF NOT EXISTS config_preferences (id INTEGER PRIMARY KEY, config INTEGER, type, name, value);");
  sql ("CREATE TABLE IF NOT EXISTS configs (id INTEGER PRIMARY KEY, name UNIQUE, nvt_selector, comment, family_count INTEGER, nvt_count INTEGER, families_growing INTEGER, nvts_growing INTEGER);");
  sql ("CREATE TABLE IF NOT EXISTS lsc_credentials (id INTEGER PRIMARY KEY, name, password, comment, public_key TEXT, private_key TEXT, rpm TEXT, deb TEXT, exe TEXT);");
  sql ("CREATE TABLE IF NOT EXISTS meta    (id INTEGER PRIMARY KEY, name UNIQUE, value);");
  sql ("CREATE TABLE IF NOT EXISTS nvt_preferences (id INTEGER PRIMARY KEY, name, value);");
  /* nvt_selectors types: 0 all, 1 family, 2 NVT (NVT_SELECTOR_TYPE_* above). */
  sql ("CREATE TABLE IF NOT EXISTS nvt_selectors (id INTEGER PRIMARY KEY, name, exclude INTEGER, type INTEGER, family_or_nvt, family);");
  sql ("CREATE TABLE IF NOT EXISTS nvts (id INTEGER PRIMARY KEY, oid, version, name, summary, description, copyright, cve, bid, xref, tag, sign_key_ids, category INTEGER, family);");
  sql ("CREATE TABLE IF NOT EXISTS report_hosts (id INTEGER PRIMARY KEY, report INTEGER, host, start_time, end_time, attack_state, current_port, max_port);");
  sql ("CREATE INDEX IF NOT EXISTS report_hosts_by_report_and_host ON report_hosts (report, host);");
  sql ("CREATE TABLE IF NOT EXISTS report_results (id INTEGER PRIMARY KEY, report INTEGER, result INTEGER);");
  sql ("CREATE TABLE IF NOT EXISTS reports (id INTEGER PRIMARY KEY, uuid, hidden INTEGER, task INTEGER, date INTEGER, start_time, end_time, nbefile, comment, scan_run_status INTEGER);");
  sql ("CREATE TABLE IF NOT EXISTS results (id INTEGER PRIMARY KEY, task INTEGER, subnet, host, port, nvt, type, description)");
  sql ("CREATE TABLE IF NOT EXISTS targets (id INTEGER PRIMARY KEY, name, hosts, comment);");
  sql ("CREATE TABLE IF NOT EXISTS task_files (id INTEGER PRIMARY KEY, task INTEGER, name, content);");
  sql ("CREATE TABLE IF NOT EXISTS tasks   (id INTEGER PRIMARY KEY, uuid, name, hidden INTEGER, time, comment, description, owner" /** @todo INTEGER */ ", run_status INTEGER, start_time, end_time, config, target);");
  sql ("CREATE TABLE IF NOT EXISTS users   (id INTEGER PRIMARY KEY, name UNIQUE, password);");
}


/* Migration. */

/**
 * @section procedure_writing_migrator Procedure for writing a migrator
 *
 * Every change that affects the database schema or the format of the data in
 * the database must have a migrator so that someone using an older version of
 * the database can update to the newer version.
 *
 * Simply adding a new table to the database is, however, OK.  At startup, the
 * manager will automatically add a table if it is missing from the database.
 *
 *  - Ensure that the ChangeLog notes the changes to the database and
 *    the increase of OPENVASMD_DATABASE_VERSION, with an entry like
 *
 *        * CMakeLists.txt (OPENVASMD_DATABASE_VERSION): Increase to 6, for...
 *
 *        * src/tasks_sql.h (create_tables): Add new column...
 *
 *  - Add the migrator function in the style of the others.  In particular,
 *    the function must check the version, do the modification and then set
 *    the new version, all inside an exclusive transaction.  Use the generic
 *    iterator (init_iterator, iterator_string, iterator_int64...) because the
 *    specialised iterators (like init_target_iterator) can change behaviour
 *    across Manager SVN versions.  Use copies of any other "manage" interfaces,
 *    for example update_all_config_caches, as these may also change in later
 *    versions of the Manager.
 *
 *  - Remember to ensure that tables exist in the migrator before the migrator
 *    modifies them.  If a migrator modifies a table then the table must either
 *    have existed in database version 0 (listed below), or some earlier
 *    migrator must have added the table, or the migrator must add the table
 *    (using the original schema of the table).
 *
 *  - Add the migrator to the database_migrators array.
 *
 *  - Test that everything still works for a database that has been migrated
 *    from the previous version.
 *
 *  - Test that everything still works for a database that has been migrated
 *    from version 0.
 *
 *  - Commit with a ChangeLog heading like
 *
 *        Add database migration from version 5 to 6.
 *
 * SQL that created database version 0:
 *
 *     CREATE TABLE IF NOT EXISTS config_preferences
 *       (config INTEGER, type, name, value);
 *
 *     CREATE TABLE IF NOT EXISTS configs
 *       (name UNIQUE, nvt_selector, comment, family_count INTEGER,
 *        nvt_count INTEGER, families_growing INTEGER, nvts_growing INTEGER);
 *
 *     CREATE TABLE IF NOT EXISTS meta
 *       (name UNIQUE, value);
 *
 *     CREATE TABLE IF NOT EXISTS nvt_selectors
 *       (name, exclude INTEGER, type INTEGER, family_or_nvt);
 *
 *     CREATE TABLE IF NOT EXISTS nvts
 *       (oid, version, name, summary, description, copyright, cve, bid, xref,
 *        tag, sign_key_ids, category, family);
 *
 *     CREATE TABLE IF NOT EXISTS report_hosts
 *       (report INTEGER, host, start_time, end_time, attack_state,
 *        current_port, max_port);
 *
 *     CREATE TABLE IF NOT EXISTS report_results
 *       (report INTEGER, result INTEGER);
 *
 *     CREATE TABLE IF NOT EXISTS reports
 *       (uuid, hidden INTEGER, task INTEGER, date INTEGER, start_time,
 *        end_time, nbefile, comment);
 *
 *     CREATE TABLE IF NOT EXISTS results
 *       (task INTEGER, subnet, host, port, nvt, type, description);
 *
 *     CREATE TABLE IF NOT EXISTS targets
 *       (name, hosts, comment);
 *
 *     CREATE TABLE IF NOT EXISTS tasks
 *       (uuid, name, hidden INTEGER, time, comment, description, owner,
 *        run_status, start_time, end_time, config, target);
 *
 *     CREATE TABLE IF NOT EXISTS users
 *       (name UNIQUE, password);
 */

/**
 * @brief Backup the database to a file.
 *
 * @param[in]   database     Database to backup.
 * @param[out]  backup_file  Freshly allocated name of backup file.
 *
 * @return 0 success, -1 error.
 */
static int
backup_db (const gchar *database, gchar **backup_file)
{
  gchar *command;
  int ret;

  sql ("BEGIN EXCLUSIVE;");

  command = g_strdup_printf ("cp %s %s.bak > /dev/null 2>&1"
                             "&& cp %s-journal %s.bak-journal > /dev/null 2>&1",
                             database,
                             database,
                             database,
                             database);
  tracef ("   command: %s\n", command);
  ret = system (command);
  g_free (command);

  if (ret == -1 || WEXITSTATUS (ret))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  sql ("COMMIT;");

  if (backup_file)
    *backup_file = g_strdup_printf ("%s.bak", database);

  return 0;
}

/**
 * @brief Backup the database to a file.
 *
 * @param[in]  database  Location of manage database.
 *
 * @return 0 success, -1 error.
 */
int
manage_backup_db (const gchar *database)
{
  int ret;
  const gchar *db = database ? database : OPENVAS_STATE_DIR "/mgr/tasks.db";

  init_manage_process (0, db);

  ret = backup_db (db, NULL);

  cleanup_manage_process (TRUE);

  return ret;
}

/**
 * @brief Return the database version supported by this manager.
 *
 * @return Database version supported by this manager.
 */
int
manage_db_supported_version ()
{
  return OPENVASMD_DATABASE_VERSION;
}

/**
 * @brief Return the database version of the actual database.
 *
 * @return Database version read from database if possible, else -1.
 */
int
manage_db_version ()
{
  int number;
  char *version = sql_string (0, 0,
                              "SELECT value FROM main.meta"
                              " WHERE name = 'database_version' LIMIT 1;");
  if (version)
    {
      number = atoi (version);
      free (version);
      return number;
    }
  return -1;
}

/**
 * @brief Set the database version of the actual database.
 *
 * @param  version  New version number.
 */
static void
set_db_version (int version)
{
  /** @todo Check that this (and others) still works with id column. */
  sql ("INSERT OR REPLACE INTO main.meta (name, value)"
       " VALUES ('database_version', '%i');",
       version);
}

/**
 * @brief A migrator.
 */
typedef struct
{
  int version;         ///< Version that the migrator produces.
  int (*function) ();  ///< Function that does the migration.  NULL if too hard.
} migrator_t;

/**
 * @brief Migrate the database from version 0 to version 1.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_0_to_1 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 0. */

  if (manage_db_version () != 0)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* In SVN the database version flag changed from 0 to 1 on 2009-09-30,
   * while the database changed to the version 1 schema on 2009-08-29.  This
   * means the database could be flagged as version 0 while it has a version
   * 1 schema.  In this case the ADD COLUMN below would fail.  A work around
   * would be simply to update the version number to 1 in the database by
   * hand. */

  sql ("ALTER TABLE reports ADD COLUMN scan_run_status INTEGER;");

  /* SQLite 3.1.3 and earlier requires a VACUUM before it can read
   * from the new column.  However, vacuuming might change the ROWIDs,
   * which would screw up the data.  Debian 5.0 (Lenny) is 3.5.9-6
   * already. */

  sql ("UPDATE reports SET scan_run_status = '%u';",
       TASK_STATUS_INTERNAL_ERROR);

  sql ("UPDATE reports SET scan_run_status = '%u'"
       " WHERE start_time IS NULL OR end_time IS NULL;",
       TASK_STATUS_STOPPED);

  sql ("UPDATE reports SET scan_run_status = '%u'"
       " WHERE end_time IS NOT NULL;",
       TASK_STATUS_DONE);

  /* Set the database version to 1. */

  set_db_version (1);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 1 to version 2.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_1_to_2 ()
{
  iterator_t nvts;

  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 1. */

  if (manage_db_version () != 1)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The category column in nvts changed type from string to int.  This
   * may be a redundant conversion, as SQLite may have converted these
   * values automatically in each query anyway. */

  init_iterator (&nvts, "SELECT ROWID, category FROM nvts;");
  while (next (&nvts))
    {
      int category;
      const char *category_string;

      category_string = (const char*) sqlite3_column_text (nvts.stmt, 1);

      category = atoi (category_string);
      sql ("UPDATE nvts SET category = %i WHERE ROWID = %llu;",
           category,
           iterator_int64 (&nvts, 0));
    }
  cleanup_iterator (&nvts);

  /* Set the database version to 2. */

  set_db_version (2);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 2 to version 3.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_2_to_3 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 2. */

  if (manage_db_version () != 2)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* Add tables added since version 2 that are adjust later in the
   * migration. */

  sql ("CREATE TABLE IF NOT EXISTS lsc_credentials (name, comment, rpm, deb, dog);");

  /* The lsc_credentials table changed: package columns changed type from BLOB
   * to string, new columns "password", "public key" and "private key" appeared
   * and the dog column changed name to exe.
   *
   * Just remove all the LSC credentials, as credential generation only
   * started working after version 3. */

  sql ("DELETE from lsc_credentials;");
  /* Before revision 5769 this could have caused problems, because these
   * columns are added on the end of the table, so columns referenced by
   * position in * queries may have been wrong (for example, with the iterator
   * returned by init_lsc_credential_iterator).  Since 5769 the queries
   * name all columns explicitly. */
  sql ("ALTER TABLE lsc_credentials ADD COLUMN password;");
  sql ("ALTER TABLE lsc_credentials ADD COLUMN public_key TEXT;");
  sql ("ALTER TABLE lsc_credentials ADD COLUMN private_key TEXT;");
  sql ("ALTER TABLE lsc_credentials ADD COLUMN exe TEXT;");

  /* Set the database version to 3. */

  set_db_version (3);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 3 to version 4.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_3_to_4 ()
{
  iterator_t nvts;

  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 3. */

  if (manage_db_version () != 3)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The nvt_selectors table got a family column. */

  sql ("ALTER TABLE nvt_selectors ADD COLUMN family;");

  init_nvt_selector_iterator (&nvts, NULL, (config_t) 0, 2);
  while (next (&nvts))
    {
      gchar *quoted_name = sql_quote (nvt_selector_iterator_name (&nvts));
      gchar *quoted_nvt = sql_quote (nvt_selector_iterator_nvt (&nvts));
      sql ("UPDATE nvt_selectors SET family ="
           " (SELECT family FROM nvts where oid = '%s')"
           " WHERE name = '%s';",
           quoted_nvt, quoted_name);
      g_free (quoted_name);
      g_free (quoted_nvt);
    }
  cleanup_iterator (&nvts);

  /* Set the database version to 4. */

  set_db_version (4);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Move all the data to the new tables for the 4 to 5 migrator.
 */
static void
migrate_4_to_5_copy_data ()
{
  iterator_t rows;

  /* Table config_preferences. */
  init_iterator (&rows,
                 "SELECT rowid, config, type, name, value"
                 " FROM config_preferences_4;");
  while (next (&rows))
    {
      gchar *quoted_type = sql_insert (iterator_string (&rows, 2));
      gchar *quoted_name = sql_insert (iterator_string (&rows, 3));
      gchar *quoted_value = sql_insert (iterator_string (&rows, 4));
      sql ("INSERT into config_preferences (id, config, type, name, value)"
           " VALUES (%llu, %llu, %s, %s, %s);",
           iterator_int64 (&rows, 0),
           iterator_int64 (&rows, 1),
           quoted_type,
           quoted_name,
           quoted_value);
      g_free (quoted_type);
      g_free (quoted_name);
      g_free (quoted_value);
    }
  cleanup_iterator (&rows);
  sql ("DROP TABLE config_preferences_4;");

  /* Table configs. */
  init_iterator (&rows,
                 "SELECT rowid, name, nvt_selector, comment, family_count,"
                 " nvt_count, families_growing, nvts_growing"
                 " FROM configs_4;");
  while (next (&rows))
    {
      gchar *quoted_name = sql_insert (iterator_string (&rows, 1));
      gchar *quoted_nvt_selector = sql_insert (iterator_string (&rows, 2));
      gchar *quoted_comment = sql_insert (iterator_string (&rows, 3));
      sql ("INSERT into configs"
           " (id, name, nvt_selector, comment, family_count, nvt_count,"
           "  families_growing, nvts_growing)"
           " VALUES"
           " (%llu, %s, %s, %s, %llu, %llu, %llu, %llu);",
           iterator_int64 (&rows, 0),
           quoted_name,
           quoted_nvt_selector,
           quoted_comment,
           iterator_int64 (&rows, 4),
           iterator_int64 (&rows, 5),
           iterator_int64 (&rows, 6),
           iterator_int64 (&rows, 7));
      g_free (quoted_name);
      g_free (quoted_nvt_selector);
      g_free (quoted_comment);
    }
  cleanup_iterator (&rows);
  sql ("DROP TABLE configs_4;");

  /* Table lsc_credentials. */
  init_iterator (&rows,
                 "SELECT rowid, name, password, comment, public_key,"
                 " private_key, rpm, deb, exe"
                 " FROM lsc_credentials_4;");
  while (next (&rows))
    {
      gchar *quoted_name = sql_insert (iterator_string (&rows, 1));
      gchar *quoted_password = sql_insert (iterator_string (&rows, 2));
      gchar *quoted_comment = sql_insert (iterator_string (&rows, 3));
      gchar *quoted_public_key = sql_insert (iterator_string (&rows, 4));
      gchar *quoted_private_key = sql_insert (iterator_string (&rows, 5));
      gchar *quoted_rpm = sql_insert (iterator_string (&rows, 6));
      gchar *quoted_deb = sql_insert (iterator_string (&rows, 7));
      gchar *quoted_exe = sql_insert (iterator_string (&rows, 8));
      sql ("INSERT into lsc_credentials"
           " (id, name, password, comment, public_key, private_key, rpm, deb,"
           "  exe)"
           " VALUES"
           " (%llu, %s, %s, %s, %s, %s, %s, %s, %s);",
           iterator_int64 (&rows, 0),
           quoted_name,
           quoted_password,
           quoted_comment,
           quoted_public_key,
           quoted_private_key,
           quoted_rpm,
           quoted_deb,
           quoted_exe);
      g_free (quoted_name);
      g_free (quoted_password);
      g_free (quoted_comment);
      g_free (quoted_public_key);
      g_free (quoted_private_key);
      g_free (quoted_rpm);
      g_free (quoted_deb);
      g_free (quoted_exe);
    }
  cleanup_iterator (&rows);
  sql ("DROP TABLE lsc_credentials_4;");

  /* Table meta. */
  init_iterator (&rows, "SELECT rowid, name, value FROM meta_4;");
  while (next (&rows))
    {
      gchar *quoted_name = sql_insert (iterator_string (&rows, 1));
      gchar *quoted_value = sql_insert (iterator_string (&rows, 2));
      sql ("INSERT into meta (id, name, value)"
           " VALUES (%llu, %s, %s);",
           iterator_int64 (&rows, 0),
           quoted_name,
           quoted_value);
      g_free (quoted_name);
      g_free (quoted_value);
    }
  cleanup_iterator (&rows);
  sql ("DROP TABLE meta_4;");

  /* Table nvt_preferences. */
  init_iterator (&rows, "SELECT rowid, name, value FROM nvt_preferences_4;");
  while (next (&rows))
    {
      gchar *quoted_name = sql_insert (iterator_string (&rows, 1));
      gchar *quoted_value = sql_insert (iterator_string (&rows, 2));
      sql ("INSERT into nvt_preferences (id, name, value)"
           " VALUES (%llu, %s, %s);",
           iterator_int64 (&rows, 0),
           quoted_name,
           quoted_value);
      g_free (quoted_name);
      g_free (quoted_value);
    }
  cleanup_iterator (&rows);
  sql ("DROP TABLE nvt_preferences_4;");

  /* Table nvt_selectors. */
  init_iterator (&rows,
                 "SELECT rowid, name, exclude, type, family_or_nvt, family"
                 " FROM nvt_selectors_4;");
  while (next (&rows))
    {
      gchar *quoted_name = sql_insert (iterator_string (&rows, 1));
      gchar *quoted_family_or_nvt = sql_insert (iterator_string (&rows, 4));
      gchar *quoted_family = sql_insert (iterator_string (&rows, 5));
      sql ("INSERT into nvt_selectors"
           " (id, name, exclude, type, family_or_nvt, family)"
           " VALUES"
           " (%llu, %s, %llu, %llu, %s, %s);",
           iterator_int64 (&rows, 0),
           quoted_name,
           iterator_int64 (&rows, 2),
           iterator_int64 (&rows, 3),
           quoted_family_or_nvt,
           quoted_family);
      g_free (quoted_name);
      g_free (quoted_family_or_nvt);
      g_free (quoted_family);
    }
  cleanup_iterator (&rows);
  sql ("DROP TABLE nvt_selectors_4;");

  /* Table nvts. */
  init_iterator (&rows,
                 "SELECT rowid, oid, version, name, summary, description,"
                 " copyright, cve, bid, xref, tag, sign_key_ids, category,"
                 " family"
                 " FROM nvts_4;");
  while (next (&rows))
    {
      gchar *quoted_oid = sql_insert (iterator_string (&rows, 1));
      gchar *quoted_version = sql_insert (iterator_string (&rows, 2));
      gchar *quoted_name = sql_insert (iterator_string (&rows, 3));
      gchar *quoted_summary = sql_insert (iterator_string (&rows, 4));
      gchar *quoted_description = sql_insert (iterator_string (&rows, 5));
      gchar *quoted_copyright = sql_insert (iterator_string (&rows, 6));
      gchar *quoted_cve = sql_insert (iterator_string (&rows, 7));
      gchar *quoted_bid = sql_insert (iterator_string (&rows, 8));
      gchar *quoted_xref = sql_insert (iterator_string (&rows, 9));
      gchar *quoted_tag = sql_insert (iterator_string (&rows, 10));
      gchar *quoted_sign_key_ids = sql_insert (iterator_string (&rows, 11));
      gchar *quoted_family = sql_insert (iterator_string (&rows, 13));

      {
        /* Starting from revision 5726 on 2009-10-26 (just before 0.9.2),
         * the Manager converts semicolons in OTP NVT descriptions to newlines
         * before entering them in the database.  Convert the existing
         * semicolons here, because it is a convenient place to do it. */
        gchar* pos = quoted_description;
        while ((pos = strchr (pos, ';')))
          pos[0] = '\n';
      }

      sql ("INSERT into nvts"
           " (id, oid, version, name, summary, description, copyright, cve,"
           "  bid, xref, tag, sign_key_ids, category, family)"
           " VALUES"
           " (%llu, %s, %s, %s, %s, %s, %s, %s, %s, %s,"
           "  %s, %s, %llu, %s);",
           iterator_int64 (&rows, 0),
           quoted_oid,
           quoted_version,
           quoted_name,
           quoted_summary,
           quoted_description,
           quoted_copyright,
           quoted_cve,
           quoted_bid,
           quoted_xref,
           quoted_tag,
           quoted_sign_key_ids,
           iterator_int64 (&rows, 12),
           quoted_family);
      g_free (quoted_oid);
      g_free (quoted_version);
      g_free (quoted_name);
      g_free (quoted_summary);
      g_free (quoted_description);
      g_free (quoted_copyright);
      g_free (quoted_cve);
      g_free (quoted_bid);
      g_free (quoted_xref);
      g_free (quoted_tag);
      g_free (quoted_sign_key_ids);
      g_free (quoted_family);
    }
  cleanup_iterator (&rows);
  sql ("DROP TABLE nvts_4;");

  /* Table report_hosts. */
  init_iterator (&rows,
                 "SELECT rowid, report, host, start_time, end_time,"
                 " attack_state, current_port, max_port"
                 " FROM report_hosts_4;");
  while (next (&rows))
    {
      gchar *quoted_host = sql_insert (iterator_string (&rows, 2));
      gchar *quoted_start_time = sql_insert (iterator_string (&rows, 3));
      gchar *quoted_end_time = sql_insert (iterator_string (&rows, 4));
      gchar *quoted_attack_state = sql_insert (iterator_string (&rows, 5));
      gchar *quoted_current_port = sql_insert (iterator_string (&rows, 6));
      gchar *quoted_max_port = sql_insert (iterator_string (&rows, 7));
      sql ("INSERT into report_hosts"
           " (id, report, host, start_time, end_time, attack_state,"
           "  current_port, max_port)"
           " VALUES"
           " (%llu, %llu, %s, %s, %s, %s, %s, %s);",
           iterator_int64 (&rows, 0),
           iterator_int64 (&rows, 1),
           quoted_host,
           quoted_start_time,
           quoted_end_time,
           quoted_attack_state,
           quoted_current_port,
           quoted_max_port);
      g_free (quoted_host);
      g_free (quoted_start_time);
      g_free (quoted_end_time);
      g_free (quoted_attack_state);
      g_free (quoted_current_port);
      g_free (quoted_max_port);
    }
  cleanup_iterator (&rows);
  sql ("DROP TABLE report_hosts_4;");

  /* Table report_results. */
  init_iterator (&rows, "SELECT rowid, report, result FROM report_results_4;");
  while (next (&rows))
    {
      sql ("INSERT into report_results (id, report, result)"
           " VALUES (%llu, %llu, %llu)",
           iterator_int64 (&rows, 0),
           iterator_int64 (&rows, 1),
           iterator_int64 (&rows, 2));
    }
  cleanup_iterator (&rows);
  sql ("DROP TABLE report_results_4;");

  /* Table reports. */
  init_iterator (&rows,
                 "SELECT rowid, uuid, hidden, task, date, start_time, end_time,"
                 " nbefile, comment, scan_run_status"
                 " FROM reports_4;");
  while (next (&rows))
    {
      gchar *quoted_uuid = sql_insert (iterator_string (&rows, 1));
      gchar *quoted_start_time = sql_insert (iterator_string (&rows, 5));
      gchar *quoted_end_time = sql_insert (iterator_string (&rows, 6));
      gchar *quoted_nbefile = sql_insert (iterator_string (&rows, 7));
      gchar *quoted_comment = sql_insert (iterator_string (&rows, 8));
      sql ("INSERT into reports"
           " (id, uuid, hidden, task, date, start_time, end_time, nbefile,"
           "  comment, scan_run_status)"
           " VALUES"
           " (%llu, %s, %llu, %llu, %llu, %s, %s, %s, %s, %llu);",
           iterator_int64 (&rows, 0),
           quoted_uuid,
           iterator_int64 (&rows, 2),
           iterator_int64 (&rows, 3),
           iterator_int64 (&rows, 4),
           quoted_start_time,
           quoted_end_time,
           quoted_nbefile,
           quoted_comment,
           iterator_int64 (&rows, 9));
      g_free (quoted_uuid);
      g_free (quoted_start_time);
      g_free (quoted_end_time);
      g_free (quoted_nbefile);
      g_free (quoted_comment);
    }
  cleanup_iterator (&rows);
  sql ("DROP TABLE reports_4;");

  /* Table results. */
  init_iterator (&rows,
                 "SELECT rowid, task, subnet, host, port, nvt, type,"
                 " description"
                 " FROM results_4;");
  while (next (&rows))
    {
      gchar *quoted_subnet = sql_insert (iterator_string (&rows, 2));
      gchar *quoted_host = sql_insert (iterator_string (&rows, 3));
      gchar *quoted_port = sql_insert (iterator_string (&rows, 4));
      gchar *quoted_nvt = sql_insert (iterator_string (&rows, 5));
      gchar *quoted_type = sql_insert (iterator_string (&rows, 6));
      gchar *quoted_description = sql_insert (iterator_string (&rows, 7));
      sql ("INSERT into results"
           " (id, task, subnet, host, port, nvt, type, description)"
           " VALUES"
           " (%llu, %llu, %s, %s, %s, %s, %s, %s);",
           iterator_int64 (&rows, 0),
           iterator_int64 (&rows, 1),
           quoted_subnet,
           quoted_host,
           quoted_port,
           quoted_nvt,
           quoted_type,
           quoted_description);
      g_free (quoted_subnet);
      g_free (quoted_host);
      g_free (quoted_port);
      g_free (quoted_nvt);
      g_free (quoted_type);
      g_free (quoted_description);
    }
  cleanup_iterator (&rows);
  sql ("DROP TABLE results_4;");

  /* Table targets. */
  init_iterator (&rows, "SELECT rowid, name, hosts, comment FROM targets_4;");
  while (next (&rows))
    {
      gchar *quoted_name = sql_insert (iterator_string (&rows, 1));
      gchar *quoted_hosts = sql_insert (iterator_string (&rows, 2));
      gchar *quoted_comment = sql_insert (iterator_string (&rows, 3));
      sql ("INSERT into targets (id, name, hosts, comment)"
           " VALUES (%llu, %s, %s, %s);",
           iterator_int64 (&rows, 0),
           quoted_name,
           quoted_hosts,
           quoted_comment);
      g_free (quoted_name);
      g_free (quoted_hosts);
      g_free (quoted_comment);
    }
  cleanup_iterator (&rows);
  sql ("DROP TABLE targets_4;");

  /* Table task_files. */
  init_iterator (&rows, "SELECT rowid, task, name, content FROM task_files_4;");
  while (next (&rows))
    {
      gchar *quoted_name = sql_insert (iterator_string (&rows, 2));
      gchar *quoted_content = sql_insert (iterator_string (&rows, 3));
      sql ("INSERT into task_files (id, task, name, content)"
           " VALUES (%llu, %llu, %s, %s);",
           iterator_int64 (&rows, 0),
           iterator_int64 (&rows, 1),
           quoted_name,
           quoted_content);
      g_free (quoted_name);
      g_free (quoted_content);
    }
  cleanup_iterator (&rows);
  sql ("DROP TABLE task_files_4;");

  /* Table tasks. */
  init_iterator (&rows,
                 "SELECT rowid, uuid, name, hidden, time, comment, description,"
                 " owner, run_status, start_time, end_time, config, target"
                 " FROM tasks_4;");
  while (next (&rows))
    {
      gchar *quoted_uuid = sql_insert (iterator_string (&rows, 1));
      gchar *quoted_name = sql_insert (iterator_string (&rows, 2));
      gchar *quoted_time = sql_insert (iterator_string (&rows, 4));
      gchar *quoted_comment = sql_insert (iterator_string (&rows, 5));
      gchar *quoted_description = sql_insert (iterator_string (&rows, 6));
      gchar *quoted_start_time = sql_insert (iterator_string (&rows, 9));
      gchar *quoted_end_time = sql_insert (iterator_string (&rows, 10));
      gchar *quoted_config = sql_insert (iterator_string (&rows, 11));
      gchar *quoted_target = sql_insert (iterator_string (&rows, 12));
      sql ("INSERT into tasks"
           " (id, uuid, name, hidden, time, comment, description, owner,"
           "  run_status, start_time, end_time, config, target)"
           " VALUES"
           " (%llu, %s, %s, %llu, %s, %s, %s, %llu, %llu, %s,"
           "  %s, %s, %s);",
           iterator_int64 (&rows, 0),
           quoted_uuid,
           quoted_name,
           iterator_int64 (&rows, 3),
           quoted_time,
           quoted_comment,
           quoted_description,
           iterator_int64 (&rows, 7),
           iterator_int64 (&rows, 8),
           quoted_start_time,
           quoted_end_time,
           quoted_config,
           quoted_target);
      g_free (quoted_uuid);
      g_free (quoted_name);
      g_free (quoted_time);
      g_free (quoted_comment);
      g_free (quoted_description);
      g_free (quoted_start_time);
      g_free (quoted_end_time);
      g_free (quoted_config);
      g_free (quoted_target);
    }
  cleanup_iterator (&rows);
  sql ("DROP TABLE tasks_4;");

  /* Table users. */
  init_iterator (&rows, "SELECT rowid, name, password FROM users_4;");
  while (next (&rows))
    {
      gchar *quoted_name = sql_insert (iterator_string (&rows, 1));
      gchar *quoted_password = sql_insert (iterator_string (&rows, 2));
      sql ("INSERT into users (id, name, password)"
           " VALUES (%llu, %s, %s);",
           iterator_int64 (&rows, 0),
           quoted_name,
           quoted_password);
      g_free (quoted_name);
      g_free (quoted_password);
    }
  cleanup_iterator (&rows);
  sql ("DROP TABLE users_4;");
}

/**
 * @brief Migrate the database from version 4 to version 5.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_4_to_5 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 4. */

  if (manage_db_version () != 4)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* Every table got an "id INTEGER PRIMARY KEY" column.  As the column is a
   * primary key, every table must be recreated and the data transfered.
   *
   * Also, starting from revision 5726 on 2009-10-26 (just before 0.9.2),
   * the Manager converts semicolons in OTP NVT descriptions to newlines
   * before entering them in the database.  Convert the existing
   * semicolons while transfering the data.  This should have been an
   * entirely separate version and migration between the current 4 and 5. */

  /* Ensure that all tables exist that will be adjusted below. */

  /* Both introduced between version 1 and 2. */
  sql ("CREATE TABLE IF NOT EXISTS nvt_preferences (name, value);");
  sql ("CREATE TABLE IF NOT EXISTS task_files (task INTEGER, name, content);");

  /* Move the tables away. */

  sql ("ALTER TABLE config_preferences RENAME TO config_preferences_4;");
  sql ("ALTER TABLE configs RENAME TO configs_4;");
  sql ("ALTER TABLE lsc_credentials RENAME TO lsc_credentials_4;");
  sql ("ALTER TABLE meta RENAME TO meta_4;");
  sql ("ALTER TABLE nvt_preferences RENAME TO nvt_preferences_4;");
  sql ("ALTER TABLE nvt_selectors RENAME TO nvt_selectors_4;");
  sql ("ALTER TABLE nvts RENAME TO nvts_4;");
  sql ("ALTER TABLE report_hosts RENAME TO report_hosts_4;");
  sql ("ALTER TABLE report_results RENAME TO report_results_4;");
  sql ("ALTER TABLE reports RENAME TO reports_4;");
  sql ("ALTER TABLE results RENAME TO results_4;");
  sql ("ALTER TABLE targets RENAME TO targets_4;");
  sql ("ALTER TABLE task_files RENAME TO task_files_4;");
  sql ("ALTER TABLE tasks RENAME TO tasks_4;");
  sql ("ALTER TABLE users RENAME TO users_4;");

  /* Create the new tables in version 4 format. */

  create_tables_version_4 ();

  /* Copy the data into the new tables, dropping the old tables. */

  migrate_4_to_5_copy_data ();

  /* Set the database version to 5. */

  set_db_version (5);

  sql ("COMMIT;");

  /* All the moving may have left much empty space, so vacuum. */

  sql ("VACUUM;");

  return 0;
}

/**
 * @brief Move a config that is using a predefined ID.
 *
 * @param[in]  predefined_config_name  Name of the predefined config.
 * @param[in]  predefined_config_id    Row ID of the predefined config.
 */
static void
migrate_5_to_6_move_other_config (const char *predefined_config_name,
                                  config_t predefined_config_id)
{
  if (sql_int (0, 0,
               "SELECT COUNT(*) = 0 FROM configs"
               " WHERE name = '%s';",
               predefined_config_name)
      && sql_int (0, 0,
                  "SELECT COUNT(*) = 1 FROM configs"
                  " WHERE ROWID = %llu;",
                  predefined_config_id))
    {
      config_t config;
      char *name;
      gchar *quoted_name;

      sql ("INSERT into configs (nvt_selector, comment, family_count,"
           " nvt_count, nvts_growing, families_growing)"
           " SELECT nvt_selector, comment, family_count,"
           " nvt_count, nvts_growing, families_growing"
           " FROM configs"
           " WHERE ROWID = %llu;",
           predefined_config_id);
      /* This ID will be larger then predefined_config_id because
       * predefined_config_id exists already.  At worst the ID will be one
       * larger. */
      config = sqlite3_last_insert_rowid (task_db);
      sql ("UPDATE config_preferences SET config = %llu WHERE config = %llu;",
           config,
           predefined_config_id);
      name = sql_string (0, 0,
                         "SELECT name FROM configs WHERE ROWID = %llu;",
                         predefined_config_id);
      if (name == NULL)
        {
          sql ("ROLLBACK;");
          abort ();
        }
      quoted_name = sql_quote (name);
      free (name);
      /* Table tasks references config by name, so it stays the same. */
      sql ("DELETE FROM configs WHERE ROWID = %llu;",
           predefined_config_id);
      sql ("UPDATE configs SET name = '%s' WHERE ROWID = %llu;",
           quoted_name,
           config);
      g_free (quoted_name);
    }
}

/**
 * @brief Migrate the database from version 5 to version 6.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_5_to_6 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 5. */

  if (manage_db_version () != 5)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The predefined configs got predefined ID's and the manager now also
   * caches counts for growing configs. */

  /* Fail with a message if the predefined configs have somehow got ID's
   * other than the usual ones. */

  if (sql_int (0, 0,
               "SELECT COUNT(*) = 0 OR ROWID == 1 FROM configs"
               " WHERE name = 'Full and fast';")
      && sql_int (0, 0,
                  "SELECT COUNT(*) = 0 OR ROWID == 2 FROM configs"
                  " WHERE name = 'Full and fast ultimate';")
      && sql_int (0, 0,
                  "SELECT COUNT(*) = 0 OR ROWID == 3 FROM configs"
                  " WHERE name = 'Full and very deep';")
      && sql_int (0, 0,
                  "SELECT COUNT(*) = 0 OR ROWID == 4 FROM configs"
                  " WHERE name = 'Full and very deep ultimate';"))
    {
      /* Any predefined configs are OK.  Move any other configs that have the
       * predefined ID's. */

      /* The ID of the moved config may be only one larger, so these must
       * be done in ID order. */
      migrate_5_to_6_move_other_config ("Full and fast", 1);
      migrate_5_to_6_move_other_config ("Full and fast ultimate", 2);
      migrate_5_to_6_move_other_config ("Full and very deep", 3);
      migrate_5_to_6_move_other_config ("Full and very deep ultimate", 4);
    }
  else
    {
      g_warning ("%s: a predefined config has moved from the standard location,"
                 " giving up\n",
                 __FUNCTION__);
      sql ("ROLLBACK;");
      return -1;
    }

  /* This would need a duplicate version of update_all_config_caches that
   * worked with the version 6 database.  Just let the cache be wrong.  This
   * is a very old version now. */
#if 0
  /* Update cache counts for growing configs. */

  update_all_config_caches ();
#endif

  /* Set the database version to 6. */

  set_db_version (6);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 6 to version 7.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_6_to_7 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 6. */

  if (manage_db_version () != 6)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* Add lsc_credential column to targets table. */
  sql ("ALTER TABLE targets ADD COLUMN lsc_credential INTEGER;");
  sql ("UPDATE targets SET lsc_credential = 0;");

  /* Set the database version to 7. */

  set_db_version (7);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 7 to version 8.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_7_to_8 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 7. */

  if (manage_db_version () != 7)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The lsc_credentials table got a login column. */

  sql ("ALTER TABLE lsc_credentials ADD COLUMN login;");
  sql ("UPDATE lsc_credentials SET login = name;");

  /* Set the database version to 8. */

  set_db_version (8);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 8 to version 9.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_8_to_9 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 8. */

  if (manage_db_version () != 8)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /** @todo Does ROLLBACK happen when these fail? */

  /* Ensure that all tables that will be modified here exist.  These were
   * all added after version 8 anyway. */

  sql ("CREATE TABLE IF NOT EXISTS escalators"
       " (id INTEGER PRIMARY KEY, name UNIQUE, comment, event INTEGER,"
       "  condition INTEGER, method INTEGER);");

  sql ("CREATE TABLE IF NOT EXISTS agents"
       " (id INTEGER PRIMARY KEY, name UNIQUE, comment, installer TEXT,"
       "  howto_install TEXT, howto_use TEXT);");

  /* Many tables got an owner column. */

  sql ("ALTER TABLE targets ADD COLUMN owner INTEGER;");
  sql ("UPDATE targets SET owner = NULL;");

  sql ("ALTER TABLE configs ADD COLUMN owner INTEGER;");
  sql ("UPDATE configs SET owner = NULL;");

  sql ("ALTER TABLE lsc_credentials ADD COLUMN owner INTEGER;");
  sql ("UPDATE lsc_credentials SET owner = NULL;");

  sql ("ALTER TABLE escalators ADD COLUMN owner INTEGER;");
  sql ("UPDATE escalators SET owner = NULL;");

  sql ("ALTER TABLE reports ADD COLUMN owner INTEGER;");
  sql ("UPDATE reports SET owner = NULL;");

  sql ("ALTER TABLE agents ADD COLUMN owner INTEGER;");
  sql ("UPDATE agents SET owner = NULL;");

  /* The owner column in tasks changed type from string to int.  This
   * may be a redundant conversion, as SQLite may have converted these
   * values automatically in each query anyway. */

  sql ("UPDATE tasks SET owner = CAST (owner AS INTEGER);"),

  /* Set the database version to 9. */

  set_db_version (9);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 9 to version 10.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_9_to_10 ()
{
  iterator_t rows;

  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 9. */

  if (manage_db_version () != 9)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The user table got a unique "uuid" column and lost the
   * uniqueness of its "name" column. */

  /** @todo ROLLBACK on failure. */

  sql ("ALTER TABLE users RENAME TO users_9;");

  sql ("CREATE TABLE users"
       " (id INTEGER PRIMARY KEY, uuid UNIQUE, name, password);");

  init_iterator (&rows, "SELECT rowid, name, password FROM users_9;");
  while (next (&rows))
    {
      gchar *quoted_name, *quoted_password, *uuid;

      uuid = openvas_user_uuid (iterator_string (&rows, 1));
      if (uuid == NULL)
        {
          uuid = openvas_uuid_make ();
          if (uuid == NULL)
            {
              cleanup_iterator (&rows);
              sql ("ROLLBACK;");
              return -1;
            }
        }

      quoted_name = sql_insert (iterator_string (&rows, 1));
      quoted_password = sql_insert (iterator_string (&rows, 2));
      sql ("INSERT into users (id, uuid, name, password)"
           " VALUES (%llu, '%s', %s, %s);",
           iterator_int64 (&rows, 0),
           uuid,
           quoted_name,
           quoted_password);
      g_free (uuid);
      g_free (quoted_name);
      g_free (quoted_password);
    }
  cleanup_iterator (&rows);
  sql ("DROP TABLE users_9;");

  /* Set the database version to 10. */

  set_db_version (10);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 10 to version 11.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_10_to_11 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 10. */

  if (manage_db_version () != 10)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The config and target columns of the tasks table changed from the name
   * of the config/target to the ROWID of the config/target.
   *
   * Recreate the table, in order to add INTEGER to the column definitions. */

  /** @todo ROLLBACK on failure. */

  sql ("ALTER TABLE tasks RENAME TO tasks_10;");

  sql ("CREATE TABLE tasks"
       " (id INTEGER PRIMARY KEY, uuid, owner INTEGER, name, hidden INTEGER,"
       "  time, comment, description, run_status INTEGER, start_time,"
       "  end_time, config INTEGER, target INTEGER);");

  sql ("INSERT into tasks"
       " (id, uuid, owner, name, hidden, time, comment, description,"
       "  run_status, start_time, end_time, config, target)"
       " SELECT"
       "  id, uuid, owner, name, hidden, time, comment, description,"
       "  run_status, start_time, end_time,"
       "  (SELECT ROWID FROM configs WHERE configs.name = tasks_10.config),"
       "  (SELECT ROWID FROM targets WHERE targets.name = tasks_10.target)"
       " FROM tasks_10;");

  sql ("DROP TABLE tasks_10;");

  /* Set the database version to 11. */

  set_db_version (11);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 11 to version 12.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_11_to_12 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 11. */

  if (manage_db_version () != 11)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* Tables agents, configs and escalators were relieved of the UNIQUE
   * constraint on the name column.
   *
   * Recreate the tables, in order to remove the contraint. */

  /** @todo ROLLBACK on failure. */

  sql ("ALTER TABLE agents RENAME TO agents_11;");

  sql ("CREATE TABLE agents"
       " (id INTEGER PRIMARY KEY, owner INTEGER, name, comment,"
       "  installer TEXT, howto_install TEXT, howto_use TEXT);");

  sql ("INSERT into agents"
       " (id, owner, name, comment, installer, howto_install, howto_use)"
       " SELECT"
       "  id, owner, name, comment, installer, howto_install, howto_use"
       " FROM agents_11;");

  sql ("DROP TABLE agents_11;");

  sql ("ALTER TABLE configs RENAME TO configs_11;");

  sql ("CREATE TABLE configs"
       " (id INTEGER PRIMARY KEY, owner INTEGER, name, nvt_selector, comment,"
       "  family_count INTEGER, nvt_count INTEGER, families_growing INTEGER,"
       "  nvts_growing INTEGER);");

  sql ("INSERT into configs"
       " (id, owner, name, nvt_selector, comment, family_count, nvt_count,"
       "  families_growing, nvts_growing)"
       " SELECT"
       "  id, owner, name, nvt_selector, comment, family_count, nvt_count,"
       "  families_growing, nvts_growing"
       " FROM configs_11;");

  sql ("DROP TABLE configs_11;");

  sql ("ALTER TABLE escalators RENAME TO escalators_11;");

  sql ("CREATE TABLE escalators"
       " (id INTEGER PRIMARY KEY, owner INTEGER, name, comment, event INTEGER,"
       "  condition INTEGER, method INTEGER);");

  sql ("INSERT into escalators"
       " (id, owner, name, comment, event, condition, method)"
       " SELECT"
       "  id, owner, name, comment, event, condition, method"
       " FROM escalators_11;");

  sql ("DROP TABLE escalators_11;");

  /* Set the database version to 12. */

  set_db_version (12);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 12 to version 13.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_12_to_13 ()
{
  iterator_t rows;

  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 12. */

  if (manage_db_version () != 12)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* Table nvt_selectors column name changed to a UUID.
   *
   * Replace names with UUIDs, ensuring that the 'All' selector gets the
   * predefined UUID. */

  /** @todo ROLLBACK on failure. */

  init_iterator (&rows, "SELECT distinct name FROM nvt_selectors;");
  while (next (&rows))
    {
      gchar *quoted_name, *uuid;

      if (strcmp (iterator_string (&rows, 0), "All") == 0)
        continue;

      uuid = openvas_uuid_make ();
      if (uuid == NULL)
        {
          cleanup_iterator (&rows);
          sql ("ROLLBACK;");
          return -1;
        }

      quoted_name = sql_insert (iterator_string (&rows, 0));

      sql ("UPDATE nvt_selectors SET name = '%s' WHERE name = %s;",
           uuid,
           quoted_name);

      sql ("UPDATE configs SET nvt_selector = '%s' WHERE nvt_selector = %s;",
           uuid,
           quoted_name);

      g_free (uuid);
      g_free (quoted_name);
    }
  cleanup_iterator (&rows);

  if (sql_int (0, 0,
               "SELECT COUNT(*) FROM nvt_selectors WHERE name = '"
               MANAGE_NVT_SELECTOR_UUID_ALL "';"))
    sql ("DELETE FROM nvt_selectors WHERE name = 'All';");
  else
    sql ("UPDATE nvt_selectors"
         " SET name = '" MANAGE_NVT_SELECTOR_UUID_ALL "'"
         " WHERE name = 'All';");

  sql ("UPDATE configs"
       " SET nvt_selector = '" MANAGE_NVT_SELECTOR_UUID_ALL "'"
       " WHERE nvt_selector = 'All';");

  /* Set the database version to 13. */

  set_db_version (13);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 13 to version 14.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_13_to_14 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 13. */

  if (manage_db_version () != 13)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* Table results got a UUID column. */

  /** @todo ROLLBACK on failure. */

  sql ("ALTER TABLE results ADD COLUMN uuid;");
  sql ("UPDATE results SET uuid = make_uuid();");

  /* Set the database version to 14. */

  set_db_version (14);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 14 to version 15.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_14_to_15 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 14. */

  if (manage_db_version () != 14)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* Table tasks got columns for scheduling info. */

  /** @todo ROLLBACK on failure. */

  sql ("ALTER TABLE tasks ADD COLUMN schedule INTEGER;");
  sql ("ALTER TABLE tasks ADD COLUMN schedule_next_time;");
  sql ("UPDATE tasks SET schedule = 0, schedule_next_time = 0;");

  /* Set the database version to 15. */

  set_db_version (15);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 15 to version 16.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_15_to_16 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 15. */

  if (manage_db_version () != 15)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* Table schedules got a period_months column. */

  /** @todo ROLLBACK on failure. */

  sql ("CREATE TABLE IF NOT EXISTS schedules"
       " (id INTEGER PRIMARY KEY, uuid, owner INTEGER, name, comment,"
       "  first_time, period, duration);");

  sql ("ALTER TABLE schedules ADD COLUMN period_months;");
  sql ("UPDATE schedules SET period_months = 0;");

  /* GSA was hardcoded to set the comment to "comment" before revision 7157,
   * so clear all task comments here. */

  sql ("UPDATE tasks SET comment = '';");

  /* Set the database version to 16. */

  set_db_version (16);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 16 to version 17.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_16_to_17 ()
{
  iterator_t rows;

  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 16. */

  if (manage_db_version () != 16)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* Table nvts got columns for CVSS base and risk factor. */

  /** @todo ROLLBACK on failure. */

  sql ("ALTER TABLE nvts ADD COLUMN cvss_base;");
  sql ("ALTER TABLE nvts ADD COLUMN risk_factor;");

  /* Move the CVSS and risk values out of any existing tags. */

  init_iterator (&rows, "SELECT ROWID, tag FROM nvts;");
  while (next (&rows))
    {
      gchar *tags, *cvss_base, *risk_factor;

      parse_tags (iterator_string (&rows, 1), &tags, &cvss_base, &risk_factor);

      sql ("UPDATE nvts SET cvss_base = '%s', risk_factor = '%s', tag = '%s'"
           " WHERE ROWID = %llu;",
           cvss_base ? cvss_base : "",
           risk_factor ? risk_factor : "",
           tags ? tags : "",
           iterator_int64 (&rows, 0));

      g_free (tags);
      g_free (cvss_base);
      g_free (risk_factor);
    }
  cleanup_iterator (&rows);

  /* Set the database version to 17. */

  set_db_version (17);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Set the pref for migrate_17_to_18.
 *
 * @param[in]  config  Config to set pref on.
 */
static void
migrate_17_to_18_set_pref (config_t config)
{
  if (sql_int (0, 0,
               "SELECT count(*) FROM config_preferences"
               " WHERE config = %llu"
               " AND name ="
               " 'Ping Host[checkbox]:Mark unrechable Hosts as dead"
               " (not scanning)'",
               config)
      == 0)
    sql ("INSERT into config_preferences (config, type, name, value)"
         " VALUES (%llu, 'PLUGINS_PREFS',"
         " 'Ping Host[checkbox]:Mark unrechable Hosts as dead (not scanning)',"
         " 'yes');",
         config);
}

/**
 * @brief Migrate the database from version 17 to version 18.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_17_to_18 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 17. */

  if (manage_db_version () != 17)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* NVT "Ping Host" was added to the predefined configs, with the
   * "Mark unrechable..." preference set to "yes". */

  /** @todo ROLLBACK on failure. */

  /* Add "Ping Host" to the "All" NVT selector. */

  if (sql_int (0, 0,
               "SELECT count(*) FROM nvt_selectors WHERE name ="
               " '" MANAGE_NVT_SELECTOR_UUID_ALL "'"
               " AND family_or_nvt = '1.3.6.1.4.1.25623.1.0.100315';")
      == 0)
    {
      sql ("INSERT into nvt_selectors"
           " (name, exclude, type, family_or_nvt, family)"
           " VALUES ('" MANAGE_NVT_SELECTOR_UUID_ALL "', 0, "
           G_STRINGIFY (NVT_SELECTOR_TYPE_NVT) ","
           /* OID of the "Ping Host" NVT. */
           " '1.3.6.1.4.1.25623.1.0.100315', 'Port scanners');");
    }

  /* Ensure the preference is set on the predefined configs. */

  migrate_17_to_18_set_pref (CONFIG_ID_FULL_AND_FAST);
  migrate_17_to_18_set_pref (CONFIG_ID_FULL_AND_FAST_ULTIMATE);
  migrate_17_to_18_set_pref (CONFIG_ID_FULL_AND_VERY_DEEP);
  migrate_17_to_18_set_pref (CONFIG_ID_FULL_AND_VERY_DEEP_ULTIMATE);

  /* Set the database version to 18. */

  set_db_version (18);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 18 to version 19.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_18_to_19 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 18. */

  if (manage_db_version () != 18)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* Many tables got a unique UUID column.  As a result the predefined
   * configs and target got fixed UUIDs.
   *
   * Recreate the tables, in order to add the unique contraint. */

  /** @todo ROLLBACK on failure. */

  sql ("ALTER TABLE agents RENAME TO agents_18;");

  sql ("CREATE TABLE agents"
       " (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, comment,"
       "  installer TEXT, howto_install TEXT, howto_use TEXT);");

  sql ("INSERT into agents"
       " (id, uuid, owner, name, comment, installer, howto_install, howto_use)"
       " SELECT"
       "  id, make_uuid (), owner, name, comment, installer, howto_install, howto_use"
       " FROM agents_18;");

  sql ("DROP TABLE agents_18;");

  sql ("ALTER TABLE configs RENAME TO configs_18;");

  sql ("CREATE TABLE configs"
       " (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name,"
       "  nvt_selector, comment, family_count INTEGER, nvt_count INTEGER,"
       "  families_growing INTEGER, nvts_growing INTEGER);");

  sql ("INSERT into configs"
       " (id, uuid, owner, name, nvt_selector, comment, family_count,"
       "  nvt_count, families_growing, nvts_growing)"
       " SELECT"
       "  id, make_uuid (), owner, name, nvt_selector, comment, family_count,"
       "  nvt_count, families_growing, nvts_growing"
       " FROM configs_18;");

  sql ("DROP TABLE configs_18;");

  sql ("ALTER TABLE escalators RENAME TO escalators_18;");

  sql ("CREATE TABLE escalators"
       " (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, comment,"
       "  event INTEGER, condition INTEGER, method INTEGER);");

  sql ("INSERT into escalators"
       " (id, uuid, owner, name, comment, event, condition, method)"
       " SELECT"
       "  id, make_uuid (), owner, name, comment, event, condition, method"
       " FROM escalators_18;");

  sql ("DROP TABLE escalators_18;");

  sql ("ALTER TABLE lsc_credentials RENAME TO lsc_credentials_18;");

  sql ("CREATE TABLE lsc_credentials"
       " (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, login,"
       "  password, comment, public_key TEXT, private_key TEXT, rpm TEXT,"
       "  deb TEXT, exe TEXT);");

  sql ("INSERT into lsc_credentials"
       " (id, uuid, owner, name, login, password, comment, public_key,"
       "  private_key, rpm, deb, exe)"
       " SELECT"
       "  id, make_uuid (), owner, name, login, password, comment, public_key,"
       "  private_key, rpm, deb, exe"
       " FROM lsc_credentials_18;");

  sql ("DROP TABLE lsc_credentials_18;");

  sql ("ALTER TABLE targets RENAME TO targets_18;");

  sql ("CREATE TABLE targets"
       " (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, hosts,"
       "  comment, lsc_credential INTEGER);");

  sql ("INSERT into targets"
       " (id, uuid, owner, name, hosts, comment, lsc_credential)"
       " SELECT"
       "  id, make_uuid (), owner, name, hosts, comment, lsc_credential"
       " FROM targets_18;");

  sql ("DROP TABLE targets_18;");

  /* Set the new predefined UUIDs. */

  sql ("UPDATE configs"
       " SET uuid = '" CONFIG_UUID_FULL_AND_FAST "'"
       " WHERE ROWID = " G_STRINGIFY (CONFIG_ID_FULL_AND_FAST) ";");

  sql ("UPDATE configs"
       " SET uuid = '" CONFIG_UUID_FULL_AND_FAST_ULTIMATE "'"
       " WHERE ROWID = " G_STRINGIFY (CONFIG_ID_FULL_AND_FAST_ULTIMATE) ";");

  sql ("UPDATE configs"
       " SET uuid = '" CONFIG_UUID_FULL_AND_VERY_DEEP "'"
       " WHERE ROWID = " G_STRINGIFY (CONFIG_ID_FULL_AND_VERY_DEEP) ";");

  sql ("UPDATE configs"
       " SET uuid = '" CONFIG_UUID_FULL_AND_VERY_DEEP_ULTIMATE "'"
       " WHERE ROWID = "
       G_STRINGIFY (CONFIG_ID_FULL_AND_VERY_DEEP_ULTIMATE) ";");

  sql ("UPDATE configs"
       " SET uuid = '" CONFIG_UUID_EMPTY "'"
       " WHERE name = 'empty';");

  sql ("UPDATE targets"
       " SET uuid = '" TARGET_UUID_LOCALHOST "'"
       " WHERE name = 'Localhost';");

  /* Set the database version to 19. */

  set_db_version (19);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 19 to version 20.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_19_to_20 ()
{
  iterator_t rows;

  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 19. */

  if (manage_db_version () != 19)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The agents table got new columns.  In particular the installer column
   * moved to installer_64 and the table got a new installer column with the
   * plain installer. */

  /** @todo ROLLBACK on failure. */

  sql ("ALTER TABLE agents ADD COLUMN installer_64 TEXT;");
  sql ("ALTER TABLE agents ADD COLUMN installer_signature_64 TEXT;");
  sql ("ALTER TABLE agents ADD COLUMN installer_trust INTEGER;");

  init_iterator (&rows, "SELECT ROWID, installer FROM agents;");
  while (next (&rows))
    {
      const char *tail, *installer_64 = iterator_string (&rows, 1);
      gchar *installer, *formatted;
      gsize installer_size;
      int ret;
      sqlite3_stmt* stmt;

      sql ("UPDATE agents SET"
           " installer_trust = %i,"
           " installer_64 = installer,"
           " installer_signature_64 = ''"
           " WHERE ROWID = %llu",
           TRUST_UNKNOWN,
           iterator_int64 (&rows, 0));

      formatted = g_strdup_printf ("UPDATE agents SET installer = $installer"
                                   " WHERE ROWID = %llu;",
                                   iterator_int64 (&rows, 0));

      /* Prepare statement. */

      while (1)
        {
          ret = sqlite3_prepare (task_db, (char*) formatted, -1, &stmt, &tail);
          if (ret == SQLITE_BUSY) continue;
          g_free (formatted);
          if (ret == SQLITE_OK)
            {
              if (stmt == NULL)
                {
                  g_warning ("%s: sqlite3_prepare failed with NULL stmt: %s\n",
                             __FUNCTION__,
                             sqlite3_errmsg (task_db));
                  cleanup_iterator (&rows);
                  sql ("ROLLBACK;");
                  return -1;
                }
              break;
            }
          g_warning ("%s: sqlite3_prepare failed: %s\n",
                     __FUNCTION__,
                     sqlite3_errmsg (task_db));
          cleanup_iterator (&rows);
          sql ("ROLLBACK;");
          return -1;
        }

      if (strlen (installer_64) > 0)
        installer = (gchar*) g_base64_decode (installer_64, &installer_size);
      else
        installer = g_strdup ("");

      /* Bind the packages to the "$values" in the SQL statement. */

      while (1)
        {
          ret = sqlite3_bind_text (stmt,
                                   1,
                                   installer,
                                   installer_size,
                                   SQLITE_TRANSIENT);
          if (ret == SQLITE_BUSY) continue;
          if (ret == SQLITE_OK) break;
          g_warning ("%s: sqlite3_prepare failed: %s\n",
                     __FUNCTION__,
                     sqlite3_errmsg (task_db));
          cleanup_iterator (&rows);
          sql ("ROLLBACK;");
          g_free (installer);
          return -1;
        }
      g_free (installer);

      /* Run the statement. */

      while (1)
        {
          ret = sqlite3_step (stmt);
          if (ret == SQLITE_BUSY) continue;
          if (ret == SQLITE_DONE) break;
          if (ret == SQLITE_ERROR || ret == SQLITE_MISUSE)
            {
              if (ret == SQLITE_ERROR) ret = sqlite3_reset (stmt);
              g_warning ("%s: sqlite3_step failed: %s\n",
                         __FUNCTION__,
                         sqlite3_errmsg (task_db));
              cleanup_iterator (&rows);
              sql ("ROLLBACK;");
              return -1;
            }
        }

      sqlite3_finalize (stmt);
    }
  cleanup_iterator (&rows);

  /* Set the database version to 20. */

  set_db_version (20);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 20 to version 21.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_20_to_21 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 20. */

  if (manage_db_version () != 20)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The agents table got an installer_filename columns. */

  /** @todo ROLLBACK on failure. */

  sql ("ALTER TABLE agents ADD COLUMN installer_filename TEXT;");

  /* Set the database version to 21. */

  set_db_version (21);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the report formats from version 21 to version 22.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_21_to_22 ()
{
  iterator_t rows;

  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 21. */

  if (manage_db_version () != 21)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the report formats.
   *
   * The name of the report format directories on disk changed from the report
   * format name to the report format UUID. */

  /** @todo ROLLBACK on failure. */

  /* Ensure that the report_formats table exists. */

  sql ("CREATE TABLE IF NOT EXISTS report_formats"
       " (id INTEGER PRIMARY KEY, uuid, owner INTEGER, name, extension,"
       "  content_type, summary, description);");

  /* Ensure that the predefined formats all exist in the database. */

  if (sql_int (0, 0, "SELECT count(*) FROM report_formats WHERE name = 'CPE';")
      == 0)
    sql ("INSERT into report_formats (uuid, owner, name, summary, description,"
         " extension, content_type)"
         " VALUES (make_uuid (), NULL, 'CPE',"
         " 'Common Product Enumeration CSV table.',"
         " 'CPE stands for Common Product Enumeration.  It is a structured naming scheme for\n"
         "information technology systems, platforms, and packages.  In other words: CPE\n"
         "provides a unique identifier for virtually any software product that is known for\n"
         "a vulnerability.\n"
         "\n"
         "The CPE dictionary is maintained by MITRE and NIST.  MITRE also maintains CVE\n"
         "(Common Vulnerability Enumeration) and other relevant security standards.\n"
         "\n"
         "The report selects all CPE tables from the results and forms a single table\n"
         "as a comma separated values file.\n',"
         " 'csv', 'text/csv');");

  if (sql_int (0, 0, "SELECT count(*) FROM report_formats WHERE name = 'HTML';")
      == 0)
    sql ("INSERT into report_formats (uuid, owner, name, summary, description,"
         " extension, content_type)"
         " VALUES (make_uuid (), NULL, 'HTML', 'Single page HTML report.',"
         " 'A single HTML page listing results of a scan.  Style information is embedded in\n"
         "the HTML, so the page is suitable for viewing in a browser as is.\n',"
         " 'html', 'text/html');");

  if (sql_int (0, 0, "SELECT count(*) FROM report_formats WHERE name = 'ITG';")
      == 0)
    sql ("INSERT into report_formats (uuid, owner, name, summary, description,"
         " extension, content_type)"
         " VALUES (make_uuid (), NULL, 'ITG',"
         " 'German \"IT-Grundschutz-Kataloge\" report.',"
         " 'Tabular report on the German \"IT-Grundschutz-Kataloge\",\n"
         "as published and maintained by the German Federal Agency for IT-Security.\n',"
         " 'csv', 'text/csv');");

  if (sql_int (0, 0, "SELECT count(*) FROM report_formats WHERE name = 'LaTeX';")
      == 0)
    sql ("INSERT into report_formats (uuid, owner, name, summary, description,"
         " extension, content_type)"
         " VALUES (make_uuid (), NULL, 'LaTeX',"
         " 'LaTeX source file.',"
         " 'Report as LaTeX source file for further processing.\n',"
         " 'tex', 'text/plain');");

  if (sql_int (0, 0, "SELECT count(*) FROM report_formats WHERE name = 'NBE';")
      == 0)
    sql ("INSERT into report_formats (uuid, owner, name, summary, description,"
         " extension, content_type)"
         " VALUES (make_uuid (), NULL, 'NBE', 'Legacy OpenVAS report.',"
         " 'The traditional OpenVAS Scanner text based format.',"
         " 'nbe', 'text/plain');");

  if (sql_int (0, 0, "SELECT count(*) FROM report_formats WHERE name = 'PDF';")
      == 0)
    sql ("INSERT into report_formats (uuid, owner, name, summary, description,"
         " extension, content_type)"
         " VALUES (make_uuid (), NULL, 'PDF',"
         " 'Portable Document Format report.',"
         " 'Scan results in Portable Document Format (PDF).',"
         "'pdf', 'application/pdf');");

  if (sql_int (0, 0, "SELECT count(*) FROM report_formats WHERE name = 'TXT';")
      == 0)
    sql ("INSERT into report_formats (uuid, owner, name, summary, description,"
         " extension, content_type)"
         " VALUES (make_uuid (), NULL, 'TXT', 'Plain text report.',"
         " 'Plain text report, best viewed with fixed font size.',"
         " 'txt', 'text/plain');");

  if (sql_int (0, 0, "SELECT count(*) FROM report_formats WHERE name = 'XML';")
      == 0)
    sql ("INSERT into report_formats (uuid, owner, name, summary, description,"
         " extension, content_type)"
         " VALUES (make_uuid (), NULL, 'XML',"
         " 'Raw XML report.',"
         " 'Complete scan report in OpenVAS Manager XML format.',"
         " 'xml', 'text/xml');");

  /* Update the UUIDs of the predefined formats to the new predefined UUIDs. */

  sql ("UPDATE report_formats SET uuid = 'a0704abb-2120-489f-959f-251c9f4ffebd'"
       " WHERE name = 'CPE'");

  sql ("UPDATE report_formats SET uuid = 'b993b6f5-f9fb-4e6e-9c94-dd46c00e058d'"
       " WHERE name = 'HTML'");

  sql ("UPDATE report_formats SET uuid = '929884c6-c2c4-41e7-befb-2f6aa163b458'"
       " WHERE name = 'ITG'");

  sql ("UPDATE report_formats SET uuid = '9f1ab17b-aaaa-411a-8c57-12df446f5588'"
       " WHERE name = 'LaTeX'");

  sql ("UPDATE report_formats SET uuid = 'f5c2a364-47d2-4700-b21d-0a7693daddab'"
       " WHERE name = 'NBE'");

  sql ("UPDATE report_formats SET uuid = '1a60a67e-97d0-4cbf-bc77-f71b08e7043d'"
       " WHERE name = 'PDF'");

  sql ("UPDATE report_formats SET uuid = '19f6f1b3-7128-4433-888c-ccc764fe6ed5'"
       " WHERE name = 'TXT'");

  sql ("UPDATE report_formats SET uuid = 'd5da9f67-8551-4e51-807b-b6a873d70e34'"
       " WHERE name = 'XML'");

  /* Rename the directories. */

  init_iterator (&rows, "SELECT ROWID, uuid, owner, name FROM report_formats;");
  while (next (&rows))
    {
      const char *name, *uuid;
      gchar *old_dir, *new_dir;
      int user_format = 0;

      uuid = iterator_string (&rows, 1);
      name = iterator_string (&rows, 3);

      if (sql_int (0, 0,
                   "SELECT owner is NULL FROM report_formats"
                   " WHERE ROWID = %llu;",
                   iterator_int64 (&rows, 0)))
        {
          /* Global. */
          old_dir = g_build_filename (OPENVAS_SYSCONF_DIR,
                                      "openvasmd",
                                      "global_report_formats",
                                      name,
                                      NULL);
          new_dir = g_build_filename (OPENVAS_SYSCONF_DIR,
                                      "openvasmd",
                                      "global_report_formats",
                                      uuid,
                                      NULL);
        }
      else
        {
          char *owner_uuid;
          owner_uuid = sql_string (0, 0,
                                   "SELECT uuid FROM users"
                                   " WHERE ROWID = %llu;",
                                   iterator_int64 (&rows, 2));
          if (owner_uuid == NULL)
            {
              g_warning ("%s: owner missing from users table\n", __FUNCTION__);
              cleanup_iterator (&rows);
              sql ("ROLLBACK;");
              return -1;
            }
          old_dir = g_build_filename (OPENVAS_SYSCONF_DIR,
                                      "openvasmd",
                                      "report_formats",
                                      owner_uuid,
                                      name,
                                      NULL);
          new_dir = g_build_filename (OPENVAS_SYSCONF_DIR,
                                      "openvasmd",
                                      "report_formats",
                                      owner_uuid,
                                      uuid,
                                      NULL);
          free (owner_uuid);
          user_format = 1;
        }
      if (g_file_test (new_dir, G_FILE_TEST_EXISTS))
        {
          if (g_file_test (old_dir, G_FILE_TEST_EXISTS)
              && openvas_file_remove_recurse (old_dir))
            g_warning ("%s: failed to remove %s\n",
                       __FUNCTION__,
                       old_dir);
        }
      /* If the old dir of a predefined format is missing that's OK, the
       * Manager will create the dir when it starts proper. */
      else if ((g_file_test (old_dir, G_FILE_TEST_EXISTS)
                || user_format)
               && rename (old_dir, new_dir))
        {
          g_warning ("%s: renaming %s to %s failed: %s\n",
                     __FUNCTION__,
                     old_dir,
                     new_dir,
                     strerror (errno));
          g_free (old_dir);
          g_free (new_dir);
          cleanup_iterator (&rows);
          sql ("ROLLBACK;");
          return -1;
        }
      g_free (old_dir);
      g_free (new_dir);
    }

  /* Set the database version to 22. */

  set_db_version (22);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the report formats from version 22 to version 23.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_22_to_23 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 22. */

  if (manage_db_version () != 22)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the report formats.
   *
   * The report_formats table got signature and trust columns. */

  /** @todo ROLLBACK on failure. */

  sql ("ALTER TABLE report_formats ADD COLUMN signature;");
  sql ("UPDATE report_formats SET signature = '';");

  sql ("ALTER TABLE report_formats ADD COLUMN trust;");
  sql ("UPDATE report_formats SET trust = %i;", TRUST_UNKNOWN);

  /* Set the database version to 23. */

  set_db_version (23);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 23 to version 24.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_23_to_24 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 23. */

  if (manage_db_version () != 23)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The 8 to 9 migrator cast owner to an integer because owner had
   * changed from a string to an integer.  This means empty strings would
   * be converted to 0 instead of NULL, so convert any 0's to NULL. */

  sql ("UPDATE tasks SET owner = NULL where owner = 0;"),

  /* Set the database version to 24. */

  set_db_version (24);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 24 to version 25.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_24_to_25 ()
{
  iterator_t rows;

  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 24. */

  if (manage_db_version () != 24)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* Missing parameter chunking handling in the GSA may have resulted in
   * empty options in NVT radio preference values. */

  init_iterator (&rows, "SELECT ROWID, name, value FROM nvt_preferences;");
  while (next (&rows))
    {
      const char *name;
      int type_start = -1, type_end = -1, count;

      name = iterator_string (&rows, 1);

      /* NVT[radio]:Preference */
      count = sscanf (name, "%*[^[][%nradio%n]:", &type_start, &type_end);
      if (count == 0 && type_start > 0 && type_end > 0)
        {
          const char *value;
          gchar **split, **point, *quoted_value;
          GString *string;
          gboolean first;

          /* Flush any empty options (";a;;b;" becomes "a;b"). */
          first = TRUE;
          value = iterator_string (&rows, 2);
          split = g_strsplit (value, ";", 0);
          string = g_string_new ("");
          point = split;
          while (*point)
            {
              if (strlen (*point))
                {
                  if (first)
                    first = FALSE;
                  else
                    g_string_append_c (string, ';');
                  g_string_append (string, *point);
                }
              point++;
            }
          g_strfreev (split);

          quoted_value = sql_nquote (string->str, string->len);
          g_string_free (string, TRUE);
          sql ("UPDATE nvt_preferences SET value = '%s' WHERE ROWID = %llu",
               quoted_value,
               iterator_int64 (&rows, 0));
          g_free (quoted_value);
        }
    }
  cleanup_iterator (&rows);

  init_iterator (&rows,
                 "SELECT ROWID, name, value FROM config_preferences"
                 " WHERE type = 'PLUGINS_PREFS';");
  while (next (&rows))
    {
      const char *name;
      int type_start = -1, type_end = -1, count;

      name = iterator_string (&rows, 1);

      /* NVT[radio]:Preference */
      count = sscanf (name, "%*[^[][%nradio%n]:", &type_start, &type_end);
      if (count == 0 && type_start > 0 && type_end > 0)
        {
          const char *value;
          gchar **split, **point, *quoted_value;
          GString *string;
          gboolean first;

          /* Flush any empty options (";a;;b;" becomes "a;b"). */
          first = TRUE;
          value = iterator_string (&rows, 2);
          split = g_strsplit (value, ";", 0);
          string = g_string_new ("");
          point = split;
          while (*point)
            {
              if (strlen (*point))
                {
                  if (first)
                    first = FALSE;
                  else
                    g_string_append_c (string, ';');
                  g_string_append (string, *point);
                }
              point++;
            }
          g_strfreev (split);

          quoted_value = sql_nquote (string->str, string->len);
          g_string_free (string, TRUE);
          sql ("UPDATE config_preferences SET value = '%s' WHERE ROWID = %llu",
               quoted_value,
               iterator_int64 (&rows, 0));
          g_free (quoted_value);
        }
    }
  cleanup_iterator (&rows);

  /* Set the database version to 25. */

  set_db_version (25);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 25 to version 26.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_25_to_26 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 25. */

  if (manage_db_version () != 25)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The report_formats table got a trust_time column. */

  sql ("ALTER TABLE report_formats ADD column trust_time;");
  sql ("UPDATE report_formats SET trust_time = %i;", time (NULL));

  /* Set the database version to 26. */

  set_db_version (26);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 26 to version 27.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_26_to_27 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 26. */

  if (manage_db_version () != 26)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The reports table got a slave_progress column and the tasks table got a
   * slave column. */

  sql ("ALTER TABLE reports ADD column slave_progress;");
  sql ("UPDATE reports SET slave_progress = 0;");

  sql ("ALTER TABLE tasks ADD column slave;");
  sql ("UPDATE tasks SET slave = 0;");

  /* Set the database version to 27. */

  set_db_version (27);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 27 to version 28.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_27_to_28 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 27. */

  if (manage_db_version () != 27)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The report_formats table got a flags column. */

  sql ("ALTER TABLE report_formats ADD COLUMN flags INTEGER;");
  sql ("UPDATE report_formats SET flags = 1;");

  /* Set the database version to 28. */

  set_db_version (28);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 27 to version 28.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_28_to_29 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 28. */

  if (manage_db_version () != 28)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The reports table got a slave_task_uuid column. */

  sql ("ALTER TABLE reports ADD COLUMN slave_task_uuid;");
  sql ("UPDATE reports SET slave_task_uuid = ''");

  /* Set the database version to 29. */

  set_db_version (29);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 29 to version 30.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_29_to_30 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 29. */

  if (manage_db_version () != 29)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The agents table got an installer_trust_time column. */

  sql ("ALTER TABLE agents ADD column installer_trust_time;");
  sql ("UPDATE agents SET installer_trust_time = %i;", time (NULL));

  /* Set the database version to 30. */

  set_db_version (30);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 30 to version 31.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_30_to_31 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 30. */

  if (manage_db_version () != 30)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* Slaves switched from being targets to being resources of their own.
   * Just clear any task slaves. */

  sql ("UPDATE tasks SET slave = 0;");

  /* Set the database version to 31. */

  set_db_version (31);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 31 to version 32.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_31_to_32 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 31. */

  if (manage_db_version () != 31)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* Ensure that the report_format_params table exists. */

  sql ("CREATE TABLE IF NOT EXISTS report_format_params"
       " (id INTEGER PRIMARY KEY, report_format, name, value);");

  /* The report_format_params table got a type column. */

  sql ("ALTER TABLE report_format_params ADD column type INTEGER;");
  sql ("UPDATE report_format_params SET type = 3;");

  /* Set the database version to 32. */

  set_db_version (32);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 32 to version 33.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_32_to_33 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 32. */

  if (manage_db_version () != 32)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The report_format_params table got a few new columns. */

  sql ("ALTER TABLE report_format_params ADD column type_min;");
  sql ("UPDATE report_format_params SET type_min = %lli;", LLONG_MIN);

  sql ("ALTER TABLE report_format_params ADD column type_max;");
  sql ("UPDATE report_format_params SET type_max = %lli;", LLONG_MAX);

  sql ("ALTER TABLE report_format_params ADD column type_regex;");
  sql ("UPDATE report_format_params SET type_regex = '';");

  sql ("ALTER TABLE report_format_params ADD column fallback;");
  sql ("UPDATE report_format_params SET fallback = value;");

  /* Set the database version to 33. */

  set_db_version (33);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Set the pref for migrate_33_to_34.
 *
 * @param[in]  config  Config to set pref on.
 */
static void
migrate_33_to_34_set_pref (config_t config)
{
  if (sql_int (0, 0,
               "SELECT count(*) FROM config_preferences"
               " WHERE config = %llu"
               " AND name ="
               " 'Login configurations[checkbox]:NTLMSSP';",
               config)
      == 0)
    sql ("INSERT into config_preferences (config, type, name, value)"
         " VALUES (%llu, 'PLUGINS_PREFS',"
         " 'Login configurations[checkbox]:NTLMSSP',"
         " 'yes');",
         config);
}

/**
 * @brief Migrate the database from version 33 to version 34.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_33_to_34 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 33. */

  if (manage_db_version () != 33)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The preference "NTLMSSP" was set to yes in the predefined configs. */

  /** @todo ROLLBACK on failure. */

  migrate_33_to_34_set_pref (CONFIG_ID_FULL_AND_FAST);
  migrate_33_to_34_set_pref (CONFIG_ID_FULL_AND_FAST_ULTIMATE);
  migrate_33_to_34_set_pref (CONFIG_ID_FULL_AND_VERY_DEEP);
  migrate_33_to_34_set_pref (CONFIG_ID_FULL_AND_VERY_DEEP_ULTIMATE);

  /* Set the database version to 34. */

  set_db_version (34);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 34 to version 35.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_34_to_35 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 34. */

  if (manage_db_version () != 34)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The LSC credential element of the target resource was split into two
   * elements, for SSH and SMB. */

  /** @todo ROLLBACK on failure. */

  sql ("ALTER TABLE targets ADD column smb_lsc_credential;");
  sql ("UPDATE targets SET smb_lsc_credential = lsc_credential;");

  /* Set the database version to 35. */

  set_db_version (35);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Make a copy of a target.
 *
 * @param[in]  target  Target to copy.
 * @param[in]  name    Name for new target.
 *
 * @return Address of matching character, else NULL.
 */
static target_t
migrate_35_to_36_duplicate_target (target_t target, const char *name)
{
  char *quoted_name = sql_quote (name);
  sql ("INSERT INTO targets"
       " (uuid, owner, name, hosts, comment, lsc_credential,"
       "  smb_lsc_credential)"
       " SELECT make_uuid (), owner, uniquify ('target', '%s', owner, ''),"
       "        hosts, comment, lsc_credential, smb_lsc_credential"
       " FROM targets WHERE ROWID = %llu;",
       quoted_name,
       target);
  g_free (quoted_name);
  return sqlite3_last_insert_rowid (task_db);
}

/**
 * @brief Migrate the database from version 35 to version 36.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_35_to_36 ()
{
  iterator_t tasks;
  char *scanner_range, *quoted_scanner_range;

  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 35. */

  if (manage_db_version () != 35)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* For a time between 1.0.0 beta3 and 1.0.0 beta5 the Manager would create
   * the example task with name references to the target and config, instead
   * of ID references.  Correct this now. */

  sql ("UPDATE tasks SET"
       " target = (SELECT ROWID FROM targets WHERE name = 'Localhost'),"
       " config = (SELECT ROWID FROM configs WHERE name = 'Full and fast')"
       " WHERE uuid = '" MANAGE_EXAMPLE_TASK_UUID "';");

  /* Scanner preference "port_range" moved from config into target. */

  /** @todo ROLLBACK on failure. */

  sql ("ALTER TABLE targets ADD column port_range;");
  sql ("UPDATE targets SET port_range = NULL;");

  scanner_range = sql_string (0, 0,
                              "SELECT value FROM nvt_preferences"
                              " WHERE name = 'port_range'");
  if (scanner_range)
    {
      quoted_scanner_range = sql_quote (scanner_range);
      free (scanner_range);
    }
  else
    quoted_scanner_range = NULL;

  init_iterator (&tasks, "SELECT ROWID, target, config FROM tasks;");
  while (next (&tasks))
    {
      char *config_range, *quoted_config_range;
      target_t target;

      target = iterator_int64 (&tasks, 1);

      if (sql_int (0, 0,
                   "SELECT port_range IS NULL FROM targets WHERE ROWID = %llu;",
                   target)
          == 0)
        {
          gchar *name;

          /* Already used this target, use a copy of it. */

          name = sql_string (0, 0,
                             "SELECT name || ' Migration' FROM targets"
                             " WHERE ROWID = %llu;",
                             target);
          assert (name);
          target = migrate_35_to_36_duplicate_target (target, name);
          free (name);

          sql ("UPDATE tasks SET target = %llu WHERE ROWID = %llu",
               target,
               iterator_int64 (&tasks, 0));
        }

      config_range = sql_string (0, 0,
                                 "SELECT value FROM config_preferences"
                                 " WHERE config = %llu"
                                 " AND name = 'port_range';",
                                 iterator_int64 (&tasks, 2));

      if (config_range)
        {
          quoted_config_range = sql_quote (config_range);
          free (config_range);
        }
      else
        quoted_config_range = NULL;

      sql ("UPDATE targets SET port_range = '%s'"
           " WHERE ROWID = %llu;",
           quoted_config_range
            ? quoted_config_range
            : (quoted_scanner_range ? quoted_scanner_range : "default"),
           target);

      free (quoted_config_range);
    }
  cleanup_iterator (&tasks);

  sql ("UPDATE targets SET port_range = 'default' WHERE port_range IS NULL;");

  sql ("DELETE FROM config_preferences WHERE name = 'port_range';");
  sql ("DELETE FROM nvt_preferences WHERE name = 'port_range';");

  free (quoted_scanner_range);

  /* Set the database version to 36. */

  set_db_version (36);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 36 to version 37.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_36_to_37 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 36. */

  if (manage_db_version () != 36)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The target and config clauses were swapped in the example task statement
     in migrate_35_to_36 in SVN for some time.  Run the statement again with
     the correct clauses. */

  sql ("UPDATE tasks SET"
       " target = (SELECT ROWID FROM targets WHERE name = 'Localhost'),"
       " config = (SELECT ROWID FROM configs WHERE name = 'Full and fast')"
       " WHERE uuid = '" MANAGE_EXAMPLE_TASK_UUID "';");

  /* Set the database version to 37. */

  set_db_version (37);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 37 to version 38.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_37_to_38 ()
{
  gchar *old_dir, *new_dir;

  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 37. */

  if (manage_db_version () != 37)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The report formats moved to FHS compliant locations. */

  /* Remove the global report format dirs, as they should have been
   * installed in the new location already. */

  old_dir = g_build_filename (OPENVAS_SYSCONF_DIR,
                              "openvasmd",
                              "global_report_formats",
                              NULL);

  openvas_file_remove_recurse (old_dir);
  g_free (old_dir);

  /* Move user uploaded report formats. */

  new_dir = g_build_filename (OPENVAS_STATE_DIR,
                              "openvasmd",
                              NULL);

  if (g_mkdir_with_parents (new_dir, 0755 /* "rwxr-xr-x" */))
    {
      g_warning ("%s: failed to create dir %s", __FUNCTION__, new_dir);
      g_free (new_dir);
      sql ("ROLLBACK;");
      return -1;
    }

  old_dir = g_build_filename (OPENVAS_SYSCONF_DIR,
                              "openvasmd",
                              "report_formats",
                              NULL);

  /* Ensure the old dir exists. */
  g_mkdir_with_parents (old_dir, 0755 /* "rwxr-xr-x" */);

  {
    gchar **cmd;
    gchar *standard_out = NULL;
    gchar *standard_err = NULL;
    gint exit_status;

    cmd = (gchar **) g_malloc (4 * sizeof (gchar *));
    cmd[0] = g_strdup ("mv");
    cmd[1] = old_dir;
    cmd[2] = new_dir;
    cmd[3] = NULL;
    g_debug ("%s: Spawning in .: %s %s %s\n",
             __FUNCTION__, cmd[0], cmd[1], cmd[2]);
    if ((g_spawn_sync (".",
                       cmd,
                       NULL,                  /* Environment. */
                       G_SPAWN_SEARCH_PATH,
                       NULL,                  /* Setup function. */
                       NULL,
                       &standard_out,
                       &standard_err,
                       &exit_status,
                       NULL)
         == FALSE)
        || (WIFEXITED (exit_status) == 0)
        || WEXITSTATUS (exit_status))
      {
        g_warning ("%s: failed rename: %d (WIF %i, WEX %i)",
                   __FUNCTION__,
                   exit_status,
                   WIFEXITED (exit_status),
                 WEXITSTATUS (exit_status));
        g_debug ("%s: stdout: %s\n", __FUNCTION__, standard_out);
        g_debug ("%s: stderr: %s\n", __FUNCTION__, standard_err);
        g_free (old_dir);
        g_free (new_dir);
        g_free (cmd[0]);
        g_free (cmd);
        sql ("ROLLBACK;");
        return -1;
      }

    g_free (cmd[0]);
    g_free (cmd);
  }

  g_free (old_dir);
  g_free (new_dir);

  /* Set the database version to 38. */

  set_db_version (38);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 38 to version 39.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_38_to_39 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 38. */

  if (manage_db_version () != 38)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The w3af NVT (80109) was removed from the predefined configs. */

  /* Just update the config comments, because init_manage will add the new
   * selectors. */

  sql ("UPDATE configs SET comment ="
       " 'Most NVT''s; optimized by using previously collected information.'"
       " WHERE id = " G_STRINGIFY (CONFIG_ID_FULL_AND_FAST) ";");

  sql ("UPDATE configs SET comment ="
       " 'Most NVT''s including those that can stop services/hosts;"
       " optimized by using previously collected information.'"
       " WHERE id = " G_STRINGIFY (CONFIG_ID_FULL_AND_FAST_ULTIMATE) ";");

  sql ("UPDATE configs SET comment ="
       " 'Most NVT''s; don''t trust previously collected information; slow.'"
       " WHERE id = " G_STRINGIFY (CONFIG_ID_FULL_AND_VERY_DEEP) ";");

  sql ("UPDATE configs SET comment ="
       " 'Most NVT''s including those that can stop services/hosts;"
       " don''t trust previously collected information; slow.'"
       " WHERE id = " G_STRINGIFY (CONFIG_ID_FULL_AND_VERY_DEEP_ULTIMATE) ";");

  /* Set the database version to 39. */

  set_db_version (39);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Set the pref for migrate_39_to_40.
 *
 * @param[in]  config  Config to set pref on.
 */
static void
migrate_39_to_40_set_pref (config_t config)
{
  sql ("UPDATE config_preferences SET value = 'yes'"
       " WHERE config = %llu"
       " AND type = 'SERVER_PREFS'"
       " AND name = 'unscanned_closed';",
       config);
}

/**
 * @brief Migrate the database from version 39 to version 40.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_39_to_40 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 39. */

  if (manage_db_version () != 39)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The preference "unscanned_closed" was set to yes in the predefined
   * configs. */

  /** @todo ROLLBACK on failure. */

  migrate_39_to_40_set_pref (CONFIG_ID_FULL_AND_FAST);
  migrate_39_to_40_set_pref (CONFIG_ID_FULL_AND_FAST_ULTIMATE);
  migrate_39_to_40_set_pref (CONFIG_ID_FULL_AND_VERY_DEEP);
  migrate_39_to_40_set_pref (CONFIG_ID_FULL_AND_VERY_DEEP_ULTIMATE);

  /* Set the database version to 40. */

  set_db_version (40);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 40 to version 41.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_40_to_41 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 40. */

  if (manage_db_version () != 40)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* For report formats, feed signatures were given priority over signatures
   * in imported XML.  This includes only setting the db signature when it is
   * imported.  So remove the db signatures for all predefined reports. */

  /** @todo ROLLBACK on failure. */

  sql ("UPDATE report_formats SET signature = NULL"
       " WHERE uuid = 'a0704abb-2120-489f-959f-251c9f4ffebd';");
  sql ("UPDATE report_formats SET signature = NULL"
       " WHERE uuid = 'b993b6f5-f9fb-4e6e-9c94-dd46c00e058d';");
  sql ("UPDATE report_formats SET signature = NULL"
       " WHERE uuid = '929884c6-c2c4-41e7-befb-2f6aa163b458';");
  sql ("UPDATE report_formats SET signature = NULL"
       " WHERE uuid = '9f1ab17b-aaaa-411a-8c57-12df446f5588';");
  sql ("UPDATE report_formats SET signature = NULL"
       " WHERE uuid = 'f5c2a364-47d2-4700-b21d-0a7693daddab';");
  sql ("UPDATE report_formats SET signature = NULL"
       " WHERE uuid = '1a60a67e-97d0-4cbf-bc77-f71b08e7043d';");
  sql ("UPDATE report_formats SET signature = NULL"
       " WHERE uuid = '19f6f1b3-7128-4433-888c-ccc764fe6ed5';");
  sql ("UPDATE report_formats SET signature = NULL"
       " WHERE uuid = 'd5da9f67-8551-4e51-807b-b6a873d70e34';");

  /* Set the database version to 41. */

  set_db_version (41);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 41 to version 42.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_41_to_42 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Require that the database is currently version 41. */

  if (manage_db_version () != 41)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* Two task tables got trashcan location fields. */

  /** @todo ROLLBACK on failure. */

  sql ("ALTER TABLE tasks ADD column config_location INTEGER;");
  sql ("ALTER TABLE tasks ADD column target_location INTEGER;");
  sql ("ALTER TABLE tasks ADD column schedule_location INTEGER;");
  sql ("ALTER TABLE tasks ADD column slave_location INTEGER;");

  sql ("UPDATE tasks SET"
       " config_location = " G_STRINGIFY (LOCATION_TABLE) ","
       " target_location = " G_STRINGIFY (LOCATION_TABLE) ","
       " schedule_location = " G_STRINGIFY (LOCATION_TABLE) ","
       " slave_location = " G_STRINGIFY (LOCATION_TABLE) ";");

  /* Ensure that the task_escalators table exists. */
  sql ("CREATE TABLE IF NOT EXISTS task_escalators"
       " (id INTEGER PRIMARY KEY, task INTEGER, escalator INTEGER);");

  sql ("ALTER TABLE task_escalators ADD column escalator_location INTEGER;");

  sql ("UPDATE task_escalators"
       " SET escalator_location = " G_STRINGIFY (LOCATION_TABLE) ";");

  /* Set the database version to 42. */

  set_db_version (42);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 42 to version 43.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_42_to_43 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Require that the database is currently version 42. */

  if (manage_db_version () != 42)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The targets table got an ssh_port field. */

  /** @todo ROLLBACK on failure. */

  /* Ensure that the targets_trash table exists. */
  sql ("CREATE TABLE IF NOT EXISTS targets_trash"
       " (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, hosts,"
       "  comment, lsc_credential INTEGER, smb_lsc_credential INTEGER,"
       "  port_range, ssh_location INTEGER, smb_location INTEGER);");

  sql ("ALTER TABLE targets ADD column ssh_port;");
  sql ("ALTER TABLE targets_trash ADD column ssh_port;");

  sql ("UPDATE targets SET ssh_port = 22"
       " WHERE lsc_credential > 0;");
  sql ("UPDATE targets_trash SET ssh_port = 22"
       " WHERE lsc_credential > 0;");

  /* Set the database version to 43. */

  set_db_version (43);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 43 to version 44.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_43_to_44 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Require that the database is currently version 43. */

  if (manage_db_version () != 43)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The file permission got much tighter. */

  if (chmod (task_db_name ? task_db_name : OPENVAS_STATE_DIR "/mgr/tasks.db",
             S_IRUSR | S_IWUSR))
    {
      g_warning ("%s: failed to chmod %s: %s",
                 __FUNCTION__,
                 task_db_name ? task_db_name
                              : OPENVAS_STATE_DIR "/mgr/tasks.db",
                 strerror (errno));
      sql ("ROLLBACK;");
      return -1;
    }

  /* Set the database version to 44. */

  set_db_version (44);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 44 to version 45.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_44_to_45 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Require that the database is currently version 44. */

  if (manage_db_version () != 44)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The tasks table got a upload_result_count column. */

  sql ("ALTER TABLE tasks ADD column upload_result_count;");
  sql ("UPDATE tasks SET upload_result_count = -1;");

  /* Set the database version to 45. */

  set_db_version (45);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 45 to version 46.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_45_to_46 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Require that the database is currently version 45. */

  if (manage_db_version () != 45)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* CREATE_TARGET now cleans the hosts string. */

  sql ("UPDATE targets SET hosts = clean_hosts (hosts);");
  sql ("UPDATE targets_trash SET hosts = clean_hosts (hosts);");

  /* Set the database version to 46. */

  set_db_version (46);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 46 to version 47.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_46_to_47 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Require that the database is currently version 46. */

  if (manage_db_version () != 46)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* Performance prefs move from config to task. */

  /* Ensure that the table exists. */
  sql ("CREATE TABLE IF NOT EXISTS task_preferences"
       " (id INTEGER PRIMARY KEY, task INTEGER, name, value);");

  sql ("INSERT INTO task_preferences (task, name, value)"
       " SELECT tasks.ROWID, config_preferences.name, config_preferences.value"
       " FROM tasks, config_preferences"
       " WHERE tasks.config = config_preferences.config"
       " AND (config_preferences.name = 'max_checks'"
       "      OR config_preferences.name = 'max_hosts')");

  /* Set the database version to 47. */

  set_db_version (47);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 47 to version 48.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_47_to_48 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Require that the database is currently version 47. */

  if (manage_db_version () != 47)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* Scanner "app" host detail changed name to "App". */

  /* Ensure that the table exists. */
  sql ("CREATE TABLE IF NOT EXISTS report_host_details"
       " (id INTEGER PRIMARY KEY, report_host INTEGER, source_type,"
       "  source_name, source_description, name, value);");

  sql ("UPDATE report_host_details SET name = 'App' WHERE name = 'app';");

  /* Set the database version to 48. */

  set_db_version (48);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 48 to version 49.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_48_to_49 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Require that the database is currently version 48. */

  if (manage_db_version () != 48)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* If the example task was created before version 14 then the 13 to 14
   * migrator would have given the example result an arbitrary UUID instead
   * of the predefined one.
   *
   * Also, the host of the example result has now changed to an IP. */

  sql ("UPDATE results SET uuid = 'cb291ec0-1b0d-11df-8aa1-002264764cea'"
       " WHERE host = 'localhost';");

  sql ("UPDATE results SET host = '127.0.0.1'"
       " WHERE uuid = 'cb291ec0-1b0d-11df-8aa1-002264764cea';");

  sql ("UPDATE report_hosts SET host = '127.0.0.1'"
       " WHERE host = 'localhost';");

  /* Set the database version to 49. */

  set_db_version (49);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 49 to version 50.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_49_to_50 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 49. */

  if (manage_db_version () != 49)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The UNIQUE constraint in task_preferences was removed. */

  /* Move the table away. */

  sql ("ALTER TABLE task_preferences RENAME TO task_preferences_49;");

  /* Create the table in the new format. */

  sql ("CREATE TABLE IF NOT EXISTS task_preferences"
       " (id INTEGER PRIMARY KEY, task INTEGER, name, value);");

  /* Copy the data into the new table. */

  sql ("INSERT into task_preferences"
       " (id, task, name, value)"
       " SELECT"
       "  id, task, name, value"
       " FROM task_preferences_49;");

  /* Drop the old tables. */

  sql ("DROP TABLE task_preferences_49;");

  /* Set the database version to 50. */

  set_db_version (50);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 50 to version 51.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_50_to_51 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 50. */

  if (manage_db_version () != 50)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The user table got a timezone column. */

  sql ("ALTER TABLE users ADD column timezone;");
  sql ("UPDATE users SET timezone = NULL;");

  /* Set the database version to 51. */

  set_db_version (51);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Check whether the migration needs the real timezone.
 *
 * @param[in]  log_config  Log configuration.
 * @param[in]  database    Location of manage database.
 *
 * @return TRUE if yes, else FALSE.
 */
gboolean
manage_migrate_needs_timezone (GSList *log_config, const gchar *database)
{
  int db_version;
  g_log_set_handler (G_LOG_DOMAIN,
                     ALL_LOG_LEVELS,
                     (GLogFunc) openvas_log_func,
                     log_config);
  init_manage_process (0, database);
  db_version = manage_db_version ();
  cleanup_manage_process (TRUE);
  return db_version < 52;
}

/**
 * @brief Convert a UTC text time to an integer time since the Epoch.
 *
 * This is a callback for a scalar SQL function of one argument.
 *
 * @param[in]  context  SQL context.
 * @param[in]  argc     Number of arguments.
 * @param[in]  argv     Argument array.
 */
static void
migrate_51_to_52_sql_convert (sqlite3_context *context, int argc,
                              sqlite3_value** argv)
{
  const unsigned char *text_time;
  int epoch_time;
  struct tm tm;

  assert (argc == 1);

  text_time = sqlite3_value_text (argv[0]);
  if (text_time)
    {
      /* Scanner uses ctime: "Wed Jun 30 21:49:08 1993".
       *
       * The dates being converted are in the timezone that the Scanner was using.
       *
       * As a special case for this migrator, openvasmd.c uses the timezone
       * from the environment, instead of forcing UTC.  This allows the user
       * to set the timezone to be the same as the Scanner timezone, so
       * that these dates are converted from the Scanner timezone.  Even if
       * the user just leaves the timezone as is, it is likely to be the same
       * timezone she/he is running the Scanner under.
       */
      if (text_time && (strlen ((char*) text_time) > 0))
        {
          if (strptime ((char*) text_time, "%a %b %d %H:%M:%S %Y", &tm) == NULL)
            {
              sqlite3_result_error (context, "Failed to parse time", -1);
              return;
            }
          epoch_time = mktime (&tm);
          if (epoch_time == -1)
            {
              sqlite3_result_error (context, "Failed to make time", -1);
              return;
            }
        }
      else
        epoch_time = 0;
    }
  else
    epoch_time = 0;
  sqlite3_result_int (context, epoch_time);
}

/**
 * @brief Migrate the database from version 51 to version 52.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_51_to_52 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 51. */

  if (manage_db_version () != 51)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Add an SQL helper. */

  if (sqlite3_create_function (task_db,
                               "convert",
                               1,               /* Number of args. */
                               SQLITE_UTF8,
                               NULL,            /* Callback data. */
                               migrate_51_to_52_sql_convert,
                               NULL,            /* xStep. */
                               NULL)            /* xFinal. */
      != SQLITE_OK)
    {
      g_warning ("%s: failed to create convert", __FUNCTION__);
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* Date storage switched from text format to seconds since the epoch. */

  sql ("UPDATE report_hosts SET start_time = convert (start_time);");
  sql ("UPDATE report_hosts SET end_time = convert (end_time);");
  sql ("UPDATE reports SET start_time = convert (start_time);");
  sql ("UPDATE reports SET end_time = convert (end_time);");
  sql ("UPDATE tasks SET start_time = convert (start_time);");
  sql ("UPDATE tasks SET end_time = convert (end_time);");

  /* Set the database version to 52. */

  set_db_version (52);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 52 to version 53.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_52_to_53 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 52. */

  if (manage_db_version () != 52)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The overrides table got a end_time column. */

  /* Ensure that the table exists. */
  sql ("CREATE TABLE IF NOT EXISTS overrides"
       " (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, nvt,"
       "  creation_time, modification_time, text, hosts, port, threat,"
       "  new_threat, task INTEGER, result INTEGER);");

  sql ("ALTER TABLE overrides ADD column end_time;");
  sql ("UPDATE overrides SET end_time = 0;");

  /* Set the database version to 53. */

  set_db_version (53);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 53 to version 54.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_53_to_54 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 53. */

  if (manage_db_version () != 53)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The notes table got a end_time column. */

  /* Ensure that the table exists. */
  sql ("CREATE TABLE IF NOT EXISTS notes"
       " (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, nvt,"
       "  creation_time, modification_time, text, hosts, port, threat,"
       "  task INTEGER, result INTEGER);");

  sql ("ALTER TABLE notes ADD column end_time;");
  sql ("UPDATE notes SET end_time = 0;");

  /* Set the database version to 54. */

  set_db_version (54);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate a report format from version 54 to version 55.
 *
 * @param[in]  old_uuid  Old UUID.
 * @param[in]  new_uuid  New UUID.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_54_to_55_format (const char *old_uuid, const char *new_uuid)
{
  gchar *dir;

  dir = g_build_filename (OPENVAS_DATA_DIR,
                          "openvasmd",
                          "global_report_formats",
                          old_uuid,
                          NULL);

  if (g_file_test (dir, G_FILE_TEST_EXISTS) && openvas_file_remove_recurse (dir))
    {
      g_warning ("%s: failed to remove dir %s", __FUNCTION__, dir);
      g_free (dir);
      return -1;
    }
  g_free (dir);

  sql ("UPDATE report_formats"
       " SET uuid = '%s'"
       " WHERE uuid = '%s';",
       new_uuid,
       old_uuid);

  return 0;
}

/**
 * @brief Migrate the database from version 54 to version 55.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_54_to_55 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 54. */

  if (manage_db_version () != 54)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* For report formats, feed signatures were given priority over signatures
   * in imported XML.  This includes only setting the db signature when it is
   * imported.  So remove the db signatures for all predefined reports. */

  /** @todo ROLLBACK on failure. */

  if (migrate_54_to_55_format ("a0704abb-2120-489f-959f-251c9f4ffebd",
                               "5ceff8ba-1f62-11e1-ab9f-406186ea4fc5"))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (migrate_54_to_55_format ("b993b6f5-f9fb-4e6e-9c94-dd46c00e058d",
                               "6c248850-1f62-11e1-b082-406186ea4fc5"))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (migrate_54_to_55_format ("929884c6-c2c4-41e7-befb-2f6aa163b458",
                               "77bd6c4a-1f62-11e1-abf0-406186ea4fc5"))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (migrate_54_to_55_format ("9f1ab17b-aaaa-411a-8c57-12df446f5588",
                               "7fcc3a1a-1f62-11e1-86bf-406186ea4fc5"))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (migrate_54_to_55_format ("f5c2a364-47d2-4700-b21d-0a7693daddab",
                               "9ca6fe72-1f62-11e1-9e7c-406186ea4fc5"))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (migrate_54_to_55_format ("1a60a67e-97d0-4cbf-bc77-f71b08e7043d",
                               "a0b5bfb2-1f62-11e1-85db-406186ea4fc5"))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (migrate_54_to_55_format ("19f6f1b3-7128-4433-888c-ccc764fe6ed5",
                               "a3810a62-1f62-11e1-9219-406186ea4fc5"))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (migrate_54_to_55_format ("d5da9f67-8551-4e51-807b-b6a873d70e34",
                               "a994b278-1f62-11e1-96ac-406186ea4fc5"))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Set the database version to 55. */

  set_db_version (55);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 55 to version 56.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_55_to_56 ()
{
  iterator_t rows;

  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 55. */

  if (manage_db_version () != 55)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /* The port_range in the targets and targets_trash tables changed to
   * refer to a port list.  The targets_trash table got a port_list_location
   * column. */

  /** @todo ROLLBACK on failure. */

  /* Add the new column. */

  sql ("ALTER TABLE targets_trash ADD COLUMN port_list_location;");
  sql ("UPDATE targets_trash"
       " SET port_list_location = " G_STRINGIFY (LOCATION_TRASH) ";");

  /* Ensure the new tables exist for the migrator. */

  sql ("CREATE TABLE IF NOT EXISTS port_lists"
       " (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, comment);");
  sql ("CREATE TABLE IF NOT EXISTS port_lists_trash"
       " (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, comment);");
  sql ("CREATE TABLE IF NOT EXISTS port_ranges"
       " (id INTEGER PRIMARY KEY, uuid UNIQUE, port_list INTEGER, type,"
       "  start, end, comment, exclude);");
  sql ("CREATE TABLE IF NOT EXISTS port_ranges_trash"
       " (id INTEGER PRIMARY KEY, uuid UNIQUE, port_list INTEGER, type,"
       "  start, end, comment, exclude);");

  ensure_predefined_port_lists_exist ();

  /* Make a port list and port range(s) for each target. */

  init_iterator (&rows, "SELECT ROWID, owner, name, port_range FROM targets;");
  while (next (&rows))
    {
      resource_t target;
      const gchar *range;

      target = iterator_int64 (&rows, 0);
      range = iterator_string (&rows, 3);

      if (range && strcmp (range, "default"))
        {
          resource_t owner, list;
          const gchar *name;
          gchar *quoted_name;

          owner = iterator_int64 (&rows, 1);
          name = iterator_string (&rows, 2);
          quoted_name = sql_quote (name);

          /* Make the port list.  Store target in comment for modification
           * outside iteration. */

          sql ("INSERT INTO port_lists (uuid, owner, name, comment)"
               " VALUES (make_uuid (), %llu, '%s', %llu)",
               owner,
               quoted_name,
               target);

          g_free (quoted_name);

          list = sqlite3_last_insert_rowid (task_db);

          /* Convert old range (1-100,1649,210-214) to multiple new ranges. */

          {
            gchar **split, **point;

            while (*range && isblank (*range)) range++;

            split = g_strsplit (range, ",", 0);
            point = split;

            while (*point)
              {
                gchar *hyphen;

                hyphen = strchr (*point, '-');
                if (hyphen)
                  {
                    *hyphen = '\0';
                    hyphen++;

                    /* A range. */

                    sql ("INSERT INTO port_ranges"
                         " (uuid, port_list, type, start, end, comment,"
                         "  exclude)"
                         " VALUES"
                         " (make_uuid (), %llu, %i, %s, %s, '', 0)",
                         list,
                         PORT_PROTOCOL_TCP,
                         *point,
                         hyphen);
                  }
                else
                  {
                    /* A single port. */

                    sql ("INSERT INTO port_ranges"
                         " (uuid, port_list, type, start, end, comment,"
                         "  exclude)"
                         " VALUES"
                         " (make_uuid (), %llu, %i, %s, NULL, '',"
                         " 0)",
                         list,
                         PORT_PROTOCOL_TCP,
                         *point);
                  }
                point += 1;
              }

            g_strfreev (split);
          }
        }
      else
        sql ("UPDATE targets SET port_range"
             " = (SELECT ROWID FROM port_lists"
             "    WHERE uuid = '" PORT_LIST_UUID_DEFAULT "')"
             " WHERE ROWID = %llu;",
             target);
    }
  cleanup_iterator (&rows);

  /* Set the port_ranges of the targets to the new port lists. */

  sql ("UPDATE targets SET"
       " port_range = (SELECT ROWID FROM port_lists"
       "               WHERE comment = targets.ROWID)"
       " WHERE port_range"
       " != (SELECT ROWID FROM port_lists"
       "     WHERE uuid = '" PORT_LIST_UUID_DEFAULT "');");

  sql ("UPDATE port_lists SET"
       " comment = 'Migrated from target '"
       "           || (SELECT targets.name FROM targets"
       "               WHERE port_lists.ROWID = targets.port_range)"
       "           || '.'"
       " WHERE uuid != '" PORT_LIST_UUID_DEFAULT "';");

  /* Make a port list and port range(s) for each trash target. */

  init_iterator (&rows,
                 "SELECT ROWID, owner, name, port_range FROM targets_trash;");
  while (next (&rows))
    {
      resource_t target;
      gchar *range;

      target = iterator_int64 (&rows, 0);
      range = g_strdup (iterator_string (&rows, 3));

      if (range && strcmp (range, "default"))
        {
          resource_t owner, list;
          const gchar *name;
          gchar *quoted_name;

          owner = iterator_int64 (&rows, 1);
          name = iterator_string (&rows, 2);
          quoted_name = sql_quote (name);

          /* Make the port list.  Store target in comment for modification
           * outside iteration. */

          sql ("INSERT INTO port_lists_trash (uuid, owner, name, comment)"
               " VALUES (make_uuid (), %llu, '%s', %llu)",
               owner,
               quoted_name,
               target);

          g_free (quoted_name);

          list = sqlite3_last_insert_rowid (task_db);

          /* Convert old range (1-100,1649,210-214) to multiple new ranges. */

          {
            gchar **split, **point;

            while (*range && isblank (*range)) range++;

            split = g_strsplit (range, ",", 0);
            point = split;

            while (*point)
              {
                gchar *hyphen;

                hyphen = strchr (*point, '-');
                if (hyphen)
                  {
                    *hyphen = '\0';
                    hyphen++;

                    /* A range. */

                    sql ("INSERT INTO port_ranges_trash"
                         " (uuid, port_list, type, start, end, comment,"
                         "  exclude)"
                         " VALUES"
                         " (make_uuid (), %llu, %i, %s, %s, '', 0)",
                         list,
                         PORT_PROTOCOL_TCP,
                         *point,
                         hyphen);
                  }
                else
                  {
                    /* A single port. */

                    sql ("INSERT INTO port_ranges_trash"
                         " (uuid, port_list, type, start, end, comment,"
                         "  exclude)"
                         " VALUES"
                         " (make_uuid (), %llu, %i, %s, NULL, '',"
                         " 0)",
                         list,
                         PORT_PROTOCOL_TCP,
                         *point);
                  }
                point += 1;
              }

            g_strfreev (split);
          }
        }
      else
        sql ("UPDATE targets_trash SET port_range"
             " = (SELECT ROWID FROM port_lists"
             "    WHERE uuid = '" PORT_LIST_UUID_DEFAULT "'),"
             " port_list_location = " G_STRINGIFY (LOCATION_TABLE)
             " WHERE ROWID = %llu;",
             target);

      g_free (range);
    }
  cleanup_iterator (&rows);

  /* Set the port_ranges of the trash targets to the new port lists. */

  sql ("UPDATE targets_trash SET"
       " port_range = (SELECT ROWID FROM port_lists_trash"
       "               WHERE comment = targets_trash.ROWID)"
       " WHERE port_range"
       " != (SELECT ROWID FROM port_lists"
       "     WHERE uuid = '" PORT_LIST_UUID_DEFAULT "');");

  sql ("UPDATE port_lists_trash SET"
       " comment = 'Migrated from trashcan target '"
       "           || (SELECT targets_trash.name FROM targets_trash"
       "               WHERE port_lists_trash.ROWID = targets_trash.port_range)"
       "           || '.'");

  /* Set the database version to 56. */

  set_db_version (56);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 56 to version 57.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_56_to_57 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 56. */

  if (manage_db_version () != 56)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /** @todo ROLLBACK on failure. */

  /* Escalators were renamed to alerts. */

  sql ("CREATE TABLE alert_condition_data"
       " (id INTEGER PRIMARY KEY, alert INTEGER, name, data);");
  sql_rename_column ("escalator_condition_data", "alert_condition_data",
                     "escalator", "alert");
  sql ("DROP TABLE escalator_condition_data;");

  sql ("CREATE TABLE alert_event_data"
       " (id INTEGER PRIMARY KEY, alert INTEGER, name, data);");
  sql_rename_column ("escalator_event_data", "alert_event_data",
                     "escalator", "alert");
  sql ("DROP TABLE escalator_event_data;");

  sql ("CREATE TABLE alert_event_data_trash"
       " (id INTEGER PRIMARY KEY, alert INTEGER, name, data);");
  sql_rename_column ("escalator_event_data_trash", "alert_event_data_trash",
                     "escalator", "alert");
  sql ("DROP TABLE escalator_event_data_trash;");

  sql ("CREATE TABLE alert_method_data"
       " (id INTEGER PRIMARY KEY, alert INTEGER, name, data);");
  sql_rename_column ("escalator_method_data", "alert_method_data",
                     "escalator", "alert");
  sql ("DROP TABLE escalator_method_data;");

  sql ("CREATE TABLE alert_method_data_trash"
       " (id INTEGER PRIMARY KEY, alert INTEGER, name, data);");
  sql_rename_column ("escalator_method_data_trash", "alert_method_data_trash",
                     "escalator", "alert");
  sql ("DROP TABLE escalator_method_data_trash;");

  sql ("CREATE TABLE alerts"
       " (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, comment,"
       "  event INTEGER, condition INTEGER, method INTEGER);");
  sql_rename_column ("escalators", "alerts",
                     "escalator", "alert");
  sql ("DROP TABLE escalators;");

  sql ("CREATE TABLE alerts_trash"
       " (id INTEGER PRIMARY KEY, uuid UNIQUE, owner INTEGER, name, comment,"
       "  event INTEGER, condition INTEGER, method INTEGER);");
  sql_rename_column ("escalators_trash", "alerts_trash",
                     "escalator", "alert");
  sql ("DROP TABLE escalators_trash;");

  sql ("CREATE TABLE task_alerts_56"
       " (id INTEGER PRIMARY KEY, task INTEGER, alert INTEGER,"
       "  escalator_location INTEGER);");
  sql_rename_column ("task_escalators", "task_alerts_56",
                     "escalator", "alert");
  sql ("DROP TABLE task_escalators;");

  sql ("CREATE TABLE task_alerts"
       " (id INTEGER PRIMARY KEY, task INTEGER, alert INTEGER,"
       "  alert_location INTEGER);");
  sql_rename_column ("task_alerts_56", "task_alerts",
                     "escalator_location", "alert_location");
  sql ("DROP TABLE task_alerts_56;");

  /* Set the database version to 57. */

  set_db_version (57);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 57 to version 58.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_57_to_58 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 57. */

  if (manage_db_version () != 57)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /** @todo ROLLBACK on failure. */

  /* Targets and agents got creation and modification times. */

  sql ("ALTER TABLE targets ADD COLUMN creation_time;");
  sql ("ALTER TABLE targets ADD COLUMN modification_time;");
  sql ("UPDATE targets SET creation_time = 0, modification_time = 0;");

  sql ("ALTER TABLE targets_trash ADD COLUMN creation_time;");
  sql ("ALTER TABLE targets_trash ADD COLUMN modification_time;");
  sql ("UPDATE targets_trash SET creation_time = 0, modification_time = 0;");

  sql ("ALTER TABLE agents ADD COLUMN creation_time;");
  sql ("ALTER TABLE agents ADD COLUMN modification_time;");
  sql ("UPDATE agents SET creation_time = 0, modification_time = 0;");

  sql ("ALTER TABLE agents_trash ADD COLUMN creation_time;");
  sql ("ALTER TABLE agents_trash ADD COLUMN modification_time;");
  sql ("UPDATE agents_trash SET creation_time = 0, modification_time = 0;");

  /* Set the database version to 58. */

  set_db_version (58);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 58 to version 59.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_58_to_59 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 58. */

  if (manage_db_version () != 58)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /** @todo ROLLBACK on failure. */

  /* Database version 55 introduced new UUIDs for the predefined report formats.
     Update the alert method data to use these new UUIDs. */

  sql ("UPDATE alert_method_data"
       " SET data = '5ceff8ba-1f62-11e1-ab9f-406186ea4fc5'"
       " WHERE data = 'a0704abb-2120-489f-959f-251c9f4ffebd';");

  sql ("UPDATE alert_method_data"
       " SET data = '6c248850-1f62-11e1-b082-406186ea4fc5'"
       " WHERE data = 'b993b6f5-f9fb-4e6e-9c94-dd46c00e058d';");

  sql ("UPDATE alert_method_data"
       " SET data = '77bd6c4a-1f62-11e1-abf0-406186ea4fc5'"
       " WHERE data = '929884c6-c2c4-41e7-befb-2f6aa163b458';");

  sql ("UPDATE alert_method_data"
       " SET data = '7fcc3a1a-1f62-11e1-86bf-406186ea4fc5'"
       " WHERE data = '9f1ab17b-aaaa-411a-8c57-12df446f5588';");

  sql ("UPDATE alert_method_data"
       " SET data = '9ca6fe72-1f62-11e1-9e7c-406186ea4fc5'"
       " WHERE data = 'f5c2a364-47d2-4700-b21d-0a7693daddab';");

  sql ("UPDATE alert_method_data"
       " SET data = 'a0b5bfb2-1f62-11e1-85db-406186ea4fc5'"
       " WHERE data = '1a60a67e-97d0-4cbf-bc77-f71b08e7043d';");

  sql ("UPDATE alert_method_data"
       " SET data = 'a3810a62-1f62-11e1-9219-406186ea4fc5'"
       " WHERE data = '19f6f1b3-7128-4433-888c-ccc764fe6ed5';");

  sql ("UPDATE alert_method_data"
       " SET data = 'a994b278-1f62-11e1-96ac-406186ea4fc5'"
       " WHERE data = 'd5da9f67-8551-4e51-807b-b6a873d70e34';");

  /* Set the database version to 59. */

  set_db_version (59);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 59 to version 60.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_59_to_60 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 59. */

  if (manage_db_version () != 59)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /** @todo ROLLBACK on failure. */

  /* Every task must now have an in_assets task preference. */

  sql ("INSERT INTO task_preferences (task, name, value)"
       " SELECT ROWID, 'in_assets', 'yes' FROM tasks;");

  /* Set the database version to 60. */

  set_db_version (60);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 60 to version 61.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_60_to_61 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 60. */

  if (manage_db_version () != 60)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /** @todo ROLLBACK on failure. */

  /* The alerts and alerts_trash tables got filter columns. */

  sql ("ALTER TABLE alerts ADD COLUMN filter INTEGER;");
  sql ("UPDATE alerts SET filter = 0;");

  sql ("ALTER TABLE alerts_trash ADD COLUMN filter INTEGER;");
  sql ("UPDATE alerts_trash SET filter = 0;");

  sql ("ALTER TABLE alerts_trash ADD COLUMN filter_location INTEGER;");
  sql ("UPDATE alerts_trash SET filter_location = 0;");

  /* Set the database version to 61. */

  set_db_version (61);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 61 to version 62.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_61_to_62 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 61. */

  if (manage_db_version () != 61)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /** @todo ROLLBACK on failure. */

  /* The reports table got count cache columns. */

  sql ("ALTER TABLE reports ADD COLUMN highs;");
  sql ("ALTER TABLE reports ADD COLUMN mediums;");
  sql ("ALTER TABLE reports ADD COLUMN lows;");
  sql ("ALTER TABLE reports ADD COLUMN logs;");
  sql ("ALTER TABLE reports ADD COLUMN fps;");
  sql ("ALTER TABLE reports ADD COLUMN override_highs;");
  sql ("ALTER TABLE reports ADD COLUMN override_mediums;");
  sql ("ALTER TABLE reports ADD COLUMN override_lows;");
  sql ("ALTER TABLE reports ADD COLUMN override_logs;");
  sql ("ALTER TABLE reports ADD COLUMN override_fps;");

  sql ("UPDATE reports SET highs = -1, override_highs = -1;");

  /* Set the database version to 62. */

  set_db_version (62);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 62 to version 63.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_62_to_63 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 62. */

  if (manage_db_version () != 62)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /** @todo ROLLBACK on failure. */

  /* The reports table got count cache columns. */

  sql ("ALTER TABLE schedules ADD COLUMN timezone;");
  sql ("ALTER TABLE schedules ADD COLUMN initial_offset;");

  sql ("UPDATE schedules"
       " SET timezone = (SELECT users.timezone FROM users"
       "                 WHERE ROWID = schedules.owner);");

  sql ("UPDATE schedules SET initial_offset = current_offset (timezone);");

  sql ("ALTER TABLE schedules_trash ADD COLUMN timezone;");
  sql ("ALTER TABLE schedules_trash ADD COLUMN initial_offset;");

  sql ("UPDATE schedules_trash"
       " SET timezone = (SELECT users.timezone FROM users"
       "                 WHERE ROWID = schedules_trash.owner);");

  sql ("UPDATE schedules_trash"
       " SET initial_offset = current_offset (timezone);");

  /* Set the database version to 63. */

  set_db_version (63);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 63 to version 64.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_63_to_64 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 63. */

  if (manage_db_version () != 63)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /** @todo ROLLBACK on failure. */

  /* The results table got a report column. */

  sql ("ALTER TABLE results ADD COLUMN report;");

  sql ("UPDATE results SET report = (SELECT report FROM report_results"
       "                             WHERE result = results.rowid);");

  sql ("CREATE INDEX IF NOT EXISTS results_by_report_host"
       " ON results (report, host);");

  /* Set the database version to 64. */

  set_db_version (64);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 64 to version 65.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_64_to_65 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 64. */

  if (manage_db_version () != 64)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /** @todo ROLLBACK on failure. */

  /* The report column on new results was left blank. */

  sql ("UPDATE results SET report = (SELECT report FROM report_results"
       "                             WHERE result = results.rowid);");

  sql ("REINDEX results_by_report_host;");

  /* Set the database version to 65. */

  set_db_version (65);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 65 to version 66.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_65_to_66 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 65. */

  if (manage_db_version () != 65)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /** @todo ROLLBACK on failure. */

  /* Schedules got creation and modification times. */

  sql ("ALTER TABLE schedules ADD COLUMN creation_time;");
  sql ("ALTER TABLE schedules ADD COLUMN modification_time;");
  sql ("UPDATE schedules SET creation_time = 0, modification_time = 0;");

  sql ("ALTER TABLE schedules_trash ADD COLUMN creation_time;");
  sql ("ALTER TABLE schedules_trash ADD COLUMN modification_time;");
  sql ("UPDATE schedules_trash SET creation_time = 0, modification_time = 0;");

  /* Set the database version to 66. */

  set_db_version (66);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 66 to version 67.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_66_to_67 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 66. */

  if (manage_db_version () != 66)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /** @todo ROLLBACK on failure. */

  /* Tasks got creation and modification times. */

  sql ("ALTER TABLE tasks ADD COLUMN creation_time;");
  sql ("ALTER TABLE tasks ADD COLUMN modification_time;");
  sql ("UPDATE tasks SET creation_time = 0, modification_time = 0;");

  /* Set the database version to 67. */

  set_db_version (67);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 67 to version 68.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_67_to_68 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 67. */

  if (manage_db_version () != 67)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /** @todo ROLLBACK on failure. */

  /* Schedules got creation and modification times. */

  sql ("ALTER TABLE slaves ADD COLUMN creation_time;");
  sql ("ALTER TABLE slaves ADD COLUMN modification_time;");
  sql ("UPDATE slaves SET creation_time = 0, modification_time = 0;");

  sql ("ALTER TABLE slaves_trash ADD COLUMN creation_time;");
  sql ("ALTER TABLE slaves_trash ADD COLUMN modification_time;");
  sql ("UPDATE slaves_trash SET creation_time = 0, modification_time = 0;");

  /* Set the database version to 68. */

  set_db_version (68);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 68 to version 69.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_68_to_69 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 68. */

  if (manage_db_version () != 68)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /** @todo ROLLBACK on failure. */

  /* Schedules got creation and modification times. */

  sql ("ALTER TABLE report_formats ADD COLUMN creation_time;");
  sql ("ALTER TABLE report_formats ADD COLUMN modification_time;");
  sql ("UPDATE report_formats SET creation_time = 0, modification_time = 0;");

  sql ("ALTER TABLE report_formats_trash ADD COLUMN creation_time;");
  sql ("ALTER TABLE report_formats_trash ADD COLUMN modification_time;");
  sql ("UPDATE report_formats_trash SET"
       " creation_time = 0, modification_time = 0;");

  /* Set the database version to 69. */

  set_db_version (69);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 69 to version 70.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_69_to_70 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 69. */

  if (manage_db_version () != 69)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /** @todo ROLLBACK on failure. */

  /* Add creation and modification times to Port Lists. */

  sql ("ALTER TABLE port_lists ADD COLUMN creation_time;");
  sql ("ALTER TABLE port_lists ADD COLUMN modification_time;");
  sql ("UPDATE port_lists SET creation_time = 0, modification_time = 0;");

  sql ("ALTER TABLE port_lists_trash ADD COLUMN creation_time;");
  sql ("ALTER TABLE port_lists_trash ADD COLUMN modification_time;");
  sql ("UPDATE port_lists_trash SET"
       " creation_time = 0, modification_time = 0;");

  /* Set the database version to 70. */

  set_db_version (70);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 70 to version 71.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_70_to_71 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 70. */

  if (manage_db_version () != 70)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /** @todo ROLLBACK on failure. */

  /* Add creation and modification times to alerts. */

  sql ("ALTER TABLE alerts ADD COLUMN creation_time;");
  sql ("ALTER TABLE alerts ADD COLUMN modification_time;");
  sql ("UPDATE alerts SET creation_time = 0, modification_time = 0;");

  sql ("ALTER TABLE alerts_trash ADD COLUMN creation_time;");
  sql ("ALTER TABLE alerts_trash ADD COLUMN modification_time;");
  sql ("UPDATE alerts_trash SET"
       " creation_time = 0, modification_time = 0;");

  /* Set the database version to 71. */

  set_db_version (71);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 71 to version 72.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_71_to_72 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 71. */

  if (manage_db_version () != 71)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /** @todo ROLLBACK on failure. */

  /* Add creation and modification times to LSC Credentials. */

  sql ("ALTER TABLE lsc_credentials ADD COLUMN creation_time;");
  sql ("ALTER TABLE lsc_credentials ADD COLUMN modification_time;");
  sql ("UPDATE lsc_credentials SET creation_time = 0, modification_time = 0;");

  sql ("ALTER TABLE lsc_credentials_trash ADD COLUMN creation_time;");
  sql ("ALTER TABLE lsc_credentials_trash ADD COLUMN modification_time;");
  sql ("UPDATE lsc_credentials_trash SET"
       " creation_time = 0, modification_time = 0;");

  /* Set the database version to 72. */

  set_db_version (72);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 72 to version 73.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_72_to_73 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 72. */

  if (manage_db_version () != 72)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /** @todo ROLLBACK on failure. */

  /* Add creation and modification times to Scan Configs. */

  sql ("ALTER TABLE configs ADD COLUMN creation_time;");
  sql ("ALTER TABLE configs ADD COLUMN modification_time;");
  sql ("UPDATE configs SET creation_time = 0, modification_time = 0;");

  sql ("ALTER TABLE configs_trash ADD COLUMN creation_time;");
  sql ("ALTER TABLE configs_trash ADD COLUMN modification_time;");
  sql ("UPDATE configs_trash SET creation_time = 0, modification_time = 0;");

  /* Set the database version to 73. */

  set_db_version (73);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Migrate the database from version 73 to version 74.
 *
 * @return 0 success, -1 error.
 */
static int
migrate_73_to_74 ()
{
  sql ("BEGIN EXCLUSIVE;");

  /* Ensure that the database is currently version 73. */

  if (manage_db_version () != 73)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Update the database. */

  /** @todo ROLLBACK on failure. */

  /* Add creation and modification times to Scan Configs. */

  sql ("ALTER TABLE nvts ADD COLUMN uuid;");
  sql ("UPDATE nvts SET uuid = oid;");

  sql ("ALTER TABLE nvts ADD COLUMN comment;");
  sql ("UPDATE nvts SET comment = '';");

  sql ("ALTER TABLE nvts ADD COLUMN creation_time;");
  sql ("ALTER TABLE nvts ADD COLUMN modification_time;");
  sql ("UPDATE nvts SET"
       " creation_time = parse_time (tag (tag, 'creation_date')),"
       " modification_time = parse_time (tag (tag, 'last_modification'));");

  /* Set the database version to 74. */

  set_db_version (74);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Array of database version migrators.
 */
static migrator_t database_migrators[]
 = {{0, NULL},
    {1, migrate_0_to_1},
    {2, migrate_1_to_2},
    {3, migrate_2_to_3},
    {4, migrate_3_to_4},
    {5, migrate_4_to_5},
    {6, migrate_5_to_6},
    {7, migrate_6_to_7},
    {8, migrate_7_to_8},
    {9, migrate_8_to_9},
    {10, migrate_9_to_10},
    {11, migrate_10_to_11},
    {12, migrate_11_to_12},
    {13, migrate_12_to_13},
    {14, migrate_13_to_14},
    {15, migrate_14_to_15},
    {16, migrate_15_to_16},
    {17, migrate_16_to_17},
    {18, migrate_17_to_18},
    {19, migrate_18_to_19},
    {20, migrate_19_to_20},
    {21, migrate_20_to_21},
    {22, migrate_21_to_22},
    {23, migrate_22_to_23},
    {24, migrate_23_to_24},
    {25, migrate_24_to_25},
    {26, migrate_25_to_26},
    {27, migrate_26_to_27},
    {28, migrate_27_to_28},
    {29, migrate_28_to_29},
    {30, migrate_29_to_30},
    {31, migrate_30_to_31},
    {32, migrate_31_to_32},
    {33, migrate_32_to_33},
    {34, migrate_33_to_34},
    {35, migrate_34_to_35},
    {36, migrate_35_to_36},
    {37, migrate_36_to_37},
    {38, migrate_37_to_38},
    {39, migrate_38_to_39},
    {40, migrate_39_to_40},
    {41, migrate_40_to_41},
    {42, migrate_41_to_42},
    {43, migrate_42_to_43},
    {44, migrate_43_to_44},
    {45, migrate_44_to_45},
    {46, migrate_45_to_46},
    {47, migrate_46_to_47},
    {48, migrate_47_to_48},
    {49, migrate_48_to_49},
    {50, migrate_49_to_50},
    {51, migrate_50_to_51},
    {52, migrate_51_to_52},
    {53, migrate_52_to_53},
    {54, migrate_53_to_54},
    {55, migrate_54_to_55},
    {56, migrate_55_to_56},
    {57, migrate_56_to_57},
    {58, migrate_57_to_58},
    {59, migrate_58_to_59},
    {60, migrate_59_to_60},
    {61, migrate_60_to_61},
    {62, migrate_61_to_62},
    {63, migrate_62_to_63},
    {64, migrate_63_to_64},
    {65, migrate_64_to_65},
    {66, migrate_65_to_66},
    {67, migrate_66_to_67},
    {68, migrate_67_to_68},
    {69, migrate_68_to_69},
    {70, migrate_69_to_70},
    {71, migrate_70_to_71},
    {72, migrate_71_to_72},
    {73, migrate_72_to_73},
    {74, migrate_73_to_74},
    /* End marker. */
    {-1, NULL}};

/**
 * @brief Check whether a migration is available.
 *
 * @param[in]  old_version  Version to migrate from.
 * @param[in]  new_version  Version to migrate to.
 *
 * @return 1 yes, 0 no, -1 error.
 */
static int
migrate_is_available (int old_version, int new_version)
{
  migrator_t *migrators;

  migrators = database_migrators + old_version + 1;

  while ((migrators->version >= 0) && (migrators->version <= new_version))
    {
      if (migrators->function == NULL) return 0;
      if (migrators->version == new_version) return 1;
      migrators++;
    }

  return -1;
}

/**
 * @brief Migrate database to version supported by this manager.
 *
 * @param[in]  log_config  Log configuration.
 * @param[in]  database    Location of manage database.
 *
 * @return 0 success, 1 already on supported version, 2 too hard, -1 error.
 */
int
manage_migrate (GSList *log_config, const gchar *database)
{
  migrator_t *migrators;
  /* The version on the disk. */
  int old_version;
  /* The version that this program requires. */
  int new_version;

  g_log_set_handler (G_LOG_DOMAIN,
                     ALL_LOG_LEVELS,
                     (GLogFunc) openvas_log_func,
                     log_config);

  init_manage_process (0, database);

  old_version = manage_db_version ();
  new_version = manage_db_supported_version ();

  if (old_version == -1)
    {
      cleanup_manage_process (TRUE);
      return -1;
    }

  if (old_version == new_version)
    {
      cleanup_manage_process (TRUE);
      return 1;
    }

  switch (migrate_is_available (old_version, new_version))
    {
      case -1:
        cleanup_manage_process (TRUE);
        return -1;
      case  0:
        cleanup_manage_process (TRUE);
        return  2;
    }

  /* Call the migrators to take the DB from the old version to the new. */

  migrators = database_migrators + old_version + 1;

  while ((migrators->version >= 0) && (migrators->version <= new_version))
    {
      if (migrators->function == NULL)
        {
          cleanup_manage_process (TRUE);
          return -1;
        }

      infof ("   Migrating to %i", migrators->version);

      if (migrators->function ())
        {
          cleanup_manage_process (TRUE);
          return -1;
        }
      migrators++;
    }

  cleanup_manage_process (TRUE);
  return 0;
}



/**
 * @brief Encrypt, re-encrypt or decrypt all credentials
 *
 * All plaintext credentials in the lsc_credentials table are
 * encrypted, all already encrypted credentials are encrypted again
 * using the latest key.
 *
 * @param[in] decrypt_flag  If true decrypt all credentials.
 *
 * @return 0 success, -1 error.
 */
static int
do_encrypt_all_credentials (gboolean decrypt_flag)
{
  iterator_t iterator;
  unsigned long ntotal, nencrypted, nreencrypted, ndecrypted;

  init_iterator (&iterator,
                 "SELECT ROWID, password, private_key FROM lsc_credentials");
  iterator.crypt_ctx = lsc_crypt_new ();

  sql ("BEGIN IMMEDIATE;");

  ntotal = nencrypted = nreencrypted = ndecrypted = 0;
  while (next (&iterator))
    {
      long long int rowid;
      const char *password, *privkey;

      ntotal++;
      if (!(ntotal % 10))
        g_message ("  %lu credentials so far processed", ntotal);

      rowid    = sqlite3_column_int64 (iterator.stmt, 0);
      password = (const char*) sqlite3_column_text (iterator.stmt, 1);
      privkey  = (const char*) sqlite3_column_text (iterator.stmt, 2);

      /* If there is no password or private key, skip the row.  */
      if (!password && !privkey)
        continue;

      /* If the row is alread encrypted, retrieve the plaintext values
         first.  */
      if (privkey && !strcmp (privkey, ";;encrypted;;"))
        {
          const char *tmp = password;

          lsc_crypt_flush (iterator.crypt_ctx);
          password = lsc_crypt_get_password (iterator.crypt_ctx, tmp);
          privkey  = lsc_crypt_get_private_key (iterator.crypt_ctx, tmp);

          /* If there is no password or private key, skip the row.  */
          if (!password && !privkey)
            continue;

          nreencrypted++;
        }
      else
        {
          if (decrypt_flag)
            continue; /* Skip non-encrypted rows.  */

          nencrypted++;
        }

      if (decrypt_flag)
        {
          char *quoted_password, *quoted_privkey;

          quoted_password = sql_insert (password);
          quoted_privkey  = sql_insert (privkey);

          sql ("UPDATE lsc_credentials SET password = %s,"
               " private_key = %s,"
               " modification_time = now ()"
               " WHERE ROWID = %llu;", quoted_password, quoted_privkey, rowid);
          g_free (quoted_password);
          g_free (quoted_privkey);
          ndecrypted++;
        }
      else
        {
          char *encblob;

          if (password && privkey)
            encblob = lsc_crypt_encrypt (iterator.crypt_ctx,
                                         "password", password,
                                         "private_key", privkey, NULL);
          else if (password)
            encblob = lsc_crypt_encrypt (iterator.crypt_ctx,
                                         "password", password, NULL);
          else
            encblob = lsc_crypt_encrypt (iterator.crypt_ctx,
                                         "private_key", privkey, NULL);

          if (!encblob)
            {
              sql ("ROLLBACK;");
              cleanup_iterator (&iterator);
              return -1;
            }
          sql ("UPDATE lsc_credentials SET password = '%s',"
               " private_key = ';;encrypted;;',"
               " modification_time = now ()"
               " WHERE ROWID = %llu;", encblob, rowid);
          g_free (encblob);
        }
    }

  sql ("COMMIT;");

  if (decrypt_flag)
    g_message ("%lu out of %lu credentials decrypted",
               ndecrypted, ntotal);
  else
    g_message ("%lu out of %lu credentials encrypted and %lu re-encrypted",
               nencrypted, ntotal, nreencrypted);
  cleanup_iterator (&iterator);
  return 0;
}

/**
 * @brief Driver to encrypt or re-encrypt all credentials
 *
 * All plaintext credentials in the lsc_credentials table are
 * encrypted, all already encrypted credentials are encrypted again
 * using the latest key.
 *
 * This function shall be used only by a command line option because
 * under SQLlite it locks the entire DB.
 *
 * @param[in] database      Location of manage database.
 * @param[in] decrypt_flag  If true decrypt all credentials.
 *
 * @return 0 success, -1 error.
 */
int
manage_encrypt_all_credentials (const gchar *database, gboolean decrypt_flag)
{
  int ret;
  const gchar *db = database ? database : OPENVAS_STATE_DIR "/mgr/tasks.db";

  init_manage_process (0, db);

  ret = do_encrypt_all_credentials (decrypt_flag);

  cleanup_manage_process (TRUE);

  return ret;
}



/* Collation. */

/**
 * @brief Collate two message type strings.
 *
 * Callback for SQLite "collate_message_type" collation.
 *
 * A lower threat is considered less than a higher threat, so Medium is
 * less than High.
 *
 * @param[in]  data     Dummy for callback.
 * @param[in]  one_len  Length of first string.
 * @param[in]  arg_one  First string.
 * @param[in]  two_len  Length of second string.
 * @param[in]  arg_two  Second string.
 *
 * @return -1, 0 or 1 if first is less than, equal to or greater than second.
 */
int
collate_message_type (void* data,
                      int one_len, const void* arg_one,
                      int two_len, const void* arg_two)
{
  const char* one = (const char*) arg_one;
  const char* two = (const char*) arg_two;

  if (strncmp (one, "Security Hole", one_len) == 0)
    {
      if (strncmp (two, "Security Hole", two_len) == 0)
        return 0;
      return 1;
    }
  if (strncmp (two, "Security Hole", two_len) == 0) return -1;

  if (strncmp (one, "Security Warning", one_len) == 0)
    {
      if (strncmp (two, "Security Warning", two_len) == 0)
        return 0;
      return 1;
    }
  if (strncmp (two, "Security Warning", two_len) == 0) return -1;

  if (strncmp (one, "Security Note", one_len) == 0)
    {
      if (strncmp (two, "Security Note", two_len) == 0)
        return 0;
      return 1;
    }
  if (strncmp (two, "Security Note", two_len) == 0) return -1;

  if (strncmp (one, "Log Message", one_len) == 0)
    {
      if (strncmp (two, "Log Message", two_len) == 0)
        return 0;
      return 1;
    }
  if (strncmp (two, "Log Message", two_len) == 0) return -1;

  if (strncmp (one, "Debug Message", one_len) == 0)
    {
      if (strncmp (two, "Debug Message", two_len) == 0)
        return 0;
      return 1;
    }
  if (strncmp (two, "Debug Message", two_len) == 0) return -1;

  return strncmp (one, two, MIN (one_len, two_len));
}

/**
 * @brief Collate two threat levels.
 *
 * A lower threat is considered less than a higher threat, so Medium is
 * less than High.
 *
 * @param[in]  data     Dummy for callback.
 * @param[in]  one_len  Length of first string.
 * @param[in]  arg_one  First string.
 * @param[in]  two_len  Length of second string.
 * @param[in]  arg_two  Second string.
 *
 * @return -1, 0 or 1 if first is less than, equal to or greater than second.
 */
int
collate_threat (void* data,
                int one_len, const void* arg_one,
                int two_len, const void* arg_two)
{
  const char* one = (const char*) arg_one;
  const char* two = (const char*) arg_two;

  if (one_len == 0)
    {
      if (two_len == 0)
        return 0;
      return -1;
    }
  if (two_len == 0)
    return 1;

  if (strncmp (one, "High", one_len) == 0)
    {
      if (strncmp (two, "High", two_len) == 0)
        return 0;
      return 1;
    }
  if (strncmp (two, "High", two_len) == 0) return -1;

  if (strncmp (one, "Medium", one_len) == 0)
    {
      if (strncmp (two, "Medium", two_len) == 0)
        return 0;
      return 1;
    }
  if (strncmp (two, "Medium", two_len) == 0) return -1;

  if (strncmp (one, "Low", one_len) == 0)
    {
      if (strncmp (two, "Low", two_len) == 0)
        return 0;
      return 1;
    }
  if (strncmp (two, "Low", two_len) == 0) return -1;

  if (strncmp (one, "Log", one_len) == 0)
    {
      if (strncmp (two, "Log", two_len) == 0)
        return 0;
      return 1;
    }
  if (strncmp (two, "Log", two_len) == 0) return -1;

  if (strncmp (one, "Debug", one_len) == 0)
    {
      if (strncmp (two, "Debug", two_len) == 0)
        return 0;
      return 1;
    }
  if (strncmp (two, "Debug", two_len) == 0) return -1;

  if (strncmp (one, "False Positive", one_len) == 0)
    {
      if (strncmp (two, "False Positive", two_len) == 0)
        return 0;
      return 1;
    }
  if (strncmp (two, "False Positive", two_len) == 0) return -1;

  if (strncmp (one, "None", one_len) == 0)
    {
      if (strncmp (two, "None", two_len) == 0)
        return 0;
      return 1;
    }
  if (strncmp (two, "None", two_len) == 0) return -1;

  return strncmp (one, two, MIN (one_len, two_len));
}

/**
 * @brief Compare two number strings for collate_ip.
 *
 * @param[in]  one_arg  First string.
 * @param[in]  two_arg  Second string.
 *
 * @return -1, 0 or 1 if first is less than, equal to or greater than second.
 */
static int
collate_ip_compare (const char *one_arg, const char *two_arg)
{
  int one = atoi (one_arg);
  int two = atoi (two_arg);
  return one == two ? 0 : (one < two ? -1 : 1);
}

/**
 * @brief Collate two IP addresses.
 *
 * For example, 127.0.0.2 is less than 127.0.0.3 and 127.0.0.10.
 *
 * Only works correctly for IPv4 addresses.
 *
 * @param[in]  data     Dummy for callback.
 * @param[in]  one_len  Length of first IP (a string).
 * @param[in]  arg_one  First string.
 * @param[in]  two_len  Length of second IP (a string).
 * @param[in]  arg_two  Second string.
 *
 * @return -1, 0 or 1 if first is less than, equal to or greater than second.
 */
int
collate_ip (void* data,
            int one_len, const void* arg_one,
            int two_len, const void* arg_two)
{
  int ret, one_dot, two_dot;
  char one_a[4], one_b[4], one_c[4], one_d[4];
  char two_a[4], two_b[4], two_c[4], two_d[4];
  const char* one = (const char*) arg_one;
  const char* two = (const char*) arg_two;

  if ((sscanf (one, "%3[0-9].%3[0-9].%3[0-9].%n%3[0-9]",
               one_a, one_b, one_c, &one_dot, one_d)
       == 4)
      && (sscanf (two, "%3[0-9].%3[0-9].%3[0-9].%n%3[0-9]",
                  two_a, two_b, two_c, &two_dot, two_d)
          == 4))
    {
      int ret = collate_ip_compare (one_a, two_a);
      if (ret) return ret < 0 ? -1 : 1;

      ret = collate_ip_compare (one_b, two_b);
      if (ret) return ret < 0 ? -1 : 1;

      ret = collate_ip_compare (one_c, two_c);
      if (ret) return ret < 0 ? -1 : 1;

      /* Ensure that the last number is limited to digits in the arg. */
      one_d[one_len - one_dot] = '\0';
      two_d[two_len - two_dot] = '\0';

      ret = collate_ip_compare (one_d, two_d);
      if (ret) return ret < 0 ? -1 : 1;

      return 0;
    }

  ret = strncmp (one, two, MIN (one_len, two_len));
  return ret == 0 ? 0 : (ret < 0 ? -1 : 1);
}


/* Access control. */

/**
 * @brief Generate accessor for an SQL iterator.
 *
 * This convenience macro is used to generate an accessor returning a
 * const string pointer.
 *
 * @param[in]  name  Name of accessor.
 * @param[in]  col   Column number to access.
 */
#define DEF_ACCESS(name, col) \
const char* \
name (iterator_t* iterator) \
{ \
  const char *ret; \
  if (iterator->done) return NULL; \
  ret = (const char*) sqlite3_column_text (iterator->stmt, col); \
  return ret; \
}

/**
 * @brief Initialise an escalator data iterator.
 *
 * @param[in]  iterator  Iterator.
 * @param[in]  task      Task.
 * @param[in]  action    Action.
 */
void
init_task_user_iterator (iterator_t *iterator, task_t task, action_t action)
{
  init_iterator (iterator,
                 "SELECT task_users.ROWID, task, user, actions,"
                 " (SELECT name FROM users WHERE users.ROWID = task_users.user)"
                 " FROM task_users"
                 " WHERE task = %llu AND actions & %u = %u;",
                 task,
                 action,
                 action);
}

/**
 * @brief Return the task from a task user iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Task of the iterator or NULL if iteration is complete.
 */
task_t
task_user_iterator_task (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return sqlite3_column_int64 (iterator->stmt, 1);
}

/**
 * @brief Return the user from a user user iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return User of the iterator or NULL if iteration is complete.
 */
user_t
task_user_iterator_user (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return sqlite3_column_int64 (iterator->stmt, 2);
}

/**
 * @brief Return the actions from a actions user iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Actions of the iterator or NULL if iteration is complete.
 */
int
task_user_iterator_actions (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return sqlite3_column_int64 (iterator->stmt, 3);
}

DEF_ACCESS (task_user_iterator_name, 4);


/* Events and Alerts. */

/**
 * @brief Find an alert given a UUID.
 *
 * @param[in]   uuid       UUID of alert.
 * @param[out]  alert  Return.  0 if succesfully failed to find alert.
 *
 * @return FALSE on success (including if failed to find alert), TRUE on
 *         error.
 */
gboolean
find_alert (const char* uuid, alert_t* alert)
{
  gchar *quoted_uuid = sql_quote (uuid);
  if (user_owns_uuid ("alert", quoted_uuid) == 0)
    {
      g_free (quoted_uuid);
      *alert = 0;
      return FALSE;
    }
  switch (sql_int64 (alert, 0, 0,
                     "SELECT ROWID FROM alerts WHERE uuid = '%s';",
                     quoted_uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *alert = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        g_free (quoted_uuid);
        return TRUE;
        break;
    }
  g_free (quoted_uuid);
  return FALSE;
}

/**
 * @brief Validate an email address.
 *
 * @param[in]  address  Email address.
 *
 * @return 0 success, 1 failure.
 */
int
validate_email (const char* address)
{
  gchar **split, *point;

  assert (address);

  split = g_strsplit (address, "@", 0);

  if (split[0] == NULL || split[1] == NULL || split[2])
    {
      g_strfreev (split);
      return 1;
    }

  /* Local part. */
  point = split[0];
  while (*point)
    if (isalnum (*point)
        || strchr ("!#$%&'*+-/=?^_`{|}~", *point)
        || ((*point == '.')
            && (point > split[0])
            && point[1]
            && (point[1] != '.')
            && (point[-1] != '.')))
      point++;
    else
      {
        g_strfreev (split);
        return 1;
      }

  /* Domain. */
  point = split[1];
  while (*point)
    if (isalnum (*point)
        || strchr ("-_", *point)  /* RFC actually forbids _. */
        || ((*point == '.')
            && (point > split[1])
            && point[1]
            && (point[1] != '.')
            && (point[-1] != '.')))
      point++;
    else
      {
        g_strfreev (split);
        return 1;
      }

  g_strfreev (split);
  return 0;
}

/**
 * @brief Create an alert.
 *
 * @param[in]  name            Name of alert.
 * @param[in]  comment         Comment on alert.
 * @param[in]  filter_id       Filter.
 * @param[in]  event           Type of event.
 * @param[in]  event_data      Type-specific event data.
 * @param[in]  condition       Event condition.
 * @param[in]  condition_data  Condition-specific data.
 * @param[in]  method          Escalation method.
 * @param[in]  method_data     Data for escalation method.
 * @param[out] alert       Created alert on success.
 *
 * @return 0 success, 1 escalation exists already, 2 validation of email failed,
 *         3 failed to find filter, 4 type must be "report" if specified,
 *         -1 error.
 */
int
create_alert (const char* name, const char* comment, const char* filter_id,
              event_t event, GPtrArray* event_data,
              alert_condition_t condition, GPtrArray* condition_data,
              alert_method_t method, GPtrArray* method_data,
              alert_t *alert)
{
  int index;
  gchar *item, *quoted_comment;
  gchar *quoted_name;
  filter_t filter;

  assert (current_credentials.uuid);

  sql ("BEGIN IMMEDIATE;");

  filter = 0;
  if (filter_id && strcmp (filter_id, "0"))
    {
      char *type;

      if (find_filter (filter_id, &filter))
        {
          sql ("ROLLBACK;");
          return -1;
        }

      if (filter == 0)
        {
          sql ("ROLLBACK;");
          return 3;
        }

      /* Filter type must be report if specified. */

      type = sql_string (0, 0,
                         "SELECT type FROM filters WHERE ROWID = %llu;",
                         filter);
      if (type && strcasecmp (type, "report"))
        {
          free (type);
          sql ("ROLLBACK;");
          return 4;
        }
      free (type);
    }

  quoted_name = sql_quote (name);

  if (sql_int (0, 0,
               "SELECT COUNT(*) FROM alerts WHERE name = '%s'"
               " AND ((owner IS NULL) OR (owner ="
               " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
               quoted_name,
               current_credentials.uuid))
    {
      g_free (quoted_name);
      sql ("ROLLBACK;");
      return 1;
    }

  quoted_comment = comment ? sql_quote (comment) : NULL;

  sql ("INSERT INTO alerts (uuid, owner, name, comment, event, condition,"
       " method, filter, creation_time, modification_time)"
       " VALUES (make_uuid (),"
       " (SELECT ROWID FROM users WHERE users.uuid = '%s'),"
       " '%s', '%s', %i, %i, %i, %llu, now (), now ());",
       current_credentials.uuid,
       quoted_name,
       quoted_comment ? quoted_comment : "",
       event,
       condition,
       method,
       filter);

  g_free (quoted_comment);
  g_free (quoted_name);

  *alert = sqlite3_last_insert_rowid (task_db);

  index = 0;
  while ((item = (gchar*) g_ptr_array_index (condition_data, index++)))
    {
      gchar *name = sql_quote (item);
      gchar *data = sql_quote (item + strlen (item) + 1);
      sql ("INSERT INTO alert_condition_data (alert, name, data)"
           " VALUES (%llu, '%s', '%s');",
           *alert,
           name,
           data);
      g_free (name);
      g_free (data);
    }

  index = 0;
  while ((item = (gchar*) g_ptr_array_index (event_data, index++)))
    {
      gchar *name = sql_quote (item);
      gchar *data = sql_quote (item + strlen (item) + 1);
      sql ("INSERT INTO alert_event_data (alert, name, data)"
           " VALUES (%llu, '%s', '%s');",
           *alert,
           name,
           data);
      g_free (name);
      g_free (data);
    }

  index = 0;
  while ((item = (gchar*) g_ptr_array_index (method_data, index++)))
    {
      gchar *name = sql_quote (item);
      gchar *data = sql_quote (item + strlen (item) + 1);
      if (method == ALERT_METHOD_EMAIL
          && (strcmp (name, "to_address") == 0
              || strcmp (name, "from_address") == 0)
          && validate_email (data))
        {
          g_free (name);
          g_free (data);
          sql ("ROLLBACK;");
          return 2;
        }

      sql ("INSERT INTO alert_method_data (alert, name, data)"
           " VALUES (%llu, '%s', '%s');",
           *alert,
           name,
           data);
      g_free (name);
      g_free (data);
    }

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Create an alert from an existing alert.
 *
 * @param[in]  name          Name of new alert. NULL to copy from existing.
 * @param[in]  comment       Comment on new alert. NULL to copy from
 *                           existing.
 * @param[in]  alert_id      UUID of existing alert.
 * @param[out] new_alert     New alert.
 *
 * @return 0 success, 1 alert exists already, 2 failed to find existing
 *         alert, -1 error.
 */
int
copy_alert (const char* name, const char* comment, const char* alert_id,
            alert_t* new_alert)
{
  alert_t new_id, alert;
  gchar *quoted_name, *quoted_comment, *quoted_uuid, *uniquify;
  char *alertchr;
  user_t owner;

  assert (current_credentials.uuid);

  if (alert_id == NULL)
    return -1;

  sql ("BEGIN IMMEDIATE");

  if (find_user (current_credentials.username, &owner)
      || owner == 0)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  quoted_name = sql_quote (name);

  /* Check for existing name. */
  if (quoted_name && strlen (quoted_name))
    {
      if (sql_int (0, 0,
                   "SELECT COUNT (*) FROM alerts WHERE name = '%s'"
                   " AND ((owner IS NULL) OR (owner = "
                   " (SELECT users.ROWID FROM users WHERE useres.uuid = '%s')));",
                   quoted_name,
                   current_credentials.uuid))
        {
          tracef ("   alert \"%s\" exists already\n", name);
          sql ("ROLLBACK");
          g_free (quoted_name);
          return 1;
        }
    }
  else
    quoted_name = NULL;

  quoted_uuid = sql_quote (alert_id);
  /* Check that alert to copy exists. */
  alertchr = sql_string (0, 0,
                         "SELECT ROWID FROM alerts"
                         " WHERE uuid = '%s'"
                         " AND ((owner IS NULL) OR (owner = %llu));",
                         quoted_uuid,
                         owner);
  if (alertchr == NULL)
    {
      sql ("ROLLBACK");
      g_free (quoted_name);
      g_free (quoted_uuid);
      return 2;
    }
  alert = atoi (alertchr);
  free (alertchr);

  /* Copy the alert. */
  if (comment && strlen (comment) > 0)
    quoted_comment = sql_nquote (comment, strlen (comment));
  else
    quoted_comment = NULL;

  uniquify = g_strdup_printf ("uniquify ('alert', name, %llu, ' Clone')",
                              owner);
  sql ("INSERT INTO alerts"
       " (uuid, name, owner, comment, event, condition, method, filter,"
       "  creation_time, modification_time)"
       " SELECT make_uuid (), %s%s%s, %llu, %s%s%s, event, condition, method,"
       "  filter, now (), now ()"
       " FROM alerts WHERE uuid = '%s';",
       quoted_name ? "'" : "",
       quoted_name ? quoted_name : uniquify,
       quoted_name ? "'" : "",
       owner,
       quoted_comment ? "'" : "",
       quoted_comment ? quoted_comment : "comment",
       quoted_comment ? "'" : "",
       quoted_uuid);

  new_id = sqlite3_last_insert_rowid (task_db);

  /* Copy the alert condition data */
  sql ("INSERT INTO alert_condition_data (alert, name, data)"
       " SELECT %llu, name, data FROM alert_condition_data"
       "  WHERE alert = %llu;",
       new_id,
       alert);

  /* Copy the alert event data */
  sql ("INSERT INTO alert_event_data (alert, name, data)"
       " SELECT %llu, name, data FROM alert_event_data"
       "  WHERE alert = %llu;",
       new_id,
       alert);

  /* Copy the alert method data */
  sql ("INSERT INTO alert_method_data (alert, name, data)"
       " SELECT %llu, name, data FROM alert_method_data"
       "  WHERE alert = %llu;",
       new_id,
       alert);

  sql ("COMMIT;");
  g_free (quoted_name);
  g_free (quoted_comment);
  g_free (quoted_uuid);
  g_free (uniquify);
  if (new_alert) *new_alert = new_id;
  return 0;
}

/**
 * @brief Modify an alert.
 *
 * @param[in]   alert_id        UUID of alert.
 * @param[in]   name            Name of alert.
 * @param[in]   comment         Comment on alert.
 * @param[in]   filter_id       Filter.
 * @param[in]   event           Type of event.
 * @param[in]   event_data      Type-specific event data.
 * @param[in]   condition       Event condition.
 * @param[in]   condition_data  Condition-specific data.
 * @param[in]   method          Escalation method.
 * @param[in]   method_data     Data for escalation method.
 *
 * @return 0 success, 1 failed to find alert, 2 alert with new name exists,
 *         3 alert_id required, 4 failed to find filter, 5 filter type must be
 *         report if specified, 6 Provided email address not valid,
 *         -1 internal error.
 */
int
modify_alert (const char *alert_id, const char *name, const char *comment,
              const char *filter_id, event_t event, GPtrArray *event_data,
              alert_condition_t condition, GPtrArray *condition_data,
              alert_method_t method, GPtrArray *method_data)
{
  int index;
  gchar *quoted_name, *quoted_comment, *item;
  alert_t alert;
  filter_t filter;

  if (alert_id == NULL)
    return 3;

  sql ("BEGIN IMMEDIATE;");

  assert (current_credentials.uuid);

  alert = 0;
  if (find_alert (alert_id, &alert))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (alert == 0)
    {
      sql ("ROLLBACK;");
      return 1;
    }

  /* Check whether an alert with the same name exists already. */
  if (name)
    {
      quoted_name = sql_quote (name);
      if (sql_int (0, 0,
                   "SELECT COUNT(*) FROM alerts"
                   " WHERE name = '%s'"
                   " AND ROWID != %llu"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                   quoted_name,
                   alert,
                   current_credentials.uuid))
        {
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return 2;
        }
    }
  else
    quoted_name = sql_quote("");

  /* Check filter. */
  filter = 0;
  if (filter_id && strcmp (filter_id, "0"))
    {
      char *type;

      if (find_filter (filter_id, &filter))
        {
          sql ("ROLLBACK;");
          return -1;
        }

      if (filter == 0)
        {
          sql ("ROLLBACK;");
          return 4;
        }

      /* Filter type must be report if specified. */

      type = sql_string (0, 0,
                         "SELECT type FROM filters WHERE ROWID = %llu;",
                         filter);
      if (type && strcasecmp (type, "report"))
        {
          free (type);
          sql ("ROLLBACK;");
          return 5;
        }
      free (type);
    }

  quoted_comment = sql_quote (comment ? comment : "");

  sql ("UPDATE alerts SET"
       " name = '%s',"
       " comment = '%s',"
       " filter = %llu,"
       " modification_time = now ()"
       " WHERE ROWID = %llu;",
       quoted_name,
       quoted_comment,
       filter,
       alert);

  g_free (quoted_comment);
  g_free (quoted_name);

  /* Modify alert event */
  if (event != EVENT_ERROR)
    {
      sql ("UPDATE alerts set event = %i WHERE ROWID = %llu", event, alert);
      sql ("DELETE FROM alert_event_data WHERE alert = %llu", alert);
      index = 0;
      while ((item = (gchar*) g_ptr_array_index (event_data, index++)))
        {
          gchar *name = sql_quote (item);
          gchar *data = sql_quote (item + strlen (item) + 1);
          sql ("INSERT INTO alert_event_data (alert, name, data)"
               " VALUES (%llu, '%s', '%s');",
               alert,
               name,
               data);
          g_free (name);
          g_free (data);
        }
    }

  /* Modify alert condition */
  if (condition != ALERT_CONDITION_ERROR)
    {
      sql ("UPDATE alerts set condition = %i WHERE ROWID = %llu",
           condition,
           alert);
      sql ("DELETE FROM alert_condition_data WHERE alert = %llu", alert);
      index = 0;
      while ((item = (gchar*) g_ptr_array_index (condition_data, index++)))
        {
          gchar *name = sql_quote (item);
          gchar *data = sql_quote (item + strlen (item) + 1);
          sql ("INSERT INTO alert_condition_data (alert, name, data)"
               " VALUES (%llu, '%s', '%s');",
               alert,
               name,
               data);
          g_free (name);
          g_free (data);
        }
    }

  /* Modify alert method */
  if (method != ALERT_METHOD_ERROR)
    {
      sql ("UPDATE alerts set method = %i WHERE ROWID = %llu", method, alert);
      sql ("DELETE FROM alert_method_data WHERE alert = %llu", alert);
      index = 0;
      while ((item = (gchar*) g_ptr_array_index (method_data, index++)))
        {
          gchar *name = sql_quote (item);
          gchar *data = sql_quote (item + strlen (item) + 1);
          if (method == ALERT_METHOD_EMAIL
              && (strcmp (name, "to_address") == 0
                  || strcmp (name, "from_address") == 0)
              && validate_email (data))
            {
              g_free (name);
              g_free (data);
              sql ("ROLLBACK;");
              return 6;
            }

          sql ("INSERT INTO alert_method_data (alert, name, data)"
               " VALUES (%llu, '%s', '%s');",
               alert,
               name,
               data);
          g_free (name);
          g_free (data);
        }
    }

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Delete an alert.
 *
 * @param[in]  alert_id  UUID of alert.
 * @param[in]  ultimate      Whether to remove entirely, or to trashcan.
 *
 * @return 0 success, 1 fail because a task refers to the alert, 2 failed
 *         to find target, -1 error.
 */
int
delete_alert (const char *alert_id, int ultimate)
{
  alert_t alert = 0;

  sql ("BEGIN IMMEDIATE;");

  if (find_alert (alert_id, &alert))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (alert == 0)
    {
      if (find_trash ("alert", alert_id, &alert))
        {
          sql ("ROLLBACK;");
          return -1;
        }
      if (alert == 0)
        {
          sql ("ROLLBACK;");
          return 2;
        }
      if (ultimate == 0)
        {
          /* It's already in the trashcan. */
          sql ("COMMIT;");
          return 0;
        }

      /* Check if it's in use by a task in the trashcan. */
      if (sql_int (0, 0,
                   "SELECT count(*) FROM task_alerts"
                   " WHERE alert = %llu"
                   " AND alert_location = " G_STRINGIFY (LOCATION_TRASH) ";",
                   alert))
        {
          sql ("ROLLBACK;");
          return 1;
        }

      sql ("DELETE FROM alert_condition_data_trash WHERE alert = %llu;",
           alert);
      sql ("DELETE FROM alert_event_data_trash WHERE alert = %llu;",
           alert);
      sql ("DELETE FROM alert_method_data_trash WHERE alert = %llu;",
           alert);
      sql ("DELETE FROM alerts_trash WHERE ROWID = %llu;", alert);
      sql ("COMMIT;");
      return 0;
    }

  if (ultimate == 0)
    {
      alert_t trash_alert;

      if (sql_int (0, 0,
                   "SELECT count(*) FROM task_alerts"
                   " WHERE alert = %llu"
                   " AND alert_location = " G_STRINGIFY (LOCATION_TABLE)
                   " AND (SELECT hidden < 2 FROM tasks"
                   "      WHERE ROWID = task_alerts.task);",
                   alert))
        {
          sql ("ROLLBACK;");
          return 1;
        }

      sql ("INSERT INTO alerts_trash"
           " (uuid, owner, name, comment, event, condition, method, filter,"
           "  filter_location, creation_time, modification_time)"
           " SELECT uuid, owner, name, comment, event, condition, method,"
           "        filter, " G_STRINGIFY (LOCATION_TABLE) ", creation_time,"
           "        now ()"
           " FROM alerts WHERE ROWID = %llu;",
           alert);

      trash_alert = sqlite3_last_insert_rowid (task_db);

      sql ("INSERT INTO alert_condition_data_trash"
           " (alert, name, data)"
           " SELECT %llu, name, data"
           " FROM alert_condition_data WHERE ROWID = %llu;",
           trash_alert);

      sql ("INSERT INTO alert_event_data_trash"
           " (alert, name, data)"
           " SELECT %llu, name, data"
           " FROM alert_event_data WHERE ROWID = %llu;",
           trash_alert);

      sql ("INSERT INTO alert_method_data_trash"
           " (alert, name, data)"
           " SELECT %llu, name, data"
           " FROM alert_method_data WHERE ROWID = %llu;",
           trash_alert);

      /* Update the location of the alert in any trashcan tasks. */
      sql ("UPDATE task_alerts"
           " SET alert = %llu,"
           "     alert_location = " G_STRINGIFY (LOCATION_TRASH)
           " WHERE alert = %llu"
           " AND alert_location = " G_STRINGIFY (LOCATION_TABLE) ";",
           trash_alert,
           alert);
    }
  else if (sql_int (0, 0,
           "SELECT count(*) FROM task_alerts"
           " WHERE alert = %llu"
           " AND alert_location = " G_STRINGIFY (LOCATION_TABLE) ";",
           alert))
    {
      sql ("ROLLBACK;");
      return 1;
    }

  sql ("DELETE FROM alert_condition_data WHERE alert = %llu;",
       alert);
  sql ("DELETE FROM alert_event_data WHERE alert = %llu;", alert);
  sql ("DELETE FROM alert_method_data WHERE alert = %llu;", alert);
  sql ("DELETE FROM alerts WHERE ROWID = %llu;", alert);
  sql ("COMMIT;");
  return 0;
}

/**
 * @brief Return the UUID of an alert.
 *
 * @param[in]  alert  Alert.
 *
 * @return UUID of alert.
 */
char *
alert_uuid (alert_t alert)
{
  return sql_string (0, 0,
                     "SELECT uuid FROM alerts WHERE ROWID = %llu;",
                     alert);
}

/**
 * @brief Return the UUID of the filter of an alert.
 *
 * @param[in]  alert  Alert.
 *
 * @return UUID if there's a filter, else NULL.
 */
char *
alert_filter_id (alert_t alert)
{
  return sql_string (0, 0,
                     "SELECT"
                     " (CASE WHEN (SELECT filter IS NULL OR filter = 0"
                     "             FROM alerts WHERE ROWID = %llu)"
                     "  THEN NULL"
                     "  ELSE (SELECT uuid FROM filters"
                     "        WHERE ROWID = (SELECT filter FROM alerts"
                     "                       WHERE ROWID = %llu))"
                     "  END);",
                     alert,
                     alert);
}

/**
 * @brief Return the condition associated with an alert.
 *
 * @param[in]  alert  Alert.
 *
 * @return Condition.
 */
static alert_condition_t
alert_condition (alert_t alert)
{
  return sql_int (0, 0,
                  "SELECT condition FROM alerts WHERE ROWID = %llu;",
                  alert);
}

/**
 * @brief Return the method associated with an alert.
 *
 * @param[in]  alert  Alert.
 *
 * @return Method.
 */
static alert_method_t
alert_method (alert_t alert)
{
  return sql_int (0, 0,
                  "SELECT method FROM alerts WHERE ROWID = %llu;",
                  alert);
}

/**
 * @brief Filter columns for alert iterator.
 */
#define ALERT_ITERATOR_FILTER_COLUMNS                                         \
 { GET_ITERATOR_FILTER_COLUMNS, "event", "condition", "method",               \
   "filter",  NULL }

/**
 * @brief Alert iterator columns.
 */
#define ALERT_ITERATOR_COLUMNS                                                \
  GET_ITERATOR_COLUMNS ", event, condition, method, filter, "                 \
  G_STRINGIFY (LOCATION_TABLE)

/**
 * @brief Alert iterator columns for trash case.
 */
#define ALERT_ITERATOR_TRASH_COLUMNS                                          \
  GET_ITERATOR_COLUMNS ", event, condition, method, filter, filter_location"

/**
 * @brief Count the number of alerts.
 *
 * @param[in]  get  GET params.
 *
 * @return Total number of alerts filtered set.
 */
int
alert_count (const get_data_t *get)
{
  static const char *extra_columns[] = ALERT_ITERATOR_FILTER_COLUMNS;
  return count ("alert", get, ALERT_ITERATOR_COLUMNS, extra_columns, 0, 0,
                0, TRUE);
}

/**
 * @brief Return whether a alert is in use by a task.
 *
 * @param[in]  alert  Alert.
 *
 * @return 1 if in use, else 0.
 */
int
alert_in_use (alert_t alert)
{
  return !!sql_int (0, 0,
                    "SELECT count (*) FROM task_alerts WHERE alert = %llu;",
                    alert);
}

/**
 * @brief Return whether a trashcan alert is in use by a task.
 *
 * @param[in]  alert  Alert.
 *
 * @return 1 if in use, else 0.
 */
int
trash_alert_in_use (alert_t alert)
{
  return !!sql_int (0, 0,
                    "SELECT count(*) FROM task_alerts"
                    " WHERE alert = %llu"
                    " AND alert_location = " G_STRINGIFY (LOCATION_TRASH),
                    alert);
}

/**
 * @brief Return whether a alert is writable.
 *
 * @param[in]  alert  Alert.
 *
 * @return 1 if writable, else 0.
 */
int
alert_writable (alert_t alert)
{
    return 1;
}

/**
 * @brief Return whether a trashcan alert is writable.
 *
 * @param[in]  alert  Alert.
 *
 * @return 1 if writable, else 0.
 */
int
trash_alert_writable (alert_t alert)
{
    return 1;
}

/**
 * @brief Initialise an alert iterator, including observed alerts.
 *
 * @param[in]  iterator    Iterator.
 * @param[in]  get         GET data.
 *
 * @return 0 success, 1 failed to find alert, failed to find filter (filt_id),
 *         -1 error.
 */
int
init_alert_iterator (iterator_t* iterator, const get_data_t *get)
{
  static const char *filter_columns[] = ALERT_ITERATOR_FILTER_COLUMNS;

  return init_get_iterator (iterator,
                            "alert",
                            get,
                            /* Columns. */
                            ALERT_ITERATOR_COLUMNS,
                            /* Columns for trashcan. */
                            ALERT_ITERATOR_TRASH_COLUMNS,
                            filter_columns,
                            NULL,
                            0,
                            NULL,
                            NULL,
                            TRUE);
}

/**
 * @brief Return the alert from an alert iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Alert of the iterator or NULL if iteration is complete.
 */
alert_t
alert_iterator_alert (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return sqlite3_column_int64 (iterator->stmt, 0);
}

/**
 * @brief Get the UUID from an alert iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return UUID, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (alert_iterator_uuid, 1);

/**
 * @brief Get the name from an alert iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (alert_iterator_name, 2);

/**
 * @brief Get the comment from an alert iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Comment, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (alert_iterator_comment, 3);

/**
 * @brief Return the event from an alert iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Event of the alert or NULL if iteration is complete.
 */
int
alert_iterator_event (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (int) sqlite3_column_int (iterator->stmt, GET_ITERATOR_COLUMN_COUNT);
  return ret;
}

/**
 * @brief Return the condition from an alert iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Condition of the alert or NULL if iteration is complete.
 */
int
alert_iterator_condition (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (int) sqlite3_column_int (iterator->stmt,
                                  GET_ITERATOR_COLUMN_COUNT + 1);
  return ret;
}

/**
 * @brief Return the method from an alert iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Method of the alert or NULL if iteration is complete.
 */
int
alert_iterator_method (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (int) sqlite3_column_int (iterator->stmt,
                                  GET_ITERATOR_COLUMN_COUNT + 2);
  return ret;
}

/**
 * @brief Return the filter from an alert iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Filter of the alert or NULL if iteration is complete.
 */
filter_t
alert_iterator_filter (iterator_t* iterator)
{
  if (iterator->done) return -1;
  return (filter_t) sqlite3_column_int64 (iterator->stmt,
                                          GET_ITERATOR_COLUMN_COUNT + 3);
}

/**
 * @brief Return the filter UUID from an alert iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return UUID of filter of the alert or NULL if iteration is complete.
 */
char *
alert_iterator_filter_uuid (iterator_t* iterator)
{
  filter_t filter;

  if (iterator->done) return NULL;

  filter = alert_iterator_filter (iterator);
  if (filter)
    {
      if (sqlite3_column_int (iterator->stmt,
                              GET_ITERATOR_COLUMN_COUNT + 4)
          == LOCATION_TABLE)
        return filter_uuid (filter);
      return trash_filter_uuid (filter);
    }
  return NULL;
}

/**
 * @brief Return the filter name from an alert iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name of filter of the alert or NULL if iteration is complete.
 */
char *
alert_iterator_filter_name (iterator_t* iterator)
{
  filter_t filter;

  if (iterator->done) return NULL;

  filter = alert_iterator_filter (iterator);
  if (filter)
    {
      if (sqlite3_column_int (iterator->stmt,
                              GET_ITERATOR_COLUMN_COUNT + 4)
          == LOCATION_TABLE)
        return filter_name (filter);
      return trash_filter_name (filter);
    }
  return NULL;
}

/**
 * @brief Return the location of an alert iterator filter.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return 0 in table, 1 in trash.
 */
int
alert_iterator_filter_trash (iterator_t* iterator)
{
  if (iterator->done) return 0;
  if (alert_iterator_filter (iterator)
      && (sqlite3_column_int (iterator->stmt,
                              GET_ITERATOR_COLUMN_COUNT + 4)
          == LOCATION_TRASH))
    return 1;
  return 0;
}

/**
 * @brief Initialise an alert data iterator.
 *
 * @param[in]  iterator   Iterator.
 * @param[in]  alert  Alert.
 * @param[in]  trash      Whether to iterate over trashcan alert data.
 * @param[in]  table      Type of data: "condition", "event" or "method",
 *                        corresponds to substring of the table to select
 *                        from.
 */
void
init_alert_data_iterator (iterator_t *iterator, alert_t alert,
                              int trash, const char *table)
{
  init_iterator (iterator,
                 "SELECT name, data FROM alert_%s_data%s"
                 " WHERE alert = %llu;",
                 table,
                 trash ? "_trash" : "",
                 alert);
}

/**
 * @brief Return the name from an alert data iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name of the alert data or NULL if iteration is complete.
 */
const char*
alert_data_iterator_name (iterator_t* iterator)
{
  const char *ret;
  if (iterator->done) return NULL;
  ret = (const char*) sqlite3_column_text (iterator->stmt, 0);
  return ret;
}

/**
 * @brief Return the data from an alert data iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 *
 * @return Data of the alert data or NULL if iteration is complete.
 */
const char*
alert_data_iterator_data (iterator_t* iterator)
{
  const char *ret;
  if (iterator->done) return NULL;
  ret = (const char*) sqlite3_column_text (iterator->stmt, 1);
  return ret;
}

/**
 * @brief Return data associated with an alert.
 *
 * @param[in]  alert  Alert.
 * @param[in]  type       Type of data: "condition", "event" or "method".
 * @param[in]  name       Name of the data.
 *
 * @return Freshly allocated data if it exists, else NULL.
 */
char *
alert_data (alert_t alert, const char *type, const char *name)
{
  gchar *quoted_name;
  char *data;

  assert (strcmp (type, "condition") == 0
          || strcmp (type, "event") == 0
          || strcmp (type, "method") == 0);

  quoted_name = sql_quote (name);
  data = sql_string (0, 0,
                     "SELECT data FROM alert_%s_data"
                     " WHERE alert = %llu AND name = '%s';",
                     type,
                     alert,
                     quoted_name);
  g_free (quoted_name);
  return data;
}

/*
 * @brief Initialise a task alert iterator.
 *
 * @param[in]  iterator  Iterator.
 * @param[in]  task      Task.
 * @param[in]  event     Event.
 */
void
init_task_alert_iterator (iterator_t* iterator, task_t task, event_t event)
{
  assert (current_credentials.uuid);

  if (event)
    init_iterator (iterator,
                   "SELECT alerts.ROWID, alerts.uuid, alerts.name"
                   " FROM alerts, task_alerts"
                   " WHERE task_alerts.task = %llu AND event = %i"
                   " AND task_alerts.alert = alerts.ROWID"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT ROWID FROM users WHERE users.uuid = '%s')));",
                   task,
                   event,
                   current_credentials.uuid);
  else
    init_iterator (iterator,
                   "SELECT alerts.ROWID, alerts.uuid, alerts.name"
                   " FROM alerts, task_alerts"
                   " WHERE task_alerts.task = %llu"
                   " AND task_alerts.alert = alerts.ROWID"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT ROWID FROM users WHERE users.uuid = '%s')));",
                   task,
                   current_credentials.uuid);
}

/**
 * @brief Get the alert from a task alert iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return alert.
 */
alert_t
task_alert_iterator_alert (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (task_t) sqlite3_column_int64 (iterator->stmt, 0);
}

/**
 * @brief Get the UUID from a task alert iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return UUID, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (task_alert_iterator_uuid, 1);

/**
 * @brief Get the name from a task alert iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (task_alert_iterator_name, 2);

/**
 * @brief Send an email.
 *
 * @param[in]  to_address    Address to send to.
 * @param[in]  from_address  Address to send to.
 * @param[in]  subject       Subject of email.
 * @param[in]  body          Body of email.
 * @param[in]  attachment    Attachment in line broken base64, or NULL.
 * @param[in]  attachment_type  Attachment MIME type, or NULL.
 * @param[in]  attachment_extension  Attachment file extension, or NULL.
 *
 * @return 0 success, -1 error.
 */
static int
email (const char *to_address, const char *from_address, const char *subject,
       const char *body, const gchar *attachment, const char *attachment_type,
       const char *attachment_extension)
{
  int ret, content_fd, to_fd;
  gchar *command;
  GError *error = NULL;
  char content_file_name[] = "/tmp/openvasmd-content-XXXXXX";
  char to_file_name[] = "/tmp/openvasmd-to-XXXXXX";
  FILE *content_file;

  content_fd = mkstemp (content_file_name);
  if (content_fd == -1)
    {
      g_warning ("%s: mkstemp: %s\n", __FUNCTION__, strerror (errno));
      return -1;
    }

  tracef ("   EMAIL to %s from %s subject: %s, body: %s",
          to_address, from_address, subject, body);

  content_file = fdopen (content_fd, "w");
  if (content_file == NULL)
    {
      g_warning ("%s: %s", __FUNCTION__, strerror (errno));
      close (content_fd);
      return -1;
    }

  if (fprintf (content_file,
               "To: %s\n"
               "From: %s\n"
               "Subject: %s\n"
               "%s%s%s"
               "\n"
               "%s"
               "%s",
               to_address,
               from_address ? from_address
                            : "automated@openvas.org",
               subject,
               (attachment
                 ? "MIME-Version: 1.0\n"
                   "Content-Type: multipart/mixed;"
                   " boundary=\""
                 : ""),
               /* @todo Future callers may give email containing this string. */
               (attachment ? "=-=-=-=-=" : ""),
               (attachment ? "\"\n" : ""),
               (attachment ? "--=-=-=-=-=\n"
                             "Content-Type: text/plain; charset=utf-8\n"
                             "Content-Transfer-Encoding: 8bit\n"
                             "Content-Disposition: inline\n"
                             "\n"
                           : ""),
               body)
      < 0)
    {
      g_warning ("%s: output error", __FUNCTION__);
      fclose (content_file);
      return -1;
    }

  if (attachment)
    {
      int len;

      if (fprintf (content_file,
                   "--=-=-=-=-=\n"
                   "Content-Type: %s\n"
                   "Content-Disposition: attachment;"
                   " filename=\"openvas-report.%s\"\n"
                   "Content-Transfer-Encoding: base64\n"
                   "Content-Description: OpenVAS report\n\n",
                   attachment_type,
                   attachment_extension)
          < 0)
        {
          g_warning ("%s: output error", __FUNCTION__);
          fclose (content_file);
          return -1;
        }

      len = strlen (attachment);
      while (len)
        if (len > 72)
          {
            if (fprintf (content_file,
                         "%.*s\n",
                         72,
                         attachment)
                < 0)
              {
                g_warning ("%s: output error", __FUNCTION__);
                fclose (content_file);
                return -1;
              }
            attachment += 72;
            len -= 72;
          }
        else
          {
            if (fprintf (content_file,
                         "%s\n",
                         attachment)
                < 0)
              {
                g_warning ("%s: output error", __FUNCTION__);
                fclose (content_file);
                return -1;
              }
            break;
          }

      if (fprintf (content_file,
                   "--=-=-=-=-=--\n")
          < 0)
        {
          g_warning ("%s: output error", __FUNCTION__);
          fclose (content_file);
          return -1;
        }
    }

  while (fflush (content_file))
    if (errno == EINTR)
      continue;
    else
      {
        g_warning ("%s", strerror (errno));
        fclose (content_file);
        return -1;
      }

  to_fd = mkstemp (to_file_name);
  if (to_fd == -1)
    {
      g_warning ("%s: mkstemp: %s\n", __FUNCTION__, strerror (errno));
      fclose (content_file);
      return -1;
    }

  g_file_set_contents (to_file_name, to_address, strlen (to_address), &error);
  if (error)
    {
      g_warning ("%s", error->message);
      g_error_free (error);
      fclose (content_file);
      close (to_fd);
      return -1;
    }

  command = g_strdup_printf ("xargs -a %s -I XXX"
                             " /usr/sbin/sendmail XXX < %s"
                             " > /dev/null 2>&1",
                             to_file_name,
                             content_file_name);

  tracef ("   command: %s\n", command);

  if (ret = system (command),
      /** @todo ret is always -1. */
      0 && ((ret) == -1
            || WEXITSTATUS (ret)))
    {
      g_warning ("%s: system failed with ret %i, %i, %s\n",
                 __FUNCTION__,
                 ret,
                 WEXITSTATUS (ret),
                 command);
      g_free (command);
      fclose (content_file);
      close (to_fd);
      unlink (content_file_name);
      unlink (to_file_name);
      return -1;
    }
  g_free (command);
  fclose (content_file);
  close (to_fd);
  unlink (content_file_name);
  unlink (to_file_name);
  return 0;
}

/**
 * @brief GET an HTTP resource.
 *
 * @param[in]  url  URL.
 *
 * @return 0 success, -1 error.
 */
static int
http_get (const char *url)
{
  int ret;
  gchar *standard_out = NULL;
  gchar *standard_err = NULL;
  gint exit_status;
  gchar **cmd;

  tracef ("   HTTP_GET %s", url);

  cmd = (gchar **) g_malloc (5 * sizeof (gchar *));
  cmd[0] = g_strdup ("/usr/bin/wget");
  cmd[1] = g_strdup ("-O");
  cmd[2] = g_strdup ("-");
  cmd[3] = g_strdup (url);
  cmd[4] = NULL;
  g_debug ("%s: Spawning in /tmp/: %s %s %s %s\n",
           __FUNCTION__, cmd[0], cmd[1], cmd[2], cmd[3]);
  if ((g_spawn_sync ("/tmp/",
                     cmd,
                     NULL,                  /* Environment. */
                     G_SPAWN_SEARCH_PATH,
                     NULL,                  /* Setup function. */
                     NULL,
                     &standard_out,
                     &standard_err,
                     &exit_status,
                     NULL)
       == FALSE)
      || (WIFEXITED (exit_status) == 0)
      || WEXITSTATUS (exit_status))
    {
      g_debug ("%s: wget failed: %d (WIF %i, WEX %i)",
               __FUNCTION__,
               exit_status,
               WIFEXITED (exit_status),
               WEXITSTATUS (exit_status));
      g_debug ("%s: stdout: %s\n", __FUNCTION__, standard_out);
      g_debug ("%s: stderr: %s\n", __FUNCTION__, standard_err);
      ret = -1;
    }
  else
    {
      if (strlen (standard_out) > 80)
        standard_out[80] = '\0';
      g_debug ("   HTTP_GET %s: %s", url, standard_out);
      ret = 0;
    }

  g_free (cmd[0]);
  g_free (cmd[1]);
  g_free (cmd[2]);
  g_free (cmd[3]);
  g_free (cmd[4]);
  g_free (cmd);
  g_free (standard_out);
  g_free (standard_err);
  return ret;
}

/**
 * @brief Send a report to a Sourcefire Defense Center.
 *
 * @param[in]  ip         IP of center.
 * @param[in]  port       Port of center.
 * @param[in]  pkcs12_64  PKCS12 content in base64.
 * @param[in]  report     Report in "Sourcefire" format.
 *
 * @return 0 success, -1 error.
 */
static int
send_to_sourcefire (const char *ip, const char *port, const char *pkcs12_64,
                    const char *report)
{
  gchar *script, *script_dir;
  gchar *report_file, *pkcs12_file, *pkcs12;
  gchar *clean_ip, *clean_port;
  char report_dir[] = "/tmp/openvasmd_escalate_XXXXXX";
  GError *error;
  gsize pkcs12_len;

  if ((report == NULL) || (ip == NULL) || (port == NULL))
    return -1;

  tracef ("send to sourcefire: %s:%s", ip, port);
  tracef ("report: %s", report);

  /* Setup files. */

  if (mkdtemp (report_dir) == NULL)
    {
      g_warning ("%s: mkdtemp failed\n", __FUNCTION__);
      return -1;
    }

  report_file = g_strdup_printf ("%s/report.csv", report_dir);

  error = NULL;
  g_file_set_contents (report_file, report, strlen (report), &error);
  if (error)
    {
      g_warning ("%s", error->message);
      g_error_free (error);
      g_free (report_file);
      return -1;
    }

  pkcs12_file = g_strdup_printf ("%s/pkcs12", report_dir);

  if (strlen (pkcs12_64))
    pkcs12 = (gchar*) g_base64_decode (pkcs12_64, &pkcs12_len);
  else
    {
      pkcs12 = g_strdup ("");
      pkcs12_len = 0;
    }

  error = NULL;
  g_file_set_contents (pkcs12_file, pkcs12, pkcs12_len, &error);
  if (error)
    {
      g_warning ("%s", error->message);
      g_error_free (error);
      g_free (report_file);
      g_free (pkcs12_file);
      return -1;
    }

  /* Setup file names. */

  script_dir = g_build_filename (OPENVAS_DATA_DIR,
                                 "openvasmd",
                                 "global_alert_methods",
                                 "cd1f5a34-6bdc-11e0-9827-002264764cea",
                                 NULL);

  script = g_build_filename (script_dir, "alert", NULL);

  if (!g_file_test (script, G_FILE_TEST_EXISTS))
    {
      g_free (report_file);
      g_free (pkcs12_file);
      g_free (script);
      g_free (script_dir);
      return -1;
    }

  {
    gchar *command;
    char *previous_dir;
    int ret;

    /* Change into the script directory. */

    /** @todo NULL arg is glibc extension. */
    previous_dir = getcwd (NULL, 0);
    if (previous_dir == NULL)
      {
        g_warning ("%s: Failed to getcwd: %s\n",
                   __FUNCTION__,
                   strerror (errno));
        g_free (report_file);
        g_free (pkcs12_file);
        g_free (previous_dir);
        g_free (script);
        g_free (script_dir);
        return -1;
      }

    if (chdir (script_dir))
      {
        g_warning ("%s: Failed to chdir: %s\n",
                   __FUNCTION__,
                   strerror (errno));
        g_free (report_file);
        g_free (pkcs12_file);
        g_free (previous_dir);
        g_free (script);
        g_free (script_dir);
        return -1;
      }
    g_free (script_dir);

    /* Call the script. */

    clean_ip = g_shell_quote (ip);
    clean_port = g_shell_quote (port);

    command = g_strdup_printf ("/bin/sh %s %s %s %s %s > /dev/null"
                               " 2> /dev/null",
                               script,
                               clean_ip,
                               clean_port,
                               pkcs12_file,
                               report_file);
    g_free (script);
    g_free (clean_ip);
    g_free (clean_port);

    g_debug ("   command: %s\n", command);

    if (getuid () == 0)
      {
        pid_t pid;
        struct passwd *nobody;

        /* Run the command with lower privileges in a fork. */

        nobody = getpwnam ("nobody");
        if ((nobody == NULL)
            || chown (report_dir, nobody->pw_uid, nobody->pw_gid)
            || chown (report_file, nobody->pw_uid, nobody->pw_gid)
            || chown (pkcs12_file, nobody->pw_uid, nobody->pw_gid))
          {
            g_warning ("%s: Failed to set permissions for user nobody: %s\n",
                       __FUNCTION__,
                       strerror (errno));
            g_free (report_file);
            g_free (pkcs12_file);
            g_free (previous_dir);
            return -1;
          }
        g_free (report_file);
        g_free (pkcs12_file);

        pid = fork ();
        switch (pid)
          {
          case 0:
              {
                /* Child.  Drop privileges, run command, exit. */
                cleanup_manage_process (FALSE);

                if (setgid (nobody->pw_gid))
                  {
                    g_warning ("%s (child): setgid: %s\n",
                               __FUNCTION__,
                               strerror (errno));
                    exit (EXIT_FAILURE);
                  }
                if (setuid (nobody->pw_uid))
                  {
                    g_warning ("%s (child): setuid: %s\n",
                               __FUNCTION__,
                               strerror (errno));
                    exit (EXIT_FAILURE);
                  }

                /* RATS: ignore, command is defined above. */
                if (ret = system (command),
                    /** @todo ret is always -1. */
                    0 && ((ret) == -1
                          || WEXITSTATUS (ret)))
                  {
                    g_warning ("%s (child):"
                               " system failed with ret %i, %i, %s\n",
                               __FUNCTION__,
                               ret,
                               WEXITSTATUS (ret),
                               command);
                    exit (EXIT_FAILURE);
                  }

                exit (EXIT_SUCCESS);
                break;
              }

          case -1:
            /* Parent when error. */

            g_warning ("%s: Failed to fork: %s\n",
                       __FUNCTION__,
                       strerror (errno));
            if (chdir (previous_dir))
              g_warning ("%s: and chdir failed\n",
                         __FUNCTION__);
            g_free (previous_dir);
            g_free (command);
            return -1;
            break;

          default:
              {
                int status;

                /* Parent on success.  Wait for child, and check result. */

                g_free (command);

                while (waitpid (pid, &status, 0) < 0)
                  {
                    if (errno == ECHILD)
                      {
                        g_warning ("%s: Failed to get child exit status",
                                   __FUNCTION__);
                        if (chdir (previous_dir))
                          g_warning ("%s: and chdir failed\n",
                                     __FUNCTION__);
                        g_free (previous_dir);
                        return -1;
                      }
                    if (errno == EINTR)
                      continue;
                    g_warning ("%s: wait: %s",
                               __FUNCTION__,
                               strerror (errno));
                    if (chdir (previous_dir))
                      g_warning ("%s: and chdir failed\n",
                                 __FUNCTION__);
                    g_free (previous_dir);
                    return -1;
                  }
                if (WIFEXITED (status))
                  switch (WEXITSTATUS (status))
                    {
                    case EXIT_SUCCESS:
                      break;
                    case EXIT_FAILURE:
                    default:
                      g_warning ("%s: child failed, %s\n",
                                 __FUNCTION__,
                                 command);
                      if (chdir (previous_dir))
                        g_warning ("%s: and chdir failed\n",
                                   __FUNCTION__);
                      g_free (previous_dir);
                      return -1;
                    }
                else
                  {
                    g_warning ("%s: child failed, %s\n",
                               __FUNCTION__,
                               command);
                    if (chdir (previous_dir))
                      g_warning ("%s: and chdir failed\n",
                                 __FUNCTION__);
                    g_free (previous_dir);
                    return -1;
                  }

                /* Child succeeded, continue to process result. */

                break;
              }
          }
      }
    else
      {
        /* Just run the command as the current user. */
        g_free (report_file);
        g_free (pkcs12_file);

        /* RATS: ignore, command is defined above. */
        if (ret = system (command),
            /** @todo ret is always -1. */
            0 && ((ret) == -1
                  || WEXITSTATUS (ret)))
          {
            g_warning ("%s: system failed with ret %i, %i, %s\n",
                       __FUNCTION__,
                       ret,
                       WEXITSTATUS (ret),
                       command);
            if (chdir (previous_dir))
              g_warning ("%s: and chdir failed\n",
                         __FUNCTION__);
            g_free (previous_dir);
            g_free (command);
            return -1;
          }

        g_free (command);
      }

    /* Change back to the previous directory. */

    if (chdir (previous_dir))
      {
        g_warning ("%s: Failed to chdir back: %s\n",
                   __FUNCTION__,
                   strerror (errno));
        g_free (previous_dir);
        return -1;
      }
    g_free (previous_dir);

    /* Remove the directory. */

    openvas_file_remove_recurse (report_dir);

    return 0;
  }
}

/**
 * @brief Send a report to a verinice.PRO server.
 *
 * @param[in]  url          URL of the server.
 * @param[in]  username     Username for server access.
 * @param[in]  password     Password for server access.
 * @param[in]  archive      Verinice archive that should be sent.
 * @param[in]  archive_size Size of the verinice archive
 *
 * @return 0 success, -1 error.
 */
static int
send_to_verinice (const char *url, const char *username, const char *password,
                  const char *archive, int archive_size)
{
  gchar *script, *script_dir;
  gchar *archive_file;
  gchar *clean_url, *clean_username, *clean_password;
  char archive_dir[] = "/tmp/openvasmd_alert_XXXXXX";
  GError *error;

  if ((archive == NULL) || (url == NULL))
    return -1;

  tracef ("send to verinice: %s", url);
  tracef ("archive: %s", archive);

  /* Setup files. */

  if (mkdtemp (archive_dir) == NULL)
    {
      g_warning ("%s: mkdtemp failed\n", __FUNCTION__);
      return -1;
    }

  archive_file = g_strdup_printf ("%s/archive.vna", archive_dir);

  error = NULL;
  g_file_set_contents (archive_file, archive, archive_size, &error);
  if (error)
    {
      g_warning ("%s", error->message);
      g_error_free (error);
      g_free (archive_file);
      return -1;
    }

  /* Setup file names. */
  script_dir = g_build_filename (OPENVAS_DATA_DIR,
                                 "openvasmd",
                                 "global_alert_methods",
                                 "f9d97653-f89b-41af-9ba1-0f6ee00e9c1a",
                                 NULL);

  script = g_build_filename (script_dir, "alert", NULL);

  if (!g_file_test (script, G_FILE_TEST_EXISTS))
    {
      g_warning ("%s: Failed to find alert script: %s\n",
           __FUNCTION__,
           script);
      g_free (archive_file);
      g_free (script);
      g_free (script_dir);
      return -1;
    }

  {
    gchar *command;
    gchar *log_command; /* Command with password removed. */
    char *previous_dir;
    int ret;

    /* Change into the script directory. */

    /** @todo NULL arg is glibc extension. */
    previous_dir = getcwd (NULL, 0);
    if (previous_dir == NULL)
      {
        g_warning ("%s: Failed to getcwd: %s\n",
                   __FUNCTION__,
                   strerror (errno));
        g_free (archive_file);
        g_free (previous_dir);
        g_free (script);
        g_free (script_dir);
        return -1;
      }

    if (chdir (script_dir))
      {
        g_warning ("%s: Failed to chdir: %s\n",
                   __FUNCTION__,
                   strerror (errno));
        g_free (archive_file);
        g_free (previous_dir);
        g_free (script);
        g_free (script_dir);
        return -1;
      }
    g_free (script_dir);

    /* Call the script. */

    clean_url = g_shell_quote (url);
    clean_username = g_shell_quote (username);
    clean_password = g_shell_quote (password);

    command = g_strdup_printf ("/bin/sh %s %s %s %s %s > /dev/null"
                               " 2> /dev/null",
                               script,
                               clean_url,
                               clean_username,
                               clean_password,
                               archive_file);
    log_command = g_strdup_printf ("/bin/sh %s %s %s ****** %s > /dev/null"
                                   " 2> /dev/null",
                                   script,
                                   clean_url,
                                   clean_username,
                                   archive_file);
    g_free (script);
    g_free (clean_url);
    g_free (clean_username);
    g_free (clean_password);

    g_debug ("   command: %s\n", log_command);

    if (getuid () == 0)
      {
        pid_t pid;
        struct passwd *nobody;

        /* Run the command with lower privileges in a fork. */

        nobody = getpwnam ("nobody");
        if ((nobody == NULL)
            || chown (archive_dir, nobody->pw_uid, nobody->pw_gid)
            || chown (archive_file, nobody->pw_uid, nobody->pw_gid))
          {
            g_warning ("%s: Failed to set permissions for user nobody: %s\n",
                       __FUNCTION__,
                       strerror (errno));
            g_free (previous_dir);
            g_free (archive_file);
            g_free (command);
            g_free (log_command);
            return -1;
          }
        g_free (archive_file);

        pid = fork ();
        switch (pid)
          {
          case 0:
              {
                /* Child.  Drop privileges, run command, exit. */

                cleanup_manage_process (FALSE);

                if (setgid (nobody->pw_gid))
                  {
                    g_warning ("%s (child): setgid: %s\n",
                               __FUNCTION__,
                               strerror (errno));
                    exit (EXIT_FAILURE);
                  }
                if (setuid (nobody->pw_uid))
                  {
                    g_warning ("%s (child): setuid: %s\n",
                               __FUNCTION__,
                               strerror (errno));
                    exit (EXIT_FAILURE);
                  }

                /* RATS: ignore, command is defined above. */
                if (ret = system (command),
                    /** @todo ret is always -1. */
                    0 && ((ret) == -1
                          || WEXITSTATUS (ret)))
                  {
                    g_warning ("%s (child):"
                               " system failed with ret %i, %i, %s\n",
                               __FUNCTION__,
                               ret,
                               WEXITSTATUS (ret),
                               log_command);
                    exit (EXIT_FAILURE);
                  }

                exit (EXIT_SUCCESS);
                break;
              }

          case -1:
            /* Parent when error. */

            g_warning ("%s: Failed to fork: %s\n",
                       __FUNCTION__,
                       strerror (errno));
            if (chdir (previous_dir))
              g_warning ("%s: and chdir failed\n",
                         __FUNCTION__);
            g_free (previous_dir);
            g_free (command);
            g_free (log_command);
            return -1;
            break;

          default:
              {
                int status;

                /* Parent on success.  Wait for child, and check result. */

                while (waitpid (pid, &status, 0) < 0)
                  {
                    if (errno == ECHILD)
                      {
                        g_warning ("%s: Failed to get child exit status",
                                   __FUNCTION__);
                        if (chdir (previous_dir))
                          g_warning ("%s: and chdir failed\n",
                                     __FUNCTION__);
                        g_free (previous_dir);
                        return -1;
                      }
                    if (errno == EINTR)
                      continue;
                    g_warning ("%s: wait: %s",
                               __FUNCTION__,
                               strerror (errno));
                    if (chdir (previous_dir))
                      g_warning ("%s: and chdir failed\n",
                                 __FUNCTION__);
                    g_free (previous_dir);
                    return -1;
                  }
                if (WIFEXITED (status))
                  switch (WEXITSTATUS (status))
                    {
                    case EXIT_SUCCESS:
                      break;
                    case EXIT_FAILURE:
                    default:
                      g_warning ("%s: child failed, %s\n",
                                 __FUNCTION__,
                                 log_command);
                      if (chdir (previous_dir))
                        g_warning ("%s: and chdir failed\n",
                                   __FUNCTION__);
                      g_free (previous_dir);
                      return -1;
                    }
                else
                  {
                    g_warning ("%s: child failed, %s\n",
                               __FUNCTION__,
                               log_command);
                    if (chdir (previous_dir))
                      g_warning ("%s: and chdir failed\n",
                                 __FUNCTION__);
                    g_free (previous_dir);
                    return -1;
                  }

                /* Child succeeded, continue to process result. */

                break;
              }
          }
      }
    else
      {
        /* Just run the command as the current user. */
        g_free (archive_file);

        /* RATS: ignore, command is defined above. */
        if (ret = system (command),
            /** @todo ret is always -1. */
            0 && ((ret) == -1
                  || WEXITSTATUS (ret)))
          {
            g_warning ("%s: system failed with ret %i, %i, %s\n",
                       __FUNCTION__,
                       ret,
                       WEXITSTATUS (ret),
                       log_command);
            if (chdir (previous_dir))
              g_warning ("%s: and chdir failed\n",
                         __FUNCTION__);
            g_free (previous_dir);
            g_free (command);
            return -1;
          }

      }

    g_free (command);
    g_free (log_command);

    /* Change back to the previous directory. */

    if (chdir (previous_dir))
      {
        g_warning ("%s: Failed to chdir back: %s\n",
                   __FUNCTION__,
                   strerror (errno));
        g_free (previous_dir);
        return -1;
      }
    g_free (previous_dir);

    /* Remove the directory. */

    openvas_file_remove_recurse (archive_dir);

    return 0;
  }
}

/**
 * @brief Format string for simple notice alert email.
 */
#define REPORT_NOTICE_FORMAT                                                  \
 "Task '%s': %s\n"                                                            \
 "\n"                                                                         \
 "After the event %s,\n"                                                      \
 "the following condition was met: %s\n"                                      \
 "\n"                                                                         \
 "This email escalation is configured to apply report format '%s'.\n"         \
 "Full details and other report formats are available on the scan engine.\n"  \
 "\n"                                                                         \
 "%s%s%s"                                                                     \
 "\n"                                                                         \
 "%.*s"                                                                       \
 "%s"                                                                         \
 "\n"                                                                         \
 "\n"                                                                         \
 "Note:\n"                                                                    \
 "This email was sent to you as a configured security scan escalation.\n"     \
 "Please contact your local system administrator if you think you\n"          \
 "should not have received it.\n"

/**
 * @brief Maximum number of bytes of the report included in email escalations.
 */
#define MAX_CONTENT_LENGTH 20000

/**
 * @brief Format string for attached report alert email.
 */
#define REPORT_ATTACH_FORMAT                                                  \
 "Task '%s': %s\n"                                                            \
 "\n"                                                                         \
 "After the event %s,\n"                                                      \
 "the following condition was met: %s\n"                                      \
 "\n"                                                                         \
 "This email escalation is configured to attach report format '%s'.\n"        \
 "Full details and other report formats are available on the scan engine.\n"  \
 "\n"                                                                         \
 "%s%s%s"                                                                     \
 "\n"                                                                         \
 "\n"                                                                         \
 "Note:\n"                                                                    \
 "This email was sent to you as a configured security scan escalation.\n"     \
 "Please contact your local system administrator if you think you\n"          \
 "should not have received it.\n"

/**
 * @brief Maximum number of bytes of the report included in email escalations.
 */
#define MAX_ATTACH_LENGTH 1048576

/**
 * @brief Format string for simple notice alert email.
 */
#define SIMPLE_NOTICE_FORMAT                                                  \
 "%s.\n"                                                                      \
 "\n"                                                                         \
 "After the event %s,\n"                                                      \
 "the following condition was met: %s\n"                                      \
 "\n"                                                                         \
 "This email escalation is not configured to provide more details.\n"         \
 "Full details are stored on the scan engine.\n"                              \
 "\n"                                                                         \
 "\n"                                                                         \
 "Note:\n"                                                                    \
 "This email was sent to you as a configured security scan escalation.\n"     \
 "Please contact your local system administrator if you think you\n"          \
 "should not have received it.\n"

/**
 * @brief Escalate an event.
 *
 * @param[in]  alert   Alert.
 * @param[in]  task        Task.
 * @param[in]  report      Report.  0 for most recent report.
 * @param[in]  event       Event.
 * @param[in]  event_data  Event data.
 * @param[in]  method      Method from alert.
 * @param[in]  condition   Condition from alert, which was met by event.
 * @param[in]  sort_order         Whether to sort ascending or descending.
 * @param[in]  sort_field         Field to sort on, or NULL for "type".
 * @param[in]  result_hosts_only  Whether to show only hosts with results.
 * @param[in]  min_cvss_base      Minimum CVSS base of included results.  All
 *                                results if NULL.
 * @param[in]  levels         String describing threat levels (message types)
 *                            to include in count (for example, "hmlgd" for
 *                            High, Medium, Low, loG and Debug).  All levels if
 *                            NULL.
 * @param[in]  apply_overrides    Whether to apply overrides.
 * @param[in]  search_phrase      Phrase that results must include.  All results
 *                                if NULL or "".
 * @param[in]  autofp             Whether to apply auto FP filter.
 * @param[in]  show_closed_cves   Whether to include the Closed CVEs host detail.
 * @param[in]  notes              Whether to include notes.
 * @param[in]  notes_details      If notes, Whether to include details.
 * @param[in]  overrides          Whether to include overrides.
 * @param[in]  overrides_details  If overrides, Whether to include details.
 * @param[in]  first_result       The result to start from.  The results are 0
 *                                indexed.
 * @param[in]  max_results        The maximum number of results returned.
 *
 * @return 0 success, -1 error.
 */
static int
escalate_2 (alert_t alert, task_t task, report_t report, event_t event,
            const void* event_data, alert_method_t method,
            alert_condition_t condition,
            /* Report filtering. */
            int sort_order, const char* sort_field,
            int result_hosts_only, const char *min_cvss_base,
            const char *levels, int apply_overrides,
            const char *search_phrase, int autofp, int show_closed_cves,
            int notes, int notes_details, int overrides, int overrides_details,
            int first_result, int max_results)
{
  g_log ("event alert", G_LOG_LEVEL_MESSAGE,
         "The alert for task %s was triggered "
         "(Event: %s, Condition: %s)",
         task_name (task),
         event_description (event, event_data, NULL),
         alert_condition_description (condition, alert));

  switch (method)
    {
      case ALERT_METHOD_EMAIL:
        {
          char *to_address;

          to_address = alert_data (alert, "method", "to_address");

          if (to_address)
            {
              int ret;
              gchar *body, *subject;
              char *name, *notice, *from_address, *filt_id;
              gchar *base64, *type, *extension;

              base64 = NULL;
              type = NULL;
              extension = NULL;

              from_address = alert_data (alert,
                                             "method",
                                             "from_address");

              notice = alert_data (alert, "method", "notice");
              filt_id = alert_filter_id (alert);
              name = task_name (task);
              if (notice && strcmp (notice, "0") == 0)
                {
                  gchar *event_desc, *condition_desc, *report_content;
                  char *format_uuid, *format_name;
                  report_format_t report_format = 0;
                  gsize content_length;

                  /* Message with inlined report. */

                  if (report == 0)
                    switch (sql_int64 (&report, 0, 0,
                                       "SELECT max (ROWID) FROM reports"
                                       " WHERE task = %llu",
                                       task))
                      {
                        case 0:
                          if (report)
                            break;
                        case 1:        /* Too few rows in result of query. */
                        case -1:
                          free (notice);
                          free (name);
                          free (to_address);
                          free (from_address);
                          return -1;
                          break;
                        default:       /* Programming error. */
                          assert (0);
                          return -1;
                      }

                  format_uuid = alert_data (alert,
                                            "method",
                                            "notice_report_format");
                  if (((format_uuid == NULL)
                       || find_report_format (format_uuid, &report_format)
                       || (report_format == 0))
                      /* Fallback to TXT. */
                      && (find_report_format
                           ("a3810a62-1f62-11e1-9219-406186ea4fc5",
                            &report_format)
                          || (report_format == 0)))
                    {
                      g_free (format_uuid);
                      free (filt_id);
                      free (notice);
                      free (name);
                      free (to_address);
                      free (from_address);
                      return -1;
                    }
                  g_free (format_uuid);

                  event_desc = event_description (event, event_data, NULL);
                  report_content = manage_report (report, report_format,
                                                  filt_id,
                                                  sort_order, sort_field,
                                                  result_hosts_only,
                                                  min_cvss_base, levels,
                                                  apply_overrides,
                                                  search_phrase, autofp,
                                                  show_closed_cves, notes,
                                                  notes_details, overrides,
                                                  overrides_details,
                                                  first_result, max_results,
                                                  NULL, /* Type. */
                                                  &content_length,
                                                  NULL,    /* Extension. */
                                                  NULL);   /* Content type. */
                  if (report_content == NULL)
                    {
                      free (event_desc);
                      free (filt_id);
                      free (notice);
                      free (name);
                      free (to_address);
                      free (from_address);
                      return -1;
                    }
                  format_name = report_format_name (report_format);
                  condition_desc = alert_condition_description (condition,
                                                                alert);
                  subject = g_strdup_printf ("[OpenVAS-Manager] Task '%s': %s",
                                             name ? name : "Internal Error",
                                             event_desc);
                  body = g_strdup_printf (REPORT_NOTICE_FORMAT,
                                          name,
                                          event_desc,
                                          event_desc,
                                          condition_desc,
                                          format_name,
                                          ((content_length > MAX_CONTENT_LENGTH)
                                            ? "Note: This report exceeds the"
                                              " maximum length of "
                                            : ""),
                                          ((content_length > MAX_CONTENT_LENGTH)
                                            ? G_STRINGIFY (MAX_CONTENT_LENGTH)
                                            : ""),
                                          ((content_length > MAX_CONTENT_LENGTH)
                                            ? " characters and thus\n"
                                              "was truncated.\n"
                                            : ""),
                                          /* Cast for 64 bit.  Safe because
                                           * MAX_CONTENT_LENGTH is small. */
                                          (int) MIN (content_length,
                                                     MAX_CONTENT_LENGTH),
                                          report_content,
                                          ((content_length > MAX_CONTENT_LENGTH)
                                            ? "\n... (report truncated after"
                                              " "
                                              G_STRINGIFY (MAX_CONTENT_LENGTH)
                                              " characters)\n"
                                            : ""));
                  free (format_name);
                  g_free (report_content);
                  g_free (event_desc);
                  g_free (condition_desc);
                }
              else if (notice && strcmp (notice, "2") == 0)
                {
                  gchar *event_desc, *condition_desc, *report_content;
                  char *format_uuid, *format_name;
                  report_format_t report_format = 0;
                  gsize content_length;

                  /* Message with attached report. */

                  if (report == 0)
                    switch (sql_int64 (&report, 0, 0,
                                       "SELECT max (ROWID) FROM reports"
                                       " WHERE task = %llu",
                                       task))
                      {
                        case 0:
                          if (report)
                            break;
                        case 1:        /* Too few rows in result of query. */
                        case -1:
                          free (notice);
                          free (name);
                          free (to_address);
                          free (from_address);
                          return -1;
                          break;
                        default:       /* Programming error. */
                          assert (0);
                          return -1;
                      }

                  format_uuid = alert_data (alert,
                                            "method",
                                            "notice_attach_format");
                  if (((format_uuid == NULL)
                       || find_report_format (format_uuid, &report_format)
                       || (report_format == 0))
                      /* Fallback to TXT. */
                      && (find_report_format
                           ("19f6f1b3-7128-4433-888c-ccc764fe6ed5",
                            &report_format)
                          || (report_format == 0)))
                    {
                      g_free (format_uuid);
                      free (filt_id);
                      free (notice);
                      free (name);
                      free (to_address);
                      free (from_address);
                      return -1;
                    }
                  g_free (format_uuid);

                  event_desc = event_description (event, event_data, NULL);
                  report_content = manage_report (report, report_format,
                                                  filt_id,
                                                  sort_order, sort_field,
                                                  result_hosts_only,
                                                  min_cvss_base, levels,
                                                  apply_overrides,
                                                  search_phrase, autofp,
                                                  show_closed_cves, notes,
                                                  notes_details, overrides,
                                                  overrides_details,
                                                  first_result, max_results,
                                                  NULL, /* Type. */
                                                  &content_length,
                                                  &extension,
                                                  &type);
                  if (report_content == NULL)
                    {
                      g_free (event_desc);
                      free (filt_id);
                      free (notice);
                      free (name);
                      free (to_address);
                      free (from_address);
                      return -1;
                    }
                  format_name = report_format_name (report_format);
                  condition_desc = alert_condition_description (condition,
                                                                    alert);
                  subject = g_strdup_printf ("[OpenVAS-Manager] Task '%s': %s",
                                             name ? name : "Internal Error",
                                             event_desc);
                  if (content_length <= MAX_ATTACH_LENGTH)
                    base64 = g_base64_encode ((guchar*) report_content,
                                              content_length);
                  g_free (report_content);
                  body = g_strdup_printf (REPORT_ATTACH_FORMAT,
                                          name,
                                          event_desc,
                                          event_desc,
                                          condition_desc,
                                          format_name,
                                          (base64
                                            ? ""
                                            : "Note: The report exceeds the"
                                              " maximum attachment length of "),
                                          (base64
                                            ? ""
                                            : G_STRINGIFY (MAX_ATTACH_LENGTH)),
                                          (base64
                                            ? ""
                                            : " bytes.\n"));
                  free (format_name);
                  g_free (event_desc);
                  g_free (condition_desc);
                }
              else
                {
                  gchar *event_desc, *generic_desc, *condition_desc;

                  /* Simple notice message. */
                  event_desc = event_description (event, event_data, name);
                  generic_desc = event_description (event, event_data, NULL);
                  condition_desc = alert_condition_description (condition,
                                                                    alert);
                  subject = g_strdup_printf ("[OpenVAS-Manager] Task '%s':"
                                             " An event occurred",
                                             name);
                  body = g_strdup_printf (SIMPLE_NOTICE_FORMAT,
                                          event_desc,
                                          generic_desc,
                                          condition_desc);
                  g_free (event_desc);
                  g_free (generic_desc);
                  g_free (condition_desc);
                }
              free (filt_id);
              free (name);
              free (notice);
              ret = email (to_address, from_address, subject, body, base64,
                           type, extension);
              g_free (base64);
              free (to_address);
              free (from_address);
              g_free (subject);
              g_free (body);
              return ret;
            }
          return -1;
          break;
        }
      case ALERT_METHOD_HTTP_GET:
        {
          char *url;

          url = alert_data (alert, "method", "URL");

          if (url)
            {
              int ret, formatting;
              gchar *point, *end;
              GString *new_url;

              new_url = g_string_new ("");
              for (formatting = 0, point = url, end = (url + strlen (url));
                   point < end;
                   point++)
                if (formatting)
                  {
                    switch (*point)
                      {
                        case '$':
                          g_string_append_c (new_url, '$');
                          break;
                        case 'c':
                          {
                            gchar *condition_desc;
                            condition_desc = alert_condition_description
                                              (condition, alert);
                            g_string_append (new_url, condition_desc);
                            g_free (condition_desc);
                            break;
                          }
                        case 'e':
                          {
                            gchar *event_desc;
                            event_desc = event_description (event, event_data,
                                                            NULL);
                            g_string_append (new_url, event_desc);
                            g_free (event_desc);
                            break;
                          }
                        case 'n':
                          {
                            char *name = task_name (task);
                            g_string_append (new_url, name);
                            free (name);
                            break;
                          }
                        default:
                          g_string_append_c (new_url, '$');
                          g_string_append_c (new_url, *point);
                          break;
                      }
                    formatting = 0;
                  }
                else if (*point == '$')
                  formatting = 1;
                else
                  g_string_append_c (new_url, *point);

              ret = http_get (new_url->str);
              g_string_free (new_url, TRUE);
              g_free (url);
              return ret;
            }
          return -1;
          break;
        }
      case ALERT_METHOD_SOURCEFIRE:
        {
          char *ip, *port, *pkcs12, *filt_id;
          gchar *report_content;
          gsize content_length;
          report_format_t report_format;
          int ret;

          if (lookup_report_format ("Sourcefire", &report_format)
              || (report_format == 0))
            return -1;

          if (report == 0)
            switch (sql_int64 (&report, 0, 0,
                               "SELECT max (ROWID) FROM reports"
                               " WHERE task = %llu",
                               task))
              {
                case 0:
                  if (report)
                    break;
                case 1:        /* Too few rows in result of query. */
                case -1:
                  return -1;
                  break;
                default:       /* Programming error. */
                  assert (0);
                  return -1;
              }

          filt_id = alert_filter_id (alert);

          report_content = manage_report (report, report_format,
                                          filt_id,
                                          sort_order, sort_field,
                                          result_hosts_only,
                                          min_cvss_base, levels,
                                          apply_overrides,
                                          search_phrase, autofp,
                                          show_closed_cves, notes,
                                          notes_details, overrides,
                                          overrides_details,
                                          first_result, max_results,
                                          NULL, /* Type. */
                                          &content_length,
                                          NULL,    /* Extension. */
                                          NULL);   /* Content type. */
          if (report_content == NULL)
            return -1;

          ip = alert_data (alert, "method", "defense_center_ip");
          port = alert_data (alert, "method", "defense_center_port");
          if (port == NULL)
            port = g_strdup ("8307");
          pkcs12 = alert_data (alert, "method", "pkcs12");

          tracef ("  sourcefire   ip: %s", ip);
          tracef ("  sourcefire port: %s", port);
          tracef ("sourcefire pkcs12: %s", pkcs12);

          ret = send_to_sourcefire (ip, port, pkcs12, report_content);

          free (filt_id);
          free (ip);
          free (port);
          free (pkcs12);
          g_free (report_content);

          return ret;
          break;
        }
      case ALERT_METHOD_SYSLOG:
        {
          char *submethod;
          gchar *message, *event_desc, *level;

          event_desc = event_description (event, event_data, NULL);
          message = g_strdup_printf ("%s: %s", event_name (event), event_desc);
          g_free (event_desc);

          submethod = alert_data (alert, "method", "submethod");
          level = g_strdup_printf ("event %s", submethod);
          g_free (submethod);

          tracef ("  syslog level: %s", level);
          tracef ("syslog message: %s", message);

          g_log (level, G_LOG_LEVEL_MESSAGE, "%s", message);

          g_free (level);
          g_free (message);

          return 0;
          break;
        }
      case ALERT_METHOD_VERINICE:
        {
          char *url, *username, *password, *filt_id;
          gchar *report_content;
          gsize content_length;
          report_format_t report_format;
          int ret;

          if (lookup_report_format ("Verinice ISM", &report_format)
              || (report_format == 0))
            {
              g_warning ("Could not find verinice RFP");
              return -1;
            }

          if (report == 0)
            switch (sql_int64 (&report, 0, 0,
                               "SELECT max (ROWID) FROM reports"
                               " WHERE task = %llu",
                               task))
              {
                case 0:
                  if (report)
                    break;
                case 1:        /* Too few rows in result of query. */
                case -1:
                  return -1;
                  break;
                default:       /* Programming error. */
                  assert (0);
                  return -1;
              }

          filt_id = alert_filter_id (alert);

          report_content = manage_report (report, report_format,
                                          filt_id,
                                          sort_order, sort_field,
                                          result_hosts_only,
                                          min_cvss_base, levels,
                                          apply_overrides,
                                          search_phrase, autofp,
                                          show_closed_cves, notes,
                                          notes_details, overrides,
                                          overrides_details,
                                          first_result, max_results,
                                          NULL, /* Type. */
                                          &content_length,
                                          NULL,    /* Extension. */
                                          NULL);   /* Content type. */
          if (report_content == NULL)
            {
              g_warning ("Empty Report");
              return -1;
            }

          url = alert_data (alert, "method", "verinice_server_url");
          username = alert_data (alert, "method", "verinice_server_username");
          password = alert_data (alert, "method", "verinice_server_password");

          tracef ("    verinice  url: %s", url);
          tracef ("verinice username: %s", username);

          ret = send_to_verinice (url, username, password, report_content,
                                  content_length);

          free (filt_id);
          free (url);
          g_free (report_content);

          return ret;
          break;
        }
      case ALERT_METHOD_ERROR:
      default:
        break;
    }
  return -1;
}

/**
 * @brief Escalate an event with preset report filtering.
 *
 * @param[in]  alert   Alert.
 * @param[in]  task        Task.
 * @param[in]  event       Event.
 * @param[in]  event_data  Event data.
 * @param[in]  method      Method from alert.
 * @param[in]  condition   Condition from alert, which was met by event.
 *
 * @return 0 success, -1 error.
 */
static int
escalate_1 (alert_t alert, task_t task, event_t event,
            const void* event_data, alert_method_t method,
            alert_condition_t condition)
{
  return escalate_2 (alert, task, 0, event, event_data, method, condition,
                     1,       /* Ascending. */
                     NULL,    /* Sort field. */
                     0,       /* Result hosts only. */
                     NULL,    /* Min CVSS base. */
                     NULL,    /* Levels. */
                     1,       /* Apply overrides. */
                     NULL,    /* Search phrase. */
                     1,       /* Auto FP. */
                     0,       /* Show closed CVEs. */
                     1,       /* Notes. */
                     1,       /* Notes details. */
                     1,       /* Overrides. */
                     1,       /* Overrides details. */
                     0,       /* First results. */
                     /* Max results. */
                     (method == ALERT_METHOD_EMAIL ? 1000 : -1));
}

/**
 * @brief Escalate an alert with task and event data.
 *
 * @param[in]  alert   Alert.
 * @param[in]  task        Task.
 * @param[in]  event       Event.
 * @param[in]  event_data  Event data.
 *
 * @return 0 success, -1 error.
 */
int
manage_alert (alert_t alert, task_t task, event_t event,
              const void* event_data)
{
  alert_condition_t condition = alert_condition (alert);
  alert_method_t method = alert_method (alert);
  return escalate_1 (alert, task, event, event_data, method, condition);
}

/**
 * @brief Return whether an event applies to a task and an alert.
 *
 * @param[in]  event       Event.
 * @param[in]  event_data  Event data.
 * @param[in]  task        Task.
 * @param[in]  alert   Alert.
 *
 * @return 1 if event applies, else 0.
 */
static int
event_applies (event_t event, const void *event_data, task_t task,
               alert_t alert)
{
  switch (event)
    {
      case EVENT_TASK_RUN_STATUS_CHANGED:
        {
          int ret;
          char *alert_event_data;

          alert_event_data = alert_data (alert, "event", "status");
          if (alert_event_data == NULL)
            return 0;
          ret = (task_run_status (task) == (task_status_t) event_data)
                && (strcmp (alert_event_data,
                            run_status_name_internal ((task_status_t)
                                                      event_data))
                    == 0);
          free (alert_event_data);
          return ret;
          break;
        }
      default:
        return 0;
        break;
    }
}

/**
 * @brief Return whether the condition of an alert is met by a task.
 *
 * @param[in]  task       Task.
 * @param[in]  alert  Alert.
 * @param[in]  condition  Condition.
 *
 * @return 1 if met, else 0.
 */
static int
condition_met (task_t task, alert_t alert,
               alert_condition_t condition)
{
  switch (condition)
    {
      case ALERT_CONDITION_ALWAYS:
        return 1;
        break;
      case ALERT_CONDITION_THREAT_LEVEL_AT_LEAST:
        {
          char *condition_level;
          const char *report_level;

          /* True if the threat level of the last finished report is at
           * least the given level. */

          condition_level = alert_data (alert, "condition", "level");
          report_level = task_threat_level (task, 1);
          if (condition_level
              && report_level
              && (collate_threat (NULL,
                                  strlen (report_level),
                                  report_level,
                                  strlen (condition_level),
                                  condition_level)
                  > -1))
            {
              free (condition_level);
              return 1;
            }
          free (condition_level);
          break;
        }
      case ALERT_CONDITION_THREAT_LEVEL_CHANGED:
        {
          char *direction;
          const char *last_level, *second_last_level;

          /* True if the threat level of the last finished report changed
           * in the given direction with respect to the second last finished
           * report. */

          direction = alert_data (alert, "condition", "direction");
          last_level = task_threat_level (task, 1);
          second_last_level = task_previous_threat_level (task);
          if (direction
              && last_level
              && second_last_level)
            {
              int cmp = collate_threat (NULL,
                                        strlen (last_level),
                                        last_level,
                                        strlen (second_last_level),
                                        second_last_level);
              tracef ("cmp: %i\n", cmp);
              tracef ("direction: %s\n", direction);
              tracef ("last_level: %s\n", last_level);
              tracef ("second_last_level: %s\n", second_last_level);
              if (((strcasecmp (direction, "changed") == 0) && cmp)
                  || ((strcasecmp (direction, "increased") == 0) && (cmp > 0))
                  || ((strcasecmp (direction, "decreased") == 0) && (cmp < 0)))
                {
                  free (direction);
                  return 1;
                }
            }
          else if (direction
                   && last_level)
            {
              tracef ("direction: %s\n", direction);
              tracef ("last_level: %s\n", last_level);
              tracef ("second_last_level NULL\n");
              if ((strcasecmp (direction, "changed") == 0)
                  || (strcasecmp (direction, "increased") == 0))
                {
                  free (direction);
                  return 1;
                }
            }
          free (direction);
          break;
        }
      default:
        break;
    }
  return 0;
}

/**
 * @brief Produce an event.
 *
 * @param[in]  task        Task.
 * @param[in]  event       Event.
 * @param[in]  event_data  Event type specific details.
 */
static void
event (task_t task, event_t event, void* event_data)
{
  iterator_t alerts;
  tracef ("   EVENT %i on task %llu", event, task);
  init_task_alert_iterator (&alerts, task, event);
  while (next (&alerts))
    {
      alert_t alert = task_alert_iterator_alert (&alerts);
      if (event_applies (event, event_data, task, alert))
        {
          alert_condition_t condition;

          condition = alert_condition (alert);
          if (condition_met (task, alert, condition))
            escalate_1 (alert,
                        task,
                        event,
                        event_data,
                        alert_method (alert),
                        condition);
        }
    }
  cleanup_iterator (&alerts);
}

/**
 * @brief Initialise an alert task iterator.
 *
 * Iterate over all tasks that use the alert.
 *
 * @param[in]  iterator   Iterator.
 * @param[in]  alert  Alert.
 * @param[in]  ascending  Whether to sort ascending or descending.
 */
void
init_alert_task_iterator (iterator_t* iterator, alert_t alert,
                              int ascending)
{
  assert (alert);
  assert (current_credentials.uuid);

  init_iterator (iterator,
                 "SELECT tasks.name, tasks.uuid FROM tasks, task_alerts"
                 " WHERE tasks.ROWID = task_alerts.task"
                 " AND task_alerts.alert = %llu"
                 " AND hidden = 0"
                 " AND ((tasks.owner IS NULL) OR (tasks.owner ="
                 " (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                 " ORDER BY tasks.name %s;",
                 alert,
                 current_credentials.uuid,
                 ascending ? "ASC" : "DESC");
}

/**
 * @brief Return the name from an alert task iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name of the task or NULL if iteration is complete.
 */
const char*
alert_task_iterator_name (iterator_t* iterator)
{
  const char *ret;
  if (iterator->done) return NULL;
  ret = (const char*) sqlite3_column_text (iterator->stmt, 0);
  return ret;
}

/**
 * @brief Return the uuid from an alert task iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return UUID of the task or NULL if iteration is complete.
 */
const char*
alert_task_iterator_uuid (iterator_t* iterator)
{
  const char *ret;
  if (iterator->done) return NULL;
  ret = (const char*) sqlite3_column_text (iterator->stmt, 1);
  return ret;
}


/* Task functions. */

/**
 * @brief Append value to field of task.
 *
 * @param[in]  task   Task.
 * @param[in]  field  Field.
 * @param[in]  value  Value.
 */
static void
append_to_task_string (task_t task, const char* field, const char* value)
{
  char* current;
  gchar* quote;
  current = sql_string (0, 0,
                        "SELECT %s FROM tasks WHERE ROWID = %llu;",
                        field,
                        task);
  if (current)
    {
      gchar* new = g_strconcat ((const gchar*) current, value, NULL);
      free (current);
      quote = sql_nquote (new, strlen (new));
      g_free (new);
    }
  else
    quote = sql_nquote (value, strlen (value));
  sql ("UPDATE tasks SET %s = '%s', modification_time = now ()"
       " WHERE ROWID = %llu;",
       field,
       quote,
       task);
  g_free (quote);
}

/**
 * @brief Filter columns for task iterator.
 */
#define TASK_ITERATOR_FILTER_COLUMNS                   \
 { GET_ITERATOR_FILTER_COLUMNS, "status", "total", "first", "last", "threat", \
   "trend", NULL }

/**
 * @brief Task iterator columns.
 */
#define TASK_ITERATOR_COLUMNS(overrides)                   \
  GET_ITERATOR_COLUMNS ", run_status,"                     \
  " (SELECT count(*) FROM reports"                         \
  /* TODO 1 == TASK_STATUS_DONE */                         \
  "  WHERE task = tasks.ROWID AND scan_run_status = 1)"    \
  " AS total,"                                             \
  " (SELECT date FROM reports WHERE task = tasks.ROWID"    \
  /* TODO 1 == TASK_STATUS_DONE */                         \
  "  AND scan_run_status = 1"                              \
  "  ORDER BY date ASC LIMIT 1)"                           \
  " AS first,"                                             \
  " (SELECT ROWID FROM reports WHERE task = tasks.ROWID"   \
  /* TODO 1 == TASK_STATUS_DONE */                         \
  "  AND scan_run_status = 1"                              \
  "  ORDER BY date DESC LIMIT 1),"                         \
  " task_threat_level (ROWID, " overrides ") AS threat,"   \
  " task_trend (ROWID, " overrides ") AS trend,"           \
  " run_status_name (run_status) AS status,"               \
  " (SELECT date FROM reports WHERE task = tasks.ROWID"    \
  /* TODO 1 == TASK_STATUS_DONE */                         \
  "  AND scan_run_status = 1"                              \
  "  ORDER BY date DESC LIMIT 1)"                          \
  " AS last"

/**
 * @brief Task iterator columns for trash case.
 */
#define TASK_ITERATOR_TRASH_COLUMNS(overrides)             \
  GET_ITERATOR_COLUMNS ", run_status,"                     \
  " (SELECT count(*) FROM reports"                         \
  /* TODO 1 == TASK_STATUS_DONE */                         \
  "  WHERE task = tasks.ROWID AND scan_run_status = 1)"    \
  " AS total,"                                             \
  " (SELECT date FROM reports WHERE task = tasks.ROWID"    \
  /* TODO 1 == TASK_STATUS_DONE */                         \
  "  AND scan_run_status = 1"                              \
  "  ORDER BY date ASC LIMIT 1)"                           \
  " AS first,"                                             \
  " (SELECT ROWID FROM reports WHERE task = tasks.ROWID"   \
  /* TODO 1 == TASK_STATUS_DONE */                         \
  "  AND scan_run_status = 1"                              \
  "  ORDER BY date DESC LIMIT 1),"                         \
  " task_threat_level (ROWID, " overrides ") AS threat,"   \
  " task_trend (ROWID, " overrides ") AS trend,"           \
  " run_status_name (run_status) AS status,"               \
  " (SELECT date FROM reports WHERE task = tasks.ROWID"    \
  /* TODO 1 == TASK_STATUS_DONE */                         \
  "  AND scan_run_status = 1"                              \
  "  ORDER BY date DESC LIMIT 1)"                          \
  " AS last"

/**
 * @brief Initialise a task iterator, limited to current user's tasks.
 *
 * @param[in]  iterator    Task iterator.
 * @param[in]  task        Task to limit iteration to.  0 for all.
 * @param[in]  trash       Whether to iterate over trashcan tasks.
 */
void
init_user_task_iterator (iterator_t* iterator,
                         task_t task,
                         int trash)
{
  static const char *filter_columns[] = TASK_ITERATOR_FILTER_COLUMNS;
  get_data_t get;
  memset (&get, '\0', sizeof (get));
  get.trash = trash;
  init_user_get_iterator (iterator, "task", &get, TASK_ITERATOR_COLUMNS ("0"),
                          TASK_ITERATOR_TRASH_COLUMNS ("0"), filter_columns,
                          task, 0, 0,
                          trash ? " AND hidden = 2" : " AND hidden < 2");
}

/**
 * @brief Initialise a task iterator.
 *
 * If there is a current user select that user's tasks and any tasks that user
 * is observing (according to actions_string), otherwise select all tasks.
 *
 * @param[in]  iterator    Task iterator.
 * @param[in]  get         GET data.
 *
 * @return 0 success, 1 failed to find target, 2 failed to find filter,
 *         -1 error.
 */
int
init_task_iterator (iterator_t* iterator, const get_data_t *get)
{
  static const char *filter_columns[] = TASK_ITERATOR_FILTER_COLUMNS;
  char *filter;
  gchar *value;
  int overrides;

  if (get->filt_id && strcmp (get->filt_id, "0"))
    {
      filter = filter_term (get->filt_id);
      if (filter == NULL)
        return 2;
    }
  else
    filter = NULL;
  value = filter_term_value (filter ? filter : get->filter, "apply_overrides");
  free (filter);
  overrides = value && strcmp (value, "0");
  g_free (value);

  return init_get_iterator (iterator,
                            "task",
                            get,
                            /* Columns. */
                            overrides
                             ? TASK_ITERATOR_COLUMNS ("1")
                             : TASK_ITERATOR_COLUMNS ("0"),
                            /* Columns for trashcan. */
                            overrides
                             ? TASK_ITERATOR_TRASH_COLUMNS ("1")
                             : TASK_ITERATOR_TRASH_COLUMNS ("0"),
                            filter_columns,
                            NULL,
                            0,
                            NULL,
                            (get->id
                             && (strcmp (get->id, MANAGE_EXAMPLE_TASK_UUID)
                                 == 0))
                             ? " AND hidden = 1"
                             : (get->trash
                                 ? " AND hidden = 2"
                                 : " AND hidden = 0"),
                            current_credentials.uuid ? TRUE : FALSE);
}

/**
 * @brief Get the run status from a task iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Task run status.
 */
task_status_t
task_iterator_run_status (iterator_t* iterator)
{
  task_status_t ret;
  if (iterator->done) return TASK_STATUS_INTERNAL_ERROR;
  ret = (unsigned int) sqlite3_column_int (iterator->stmt,
                                           GET_ITERATOR_COLUMN_COUNT);
  return ret;
}

/**
 * @brief Return whether a task is in use by a task.
 *
 * @param[in]  task  Task.
 *
 * @return 0.
 */
int
task_in_use (task_t task)
{
  task_status_t status;
  status = task_run_status (task);
  return status == TASK_STATUS_DELETE_REQUESTED
         || status == TASK_STATUS_DELETE_WAITING
         || status == TASK_STATUS_DELETE_ULTIMATE_REQUESTED
         || status == TASK_STATUS_DELETE_ULTIMATE_WAITING
         || status == TASK_STATUS_PAUSE_REQUESTED
         || status == TASK_STATUS_PAUSE_WAITING
         || status == TASK_STATUS_PAUSED
         || status == TASK_STATUS_REQUESTED
         || status == TASK_STATUS_RESUME_REQUESTED
         || status == TASK_STATUS_RESUME_WAITING
         || status == TASK_STATUS_RUNNING
         || status == TASK_STATUS_STOP_REQUESTED_GIVEUP
         || status == TASK_STATUS_STOP_REQUESTED
         || status == TASK_STATUS_STOP_WAITING;
}

/**
 * @brief Return whether a trashcan task is referenced by a task.
 *
 * @param[in]  task  Task.
 *
 * @return 0.
 */
int
trash_task_in_use (task_t task)
{
  return task_in_use (task);
}

/**
 * @brief Return whether a task is writable.
 *
 * @param[in]  task  Task.
 *
 * @return 1 if writable, else 0.
 */
int
task_writable (task_t task)
{
  char *uuid;

  task_uuid (task, &uuid);
  if (user_has_access_uuid ("task", uuid, "w") == 0)
    {
      free (uuid);
      return 0;
    }
  free (uuid);

  return sql_int (0, 0,
                  "SELECT hidden = 0 FROM tasks"
                  " WHERE ROWID = %llu",
                  task);
}

/**
 * @brief Return whether a trashcan task is writable.
 *
 * @param[in]  task  Task.
 *
 * @return 1 if writable, else 0.
 */
int
trash_task_writable (task_t task)
{
  char *uuid;

  task_uuid (task, &uuid);
  if (user_has_access_uuid ("task", uuid, "w") == 0)
    {
      free (uuid);
      return 0;
    }
  free (uuid);

  return sql_int (0, 0,
                  "SELECT hidden = 2 FROM tasks"
                  " WHERE ROWID = %llu",
                  task);
}

/**
 * @brief Initialize the manage library for a process.
 *
 * Open the SQL database.
 *
 * @param[in]  update_nvt_cache  0 operate normally, -1 just update NVT cache,
 *                               -2 just rebuild NVT cache.
 * @param[in]  database          Location of manage database.
 */
void
init_manage_process (int update_nvt_cache, const gchar *database)
{
  gchar *mgr_dir;
  int ret;

  if (task_db)
    {
      if (update_nvt_cache == -2)
        {
          sql ("BEGIN EXCLUSIVE;");
          sql ("DELETE FROM nvts;");
          sql ("DELETE FROM nvt_preferences;");
          sql ("DELETE FROM main.meta WHERE name = 'nvts_checksum';");
        }
      return;
    }

  /* Ensure the mgr directory exists. */
  mgr_dir = g_build_filename (OPENVAS_STATE_DIR, "mgr", NULL);
  ret = g_mkdir_with_parents (mgr_dir, 0755 /* "rwxr-xr-x" */);
  g_free (mgr_dir);
  if (ret == -1)
    {
      g_warning ("%s: failed to create mgr directory: %s\n",
                 __FUNCTION__,
                 strerror (errno));
      abort ();
    }

  {
    struct stat state;
    int err;

    err = stat (database ? database : OPENVAS_STATE_DIR "/mgr/tasks.db",
                &state);
    if (err)
      switch (errno)
        {
          case ENOENT:
            break;
          default:
            g_warning ("%s: failed to stat database: %s\n",
                       __FUNCTION__,
                       strerror (errno));
            abort ();
        }
    else if (state.st_mode & (S_IXUSR | S_IRWXG | S_IRWXO))
      {
        g_warning ("%s: database permissions are too loose, repairing\n",
                   __FUNCTION__);
        if (chmod (database ? database : OPENVAS_STATE_DIR "/mgr/tasks.db",
                   S_IRUSR | S_IWUSR))
          {
            g_warning ("%s: chmod failed: %s\n",
                       __FUNCTION__,
                       strerror (errno));
            abort ();
          }
      }
  }

#ifndef S_SPLINT_S
  /* Open the database. */
  if (sqlite3_open (database ? database
                             : OPENVAS_STATE_DIR "/mgr/tasks.db",
                    &task_db))
    {
      g_warning ("%s: sqlite3_open failed: %s\n",
                 __FUNCTION__,
                 sqlite3_errmsg (task_db));
      abort ();
    }
#endif /* not S_SPLINT_S */

  if (update_nvt_cache)
    {
      if (update_nvt_cache == -2)
        {
          sql ("BEGIN EXCLUSIVE;");
          sql ("DELETE FROM nvts;");
          sql ("DELETE FROM nvt_preferences;");
          sql ("DELETE FROM main.meta WHERE name = 'nvts_checksum';");
        }
    }
  else
    {
      /* Attach the SCAP database. */

      if (access (OPENVAS_STATE_DIR "/scap-data/scap.db", R_OK))
        switch (errno)
          {
            case ENOENT:
              break;
            default:
              g_warning ("%s: failed to stat SCAP database: %s\n",
                         __FUNCTION__,
                         strerror (errno));
              break;
          }
      else
        sql ("ATTACH DATABASE '" OPENVAS_STATE_DIR "/scap-data/scap.db'"
             " AS scap;");

      /* Attach the CERT database. */

      if (access (OPENVAS_STATE_DIR "/cert-data/cert.db", R_OK))
        switch (errno)
          {
            case ENOENT:
              break;
            default:
              g_warning ("%s: failed to stat CERT database: %s\n",
                         __FUNCTION__,
                         strerror (errno));
              break;
          }
      else
        sql ("ATTACH DATABASE '" OPENVAS_STATE_DIR "/cert-data/cert.db'"
             " AS cert;");
    }

  /* Define functions for SQL. */

  if (sqlite3_create_collation (task_db,
                                "collate_message_type",
                                SQLITE_UTF8,
                                NULL,
                                collate_message_type)
      != SQLITE_OK)
    {
      g_warning ("%s: failed to create collate_message_type", __FUNCTION__);
      abort ();
    }

  if (sqlite3_create_collation (task_db,
                                "collate_threat",
                                SQLITE_UTF8,
                                NULL,
                                collate_threat)
      != SQLITE_OK)
    {
      g_warning ("%s: failed to create collate_threat", __FUNCTION__);
      abort ();
    }

  if (sqlite3_create_collation (task_db,
                                "collate_ip",
                                SQLITE_UTF8,
                                NULL,
                                collate_ip)
      != SQLITE_OK)
    {
      g_warning ("%s: failed to create collate_ip", __FUNCTION__);
      abort ();
    }

  if (sqlite3_create_function (task_db,
                               "make_uuid",
                               0,               /* Number of args. */
                               SQLITE_UTF8,
                               NULL,            /* Callback data. */
                               sql_make_uuid,
                               NULL,            /* xStep. */
                               NULL)            /* xFinal. */
      != SQLITE_OK)
    {
      g_warning ("%s: failed to create make_uuid", __FUNCTION__);
      abort ();
    }

  if (sqlite3_create_function (task_db,
                               "hosts_contains",
                               2,               /* Number of args. */
                               SQLITE_UTF8,
                               NULL,            /* Callback data. */
                               sql_hosts_contains,
                               NULL,            /* xStep. */
                               NULL)            /* xFinal. */
      != SQLITE_OK)
    {
      g_warning ("%s: failed to create host_contains", __FUNCTION__);
      abort ();
    }

  if (sqlite3_create_function (task_db,
                               "clean_hosts",
                               1,               /* Number of args. */
                               SQLITE_UTF8,
                               NULL,            /* Callback data. */
                               sql_clean_hosts,
                               NULL,            /* xStep. */
                               NULL)            /* xFinal. */
      != SQLITE_OK)
    {
      g_warning ("%s: failed to create clean_hosts", __FUNCTION__);
      abort ();
    }

  if (sqlite3_create_function (task_db,
                               "iso_time",
                               1,               /* Number of args. */
                               SQLITE_UTF8,
                               NULL,            /* Callback data. */
                               sql_iso_time,
                               NULL,            /* xStep. */
                               NULL)            /* xFinal. */
      != SQLITE_OK)
    {
      g_warning ("%s: failed to create iso_time", __FUNCTION__);
      abort ();
    }

  if (sqlite3_create_function (task_db,
                               "parse_time",
                               1,               /* Number of args. */
                               SQLITE_UTF8,
                               NULL,            /* Callback data. */
                               sql_parse_time,
                               NULL,            /* xStep. */
                               NULL)            /* xFinal. */
      != SQLITE_OK)
    {
      g_warning ("%s: failed to create parse_time", __FUNCTION__);
      abort ();
    }

  if (sqlite3_create_function (task_db,
                               "tag",
                               2,               /* Number of args. */
                               SQLITE_UTF8,
                               NULL,            /* Callback data. */
                               sql_tag,
                               NULL,            /* xStep. */
                               NULL)            /* xFinal. */
      != SQLITE_OK)
    {
      g_warning ("%s: failed to create tag", __FUNCTION__);
      abort ();
    }

  if (sqlite3_create_function (task_db,
                               "uniquify",
                               4,               /* Number of args. */
                               SQLITE_UTF8,
                               NULL,            /* Callback data. */
                               sql_uniquify,
                               NULL,            /* xStep. */
                               NULL)            /* xFinal. */
      != SQLITE_OK)
    {
      g_warning ("%s: failed to create uniquify", __FUNCTION__);
      abort ();
    }

  if (sqlite3_create_function (task_db,
                               "now",
                               0,               /* Number of args. */
                               SQLITE_UTF8,
                               NULL,            /* Callback data. */
                               sql_now,
                               NULL,            /* xStep. */
                               NULL)            /* xFinal. */
      != SQLITE_OK)
    {
      g_warning ("%s: failed to create now", __FUNCTION__);
      abort ();
    }

  if (sqlite3_create_function (task_db,
                               "max_hosts",
                               1,               /* Number of args. */
                               SQLITE_UTF8,
                               NULL,            /* Callback data. */
                               sql_max_hosts,
                               NULL,            /* xStep. */
                               NULL)            /* xFinal. */
      != SQLITE_OK)
    {
      g_warning ("%s: failed to create max_hosts", __FUNCTION__);
      abort ();
    }

  if (sqlite3_create_function (task_db,
                               "common_cve",
                               2,               /* Number of args. */
                               SQLITE_UTF8,
                               NULL,            /* Callback data. */
                               sql_common_cve,
                               NULL,            /* xStep. */
                               NULL)            /* xFinal. */
      != SQLITE_OK)
    {
      g_warning ("%s: failed to create common_cve", __FUNCTION__);
      abort ();
    }

  if (sqlite3_create_function (task_db,
                               "current_offset",
                               1,               /* Number of args. */
                               SQLITE_UTF8,
                               NULL,            /* Callback data. */
                               sql_current_offset,
                               NULL,            /* xStep. */
                               NULL)            /* xFinal. */
      != SQLITE_OK)
    {
      g_warning ("%s: failed to create current_offset", __FUNCTION__);
      abort ();
    }

  if (sqlite3_create_function (task_db,
                               "task_trend",
                               2,               /* Number of args. */
                               SQLITE_UTF8,
                               NULL,            /* Callback data. */
                               sql_task_trend,
                               NULL,            /* xStep. */
                               NULL)            /* xFinal. */
      != SQLITE_OK)
    {
      g_warning ("%s: failed to create task_trend", __FUNCTION__);
      abort ();
    }

  if (sqlite3_create_function (task_db,
                               "task_threat_level",
                               2,               /* Number of args. */
                               SQLITE_UTF8,
                               NULL,            /* Callback data. */
                               sql_threat_level,
                               NULL,            /* xStep. */
                               NULL)            /* xFinal. */
      != SQLITE_OK)
    {
      g_warning ("%s: failed to create task_threat_level", __FUNCTION__);
      abort ();
    }

  if (sqlite3_create_function (task_db,
                               "run_status_name",
                               1,               /* Number of args. */
                               SQLITE_UTF8,
                               NULL,            /* Callback data. */
                               sql_run_status_name,
                               NULL,            /* xStep. */
                               NULL)            /* xFinal. */
      != SQLITE_OK)
    {
      g_warning ("%s: failed to create run_status_name", __FUNCTION__);
      abort ();
    }
}

/**
 * @brief Reinitialize the manage library for a process.
 *
 * This is essentially needed after a fork, to not carry open databases around
 * (refer to sqlite3 documentation).
 */
void
reinit_manage_process ()
{
  cleanup_manage_process (FALSE);
  init_manage_process (0, task_db_name);
}

/**
 * @brief Setup config preferences for a config.
 *
 * @param[in]  config         The config.
 * @param[in]  safe_checks    safe_checks option: 1 for "yes", 0 for "no".
 * @param[in]  optimize_test  optimize_test option: 1 for "yes", 0 for "no".
 * @param[in]  port_range     port_range option: 1 for "yes", 0 for "no".
 */
static void
setup_full_config_prefs (config_t config, int safe_checks,
                         int optimize_test, int port_range)
{
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'max_hosts', '20');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'max_checks', '4');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'cgi_path', '/cgi-bin:/scripts');",
       config);
  if (port_range)
    sql ("INSERT into config_preferences (config, type, name, value)"
         " VALUES (%i, 'SERVER_PREFS', 'port_range', '1-65535');",
         config);
  else
    sql ("INSERT into config_preferences (config, type, name, value)"
         " VALUES (%i, 'SERVER_PREFS', 'port_range', 'default');",
         config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'auto_enable_dependencies', 'yes');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'silent_dependencies', 'yes');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'host_expansion', 'ip');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'reverse_lookup', 'no');",
       config);
  if (optimize_test)
    sql ("INSERT into config_preferences (config, type, name, value)"
         " VALUES (%i, 'SERVER_PREFS', 'optimize_test', 'yes');",
         config);
  else
    sql ("INSERT into config_preferences (config, type, name, value)"
         " VALUES (%i, 'SERVER_PREFS', 'optimize_test', 'no');",
         config);
  if (safe_checks)
    sql ("INSERT into config_preferences (config, type, name, value)"
         " VALUES (%i, 'SERVER_PREFS', 'safe_checks', 'yes');",
         config);
  else
    sql ("INSERT into config_preferences (config, type, name, value)"
         " VALUES (%i, 'SERVER_PREFS', 'safe_checks', 'no');",
         config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'use_mac_addr', 'no');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'unscanned_closed', 'yes');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'save_knowledge_base', 'yes');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'only_test_hosts_whose_kb_we_dont_have', 'no');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'only_test_hosts_whose_kb_we_have', 'no');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'kb_restore', 'no');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'kb_dont_replay_scanners', 'no');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'kb_dont_replay_info_gathering', 'no');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'kb_dont_replay_attacks', 'no');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'kb_dont_replay_denials', 'no');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'kb_max_age', '864000');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'log_whole_attack', 'no');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'checks_read_timeout', '5');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'network_scan', 'no');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'non_simult_ports', '139, 445');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'plugins_timeout', '320');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'slice_network_addresses', 'no');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'SERVER_PREFS', 'nasl_no_signature_check', 'yes');",
       config);

  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'PLUGINS_PREFS',"
       " 'Ping Host[checkbox]:Mark unrechable Hosts as dead (not scanning)',"
       " 'yes');",
       config);
  sql ("INSERT into config_preferences (config, type, name, value)"
       " VALUES (%i, 'PLUGINS_PREFS',"
       " 'Login configurations[checkbox]:NTLMSSP',"
       " 'yes');",
       config);
}

/**
 * @brief Update the memory cache of NVTs.
 */
static void
update_nvti_cache ()
{
  iterator_t nvts;

  nvtis_free (nvti_cache);

  nvti_cache = nvtis_new ();

  init_nvt_iterator (&nvts, (nvt_t) 0, (config_t) 0, NULL, NULL, 1, NULL);
  while (next (&nvts))
    {
      nvti_t *nvti = nvti_new ();
      nvti_set_oid (nvti, nvt_iterator_oid (&nvts));
      nvti_set_name (nvti, nvt_iterator_name (&nvts));
      nvti_set_family (nvti, nvt_iterator_family (&nvts));
      nvti_set_cvss_base (nvti, nvt_iterator_cvss_base (&nvts));
      nvti_set_cve (nvti, nvt_iterator_cve (&nvts));
      nvti_set_bid (nvti, nvt_iterator_bid (&nvts));
      nvti_set_xref (nvti, nvt_iterator_xref (&nvts));
      nvti_set_tag (nvti, nvt_iterator_tag (&nvts));
      nvtis_add (nvti_cache, nvti);
    }
  cleanup_iterator (&nvts);
}

/**
 * @brief Update the memory cache of NVTs, if this has been requested.
 */
void
manage_update_nvti_cache ()
{
  if (sql_int (0, 0,
               "SELECT value FROM main.meta"
               " WHERE name = 'update_nvti_cache';"))
    {
      update_nvti_cache ();
      sql ("UPDATE main.meta SET value = 0 WHERE name = 'update_nvti_cache';");
    }
}

/**
 * @brief Insert a port range.
 */
#define RANGE(type, start, end)                                  \
  sql ("INSERT INTO port_ranges"                                 \
       " (uuid, port_list, type, start, end, comment, exclude)"  \
       " VALUES"                                                 \
       " (make_uuid (), %llu, %i,"                               \
       "  '" G_STRINGIFY (start) "',"                            \
       "  '" G_STRINGIFY (end) "',"                              \
       "  '', 0)",                                               \
       list,                                                     \
       type)

/**
 * @brief Make port ranges.
 *
 * Caller must lock the db.
 *
 * @param[in]  list  Port list.
 */
static void
make_port_ranges_openvas_default (port_list_t list)
{
  RANGE (PORT_PROTOCOL_TCP, 1, 5);
  RANGE (PORT_PROTOCOL_TCP, 7, 7);
  RANGE (PORT_PROTOCOL_TCP, 9, 9);
  RANGE (PORT_PROTOCOL_TCP, 11, 11);
  RANGE (PORT_PROTOCOL_TCP, 13, 13);
  RANGE (PORT_PROTOCOL_TCP, 15, 15);
  RANGE (PORT_PROTOCOL_TCP, 17, 25);
  RANGE (PORT_PROTOCOL_TCP, 27, 27);
  RANGE (PORT_PROTOCOL_TCP, 29, 29);
  RANGE (PORT_PROTOCOL_TCP, 31, 31);
  RANGE (PORT_PROTOCOL_TCP, 33, 33);
  RANGE (PORT_PROTOCOL_TCP, 35, 35);
  RANGE (PORT_PROTOCOL_TCP, 37, 39);
  RANGE (PORT_PROTOCOL_TCP, 41, 59);
  RANGE (PORT_PROTOCOL_TCP, 61, 224);
  RANGE (PORT_PROTOCOL_TCP, 242, 248);
  RANGE (PORT_PROTOCOL_TCP, 256, 268);
  RANGE (PORT_PROTOCOL_TCP, 280, 287);
  RANGE (PORT_PROTOCOL_TCP, 308, 322);
  RANGE (PORT_PROTOCOL_TCP, 333, 333);
  RANGE (PORT_PROTOCOL_TCP, 344, 700);
  RANGE (PORT_PROTOCOL_TCP, 702, 702);
  RANGE (PORT_PROTOCOL_TCP, 704, 707);
  RANGE (PORT_PROTOCOL_TCP, 709, 711);
  RANGE (PORT_PROTOCOL_TCP, 721, 721);
  RANGE (PORT_PROTOCOL_TCP, 723, 723);
  RANGE (PORT_PROTOCOL_TCP, 729, 731);
  RANGE (PORT_PROTOCOL_TCP, 740, 742);
  RANGE (PORT_PROTOCOL_TCP, 744, 744);
  RANGE (PORT_PROTOCOL_TCP, 747, 754);
  RANGE (PORT_PROTOCOL_TCP, 758, 765);
  RANGE (PORT_PROTOCOL_TCP, 767, 767);
  RANGE (PORT_PROTOCOL_TCP, 769, 777);
  RANGE (PORT_PROTOCOL_TCP, 780, 783);
  RANGE (PORT_PROTOCOL_TCP, 786, 787);
  RANGE (PORT_PROTOCOL_TCP, 799, 801);
  RANGE (PORT_PROTOCOL_TCP, 808, 808);
  RANGE (PORT_PROTOCOL_TCP, 810, 810);
  RANGE (PORT_PROTOCOL_TCP, 828, 829);
  RANGE (PORT_PROTOCOL_TCP, 847, 848);
  RANGE (PORT_PROTOCOL_TCP, 860, 860);
  RANGE (PORT_PROTOCOL_TCP, 871, 871);
  RANGE (PORT_PROTOCOL_TCP, 873, 873);
  RANGE (PORT_PROTOCOL_TCP, 886, 888);
  RANGE (PORT_PROTOCOL_TCP, 898, 898);
  RANGE (PORT_PROTOCOL_TCP, 900, 904);
  RANGE (PORT_PROTOCOL_TCP, 911, 913);
  RANGE (PORT_PROTOCOL_TCP, 927, 927);
  RANGE (PORT_PROTOCOL_TCP, 950, 950);
  RANGE (PORT_PROTOCOL_TCP, 953, 953);
  RANGE (PORT_PROTOCOL_TCP, 975, 975);
  RANGE (PORT_PROTOCOL_TCP, 989, 1002);
  RANGE (PORT_PROTOCOL_TCP, 1005, 1005);
  RANGE (PORT_PROTOCOL_TCP, 1008, 1008);
  RANGE (PORT_PROTOCOL_TCP, 1010, 1010);
  RANGE (PORT_PROTOCOL_TCP, 1023, 1027);
  RANGE (PORT_PROTOCOL_TCP, 1029, 1036);
  RANGE (PORT_PROTOCOL_TCP, 1040, 1040);
  RANGE (PORT_PROTOCOL_TCP, 1042, 1042);
  RANGE (PORT_PROTOCOL_TCP, 1045, 1045);
  RANGE (PORT_PROTOCOL_TCP, 1047, 1112);
  RANGE (PORT_PROTOCOL_TCP, 1114, 1117);
  RANGE (PORT_PROTOCOL_TCP, 1119, 1120);
  RANGE (PORT_PROTOCOL_TCP, 1122, 1127);
  RANGE (PORT_PROTOCOL_TCP, 1139, 1139);
  RANGE (PORT_PROTOCOL_TCP, 1154, 1155);
  RANGE (PORT_PROTOCOL_TCP, 1161, 1162);
  RANGE (PORT_PROTOCOL_TCP, 1168, 1170);
  RANGE (PORT_PROTOCOL_TCP, 1178, 1178);
  RANGE (PORT_PROTOCOL_TCP, 1180, 1181);
  RANGE (PORT_PROTOCOL_TCP, 1183, 1188);
  RANGE (PORT_PROTOCOL_TCP, 1194, 1194);
  RANGE (PORT_PROTOCOL_TCP, 1199, 1231);
  RANGE (PORT_PROTOCOL_TCP, 1233, 1286);
  RANGE (PORT_PROTOCOL_TCP, 1288, 1774);
  RANGE (PORT_PROTOCOL_TCP, 1776, 2028);
  RANGE (PORT_PROTOCOL_TCP, 2030, 2030);
  RANGE (PORT_PROTOCOL_TCP, 2032, 2035);
  RANGE (PORT_PROTOCOL_TCP, 2037, 2038);
  RANGE (PORT_PROTOCOL_TCP, 2040, 2065);
  RANGE (PORT_PROTOCOL_TCP, 2067, 2083);
  RANGE (PORT_PROTOCOL_TCP, 2086, 2087);
  RANGE (PORT_PROTOCOL_TCP, 2089, 2152);
  RANGE (PORT_PROTOCOL_TCP, 2155, 2155);
  RANGE (PORT_PROTOCOL_TCP, 2159, 2167);
  RANGE (PORT_PROTOCOL_TCP, 2170, 2177);
  RANGE (PORT_PROTOCOL_TCP, 2180, 2181);
  RANGE (PORT_PROTOCOL_TCP, 2190, 2191);
  RANGE (PORT_PROTOCOL_TCP, 2199, 2202);
  RANGE (PORT_PROTOCOL_TCP, 2213, 2213);
  RANGE (PORT_PROTOCOL_TCP, 2220, 2223);
  RANGE (PORT_PROTOCOL_TCP, 2232, 2246);
  RANGE (PORT_PROTOCOL_TCP, 2248, 2255);
  RANGE (PORT_PROTOCOL_TCP, 2260, 2260);
  RANGE (PORT_PROTOCOL_TCP, 2273, 2273);
  RANGE (PORT_PROTOCOL_TCP, 2279, 2289);
  RANGE (PORT_PROTOCOL_TCP, 2294, 2311);
  RANGE (PORT_PROTOCOL_TCP, 2313, 2371);
  RANGE (PORT_PROTOCOL_TCP, 2381, 2425);
  RANGE (PORT_PROTOCOL_TCP, 2427, 2681);
  RANGE (PORT_PROTOCOL_TCP, 2683, 2824);
  RANGE (PORT_PROTOCOL_TCP, 2826, 2854);
  RANGE (PORT_PROTOCOL_TCP, 2856, 2924);
  RANGE (PORT_PROTOCOL_TCP, 2926, 3096);
  RANGE (PORT_PROTOCOL_TCP, 3098, 3299);
  RANGE (PORT_PROTOCOL_TCP, 3302, 3321);
  RANGE (PORT_PROTOCOL_TCP, 3326, 3366);
  RANGE (PORT_PROTOCOL_TCP, 3372, 3403);
  RANGE (PORT_PROTOCOL_TCP, 3405, 3545);
  RANGE (PORT_PROTOCOL_TCP, 3547, 3707);
  RANGE (PORT_PROTOCOL_TCP, 3709, 3765);
  RANGE (PORT_PROTOCOL_TCP, 3767, 3770);
  RANGE (PORT_PROTOCOL_TCP, 3772, 3800);
  RANGE (PORT_PROTOCOL_TCP, 3802, 3802);
  RANGE (PORT_PROTOCOL_TCP, 3845, 3871);
  RANGE (PORT_PROTOCOL_TCP, 3875, 3876);
  RANGE (PORT_PROTOCOL_TCP, 3885, 3885);
  RANGE (PORT_PROTOCOL_TCP, 3900, 3900);
  RANGE (PORT_PROTOCOL_TCP, 3928, 3929);
  RANGE (PORT_PROTOCOL_TCP, 3939, 3939);
  RANGE (PORT_PROTOCOL_TCP, 3959, 3959);
  RANGE (PORT_PROTOCOL_TCP, 3970, 3971);
  RANGE (PORT_PROTOCOL_TCP, 3984, 3987);
  RANGE (PORT_PROTOCOL_TCP, 3999, 4036);
  RANGE (PORT_PROTOCOL_TCP, 4040, 4042);
  RANGE (PORT_PROTOCOL_TCP, 4045, 4045);
  RANGE (PORT_PROTOCOL_TCP, 4080, 4080);
  RANGE (PORT_PROTOCOL_TCP, 4096, 4100);
  RANGE (PORT_PROTOCOL_TCP, 4111, 4111);
  RANGE (PORT_PROTOCOL_TCP, 4114, 4114);
  RANGE (PORT_PROTOCOL_TCP, 4132, 4134);
  RANGE (PORT_PROTOCOL_TCP, 4138, 4138);
  RANGE (PORT_PROTOCOL_TCP, 4141, 4145);
  RANGE (PORT_PROTOCOL_TCP, 4154, 4154);
  RANGE (PORT_PROTOCOL_TCP, 4160, 4160);
  RANGE (PORT_PROTOCOL_TCP, 4199, 4200);
  RANGE (PORT_PROTOCOL_TCP, 4242, 4242);
  RANGE (PORT_PROTOCOL_TCP, 4300, 4300);
  RANGE (PORT_PROTOCOL_TCP, 4321, 4321);
  RANGE (PORT_PROTOCOL_TCP, 4333, 4333);
  RANGE (PORT_PROTOCOL_TCP, 4343, 4351);
  RANGE (PORT_PROTOCOL_TCP, 4353, 4358);
  RANGE (PORT_PROTOCOL_TCP, 4369, 4369);
  RANGE (PORT_PROTOCOL_TCP, 4400, 4400);
  RANGE (PORT_PROTOCOL_TCP, 4442, 4457);
  RANGE (PORT_PROTOCOL_TCP, 4480, 4480);
  RANGE (PORT_PROTOCOL_TCP, 4500, 4500);
  RANGE (PORT_PROTOCOL_TCP, 4545, 4547);
  RANGE (PORT_PROTOCOL_TCP, 4555, 4555);
  RANGE (PORT_PROTOCOL_TCP, 4557, 4557);
  RANGE (PORT_PROTOCOL_TCP, 4559, 4559);
  RANGE (PORT_PROTOCOL_TCP, 4567, 4568);
  RANGE (PORT_PROTOCOL_TCP, 4600, 4601);
  RANGE (PORT_PROTOCOL_TCP, 4658, 4662);
  RANGE (PORT_PROTOCOL_TCP, 4672, 4672);
  RANGE (PORT_PROTOCOL_TCP, 4752, 4752);
  RANGE (PORT_PROTOCOL_TCP, 4800, 4802);
  RANGE (PORT_PROTOCOL_TCP, 4827, 4827);
  RANGE (PORT_PROTOCOL_TCP, 4837, 4839);
  RANGE (PORT_PROTOCOL_TCP, 4848, 4849);
  RANGE (PORT_PROTOCOL_TCP, 4868, 4869);
  RANGE (PORT_PROTOCOL_TCP, 4885, 4885);
  RANGE (PORT_PROTOCOL_TCP, 4894, 4894);
  RANGE (PORT_PROTOCOL_TCP, 4899, 4899);
  RANGE (PORT_PROTOCOL_TCP, 4950, 4950);
  RANGE (PORT_PROTOCOL_TCP, 4983, 4983);
  RANGE (PORT_PROTOCOL_TCP, 4987, 4989);
  RANGE (PORT_PROTOCOL_TCP, 4998, 4998);
  RANGE (PORT_PROTOCOL_TCP, 5000, 5011);
  RANGE (PORT_PROTOCOL_TCP, 5020, 5025);
  RANGE (PORT_PROTOCOL_TCP, 5031, 5031);
  RANGE (PORT_PROTOCOL_TCP, 5042, 5042);
  RANGE (PORT_PROTOCOL_TCP, 5050, 5057);
  RANGE (PORT_PROTOCOL_TCP, 5060, 5061);
  RANGE (PORT_PROTOCOL_TCP, 5064, 5066);
  RANGE (PORT_PROTOCOL_TCP, 5069, 5069);
  RANGE (PORT_PROTOCOL_TCP, 5071, 5071);
  RANGE (PORT_PROTOCOL_TCP, 5081, 5081);
  RANGE (PORT_PROTOCOL_TCP, 5093, 5093);
  RANGE (PORT_PROTOCOL_TCP, 5099, 5102);
  RANGE (PORT_PROTOCOL_TCP, 5137, 5137);
  RANGE (PORT_PROTOCOL_TCP, 5145, 5145);
  RANGE (PORT_PROTOCOL_TCP, 5150, 5152);
  RANGE (PORT_PROTOCOL_TCP, 5154, 5154);
  RANGE (PORT_PROTOCOL_TCP, 5165, 5165);
  RANGE (PORT_PROTOCOL_TCP, 5190, 5193);
  RANGE (PORT_PROTOCOL_TCP, 5200, 5203);
  RANGE (PORT_PROTOCOL_TCP, 5222, 5222);
  RANGE (PORT_PROTOCOL_TCP, 5225, 5226);
  RANGE (PORT_PROTOCOL_TCP, 5232, 5232);
  RANGE (PORT_PROTOCOL_TCP, 5236, 5236);
  RANGE (PORT_PROTOCOL_TCP, 5250, 5251);
  RANGE (PORT_PROTOCOL_TCP, 5264, 5265);
  RANGE (PORT_PROTOCOL_TCP, 5269, 5269);
  RANGE (PORT_PROTOCOL_TCP, 5272, 5272);
  RANGE (PORT_PROTOCOL_TCP, 5282, 5282);
  RANGE (PORT_PROTOCOL_TCP, 5300, 5311);
  RANGE (PORT_PROTOCOL_TCP, 5314, 5315);
  RANGE (PORT_PROTOCOL_TCP, 5351, 5355);
  RANGE (PORT_PROTOCOL_TCP, 5400, 5432);
  RANGE (PORT_PROTOCOL_TCP, 5435, 5435);
  RANGE (PORT_PROTOCOL_TCP, 5454, 5456);
  RANGE (PORT_PROTOCOL_TCP, 5461, 5463);
  RANGE (PORT_PROTOCOL_TCP, 5465, 5465);
  RANGE (PORT_PROTOCOL_TCP, 5500, 5504);
  RANGE (PORT_PROTOCOL_TCP, 5510, 5510);
  RANGE (PORT_PROTOCOL_TCP, 5520, 5521);
  RANGE (PORT_PROTOCOL_TCP, 5530, 5530);
  RANGE (PORT_PROTOCOL_TCP, 5540, 5540);
  RANGE (PORT_PROTOCOL_TCP, 5550, 5550);
  RANGE (PORT_PROTOCOL_TCP, 5553, 5556);
  RANGE (PORT_PROTOCOL_TCP, 5566, 5566);
  RANGE (PORT_PROTOCOL_TCP, 5569, 5569);
  RANGE (PORT_PROTOCOL_TCP, 5595, 5605);
  RANGE (PORT_PROTOCOL_TCP, 5631, 5632);
  RANGE (PORT_PROTOCOL_TCP, 5666, 5666);
  RANGE (PORT_PROTOCOL_TCP, 5673, 5680);
  RANGE (PORT_PROTOCOL_TCP, 5688, 5688);
  RANGE (PORT_PROTOCOL_TCP, 5690, 5690);
  RANGE (PORT_PROTOCOL_TCP, 5713, 5717);
  RANGE (PORT_PROTOCOL_TCP, 5720, 5720);
  RANGE (PORT_PROTOCOL_TCP, 5729, 5730);
  RANGE (PORT_PROTOCOL_TCP, 5741, 5742);
  RANGE (PORT_PROTOCOL_TCP, 5745, 5746);
  RANGE (PORT_PROTOCOL_TCP, 5755, 5755);
  RANGE (PORT_PROTOCOL_TCP, 5757, 5757);
  RANGE (PORT_PROTOCOL_TCP, 5766, 5768);
  RANGE (PORT_PROTOCOL_TCP, 5771, 5771);
  RANGE (PORT_PROTOCOL_TCP, 5800, 5803);
  RANGE (PORT_PROTOCOL_TCP, 5813, 5813);
  RANGE (PORT_PROTOCOL_TCP, 5858, 5859);
  RANGE (PORT_PROTOCOL_TCP, 5882, 5882);
  RANGE (PORT_PROTOCOL_TCP, 5888, 5889);
  RANGE (PORT_PROTOCOL_TCP, 5900, 5903);
  RANGE (PORT_PROTOCOL_TCP, 5968, 5969);
  RANGE (PORT_PROTOCOL_TCP, 5977, 5979);
  RANGE (PORT_PROTOCOL_TCP, 5987, 5991);
  RANGE (PORT_PROTOCOL_TCP, 5997, 6010);
  RANGE (PORT_PROTOCOL_TCP, 6050, 6051);
  RANGE (PORT_PROTOCOL_TCP, 6064, 6073);
  RANGE (PORT_PROTOCOL_TCP, 6085, 6085);
  RANGE (PORT_PROTOCOL_TCP, 6100, 6112);
  RANGE (PORT_PROTOCOL_TCP, 6123, 6123);
  RANGE (PORT_PROTOCOL_TCP, 6141, 6150);
  RANGE (PORT_PROTOCOL_TCP, 6175, 6177);
  RANGE (PORT_PROTOCOL_TCP, 6200, 6200);
  RANGE (PORT_PROTOCOL_TCP, 6253, 6253);
  RANGE (PORT_PROTOCOL_TCP, 6255, 6255);
  RANGE (PORT_PROTOCOL_TCP, 6270, 6270);
  RANGE (PORT_PROTOCOL_TCP, 6300, 6300);
  RANGE (PORT_PROTOCOL_TCP, 6321, 6322);
  RANGE (PORT_PROTOCOL_TCP, 6343, 6343);
  RANGE (PORT_PROTOCOL_TCP, 6346, 6347);
  RANGE (PORT_PROTOCOL_TCP, 6373, 6373);
  RANGE (PORT_PROTOCOL_TCP, 6382, 6382);
  RANGE (PORT_PROTOCOL_TCP, 6389, 6389);
  RANGE (PORT_PROTOCOL_TCP, 6400, 6400);
  RANGE (PORT_PROTOCOL_TCP, 6455, 6456);
  RANGE (PORT_PROTOCOL_TCP, 6471, 6471);
  RANGE (PORT_PROTOCOL_TCP, 6500, 6503);
  RANGE (PORT_PROTOCOL_TCP, 6505, 6510);
  RANGE (PORT_PROTOCOL_TCP, 6543, 6543);
  RANGE (PORT_PROTOCOL_TCP, 6547, 6550);
  RANGE (PORT_PROTOCOL_TCP, 6558, 6558);
  RANGE (PORT_PROTOCOL_TCP, 6566, 6566);
  RANGE (PORT_PROTOCOL_TCP, 6580, 6582);
  RANGE (PORT_PROTOCOL_TCP, 6588, 6588);
  RANGE (PORT_PROTOCOL_TCP, 6620, 6621);
  RANGE (PORT_PROTOCOL_TCP, 6623, 6623);
  RANGE (PORT_PROTOCOL_TCP, 6628, 6628);
  RANGE (PORT_PROTOCOL_TCP, 6631, 6631);
  RANGE (PORT_PROTOCOL_TCP, 6665, 6670);
  RANGE (PORT_PROTOCOL_TCP, 6672, 6673);
  RANGE (PORT_PROTOCOL_TCP, 6699, 6701);
  RANGE (PORT_PROTOCOL_TCP, 6714, 6714);
  RANGE (PORT_PROTOCOL_TCP, 6767, 6768);
  RANGE (PORT_PROTOCOL_TCP, 6776, 6776);
  RANGE (PORT_PROTOCOL_TCP, 6788, 6790);
  RANGE (PORT_PROTOCOL_TCP, 6831, 6831);
  RANGE (PORT_PROTOCOL_TCP, 6841, 6842);
  RANGE (PORT_PROTOCOL_TCP, 6850, 6850);
  RANGE (PORT_PROTOCOL_TCP, 6881, 6889);
  RANGE (PORT_PROTOCOL_TCP, 6891, 6891);
  RANGE (PORT_PROTOCOL_TCP, 6901, 6901);
  RANGE (PORT_PROTOCOL_TCP, 6939, 6939);
  RANGE (PORT_PROTOCOL_TCP, 6961, 6966);
  RANGE (PORT_PROTOCOL_TCP, 6969, 6970);
  RANGE (PORT_PROTOCOL_TCP, 6998, 7015);
  RANGE (PORT_PROTOCOL_TCP, 7020, 7021);
  RANGE (PORT_PROTOCOL_TCP, 7030, 7030);
  RANGE (PORT_PROTOCOL_TCP, 7070, 7070);
  RANGE (PORT_PROTOCOL_TCP, 7099, 7100);
  RANGE (PORT_PROTOCOL_TCP, 7121, 7121);
  RANGE (PORT_PROTOCOL_TCP, 7161, 7161);
  RANGE (PORT_PROTOCOL_TCP, 7170, 7170);
  RANGE (PORT_PROTOCOL_TCP, 7174, 7174);
  RANGE (PORT_PROTOCOL_TCP, 7200, 7201);
  RANGE (PORT_PROTOCOL_TCP, 7210, 7210);
  RANGE (PORT_PROTOCOL_TCP, 7269, 7269);
  RANGE (PORT_PROTOCOL_TCP, 7273, 7273);
  RANGE (PORT_PROTOCOL_TCP, 7280, 7281);
  RANGE (PORT_PROTOCOL_TCP, 7283, 7283);
  RANGE (PORT_PROTOCOL_TCP, 7300, 7300);
  RANGE (PORT_PROTOCOL_TCP, 7320, 7320);
  RANGE (PORT_PROTOCOL_TCP, 7326, 7326);
  RANGE (PORT_PROTOCOL_TCP, 7391, 7392);
  RANGE (PORT_PROTOCOL_TCP, 7395, 7395);
  RANGE (PORT_PROTOCOL_TCP, 7426, 7431);
  RANGE (PORT_PROTOCOL_TCP, 7437, 7437);
  RANGE (PORT_PROTOCOL_TCP, 7464, 7464);
  RANGE (PORT_PROTOCOL_TCP, 7491, 7491);
  RANGE (PORT_PROTOCOL_TCP, 7501, 7501);
  RANGE (PORT_PROTOCOL_TCP, 7510, 7511);
  RANGE (PORT_PROTOCOL_TCP, 7544, 7545);
  RANGE (PORT_PROTOCOL_TCP, 7560, 7560);
  RANGE (PORT_PROTOCOL_TCP, 7566, 7566);
  RANGE (PORT_PROTOCOL_TCP, 7570, 7570);
  RANGE (PORT_PROTOCOL_TCP, 7575, 7575);
  RANGE (PORT_PROTOCOL_TCP, 7588, 7588);
  RANGE (PORT_PROTOCOL_TCP, 7597, 7597);
  RANGE (PORT_PROTOCOL_TCP, 7624, 7624);
  RANGE (PORT_PROTOCOL_TCP, 7626, 7627);
  RANGE (PORT_PROTOCOL_TCP, 7633, 7634);
  RANGE (PORT_PROTOCOL_TCP, 7648, 7649);
  RANGE (PORT_PROTOCOL_TCP, 7666, 7666);
  RANGE (PORT_PROTOCOL_TCP, 7674, 7676);
  RANGE (PORT_PROTOCOL_TCP, 7743, 7743);
  RANGE (PORT_PROTOCOL_TCP, 7775, 7779);
  RANGE (PORT_PROTOCOL_TCP, 7781, 7781);
  RANGE (PORT_PROTOCOL_TCP, 7786, 7786);
  RANGE (PORT_PROTOCOL_TCP, 7797, 7798);
  RANGE (PORT_PROTOCOL_TCP, 7800, 7801);
  RANGE (PORT_PROTOCOL_TCP, 7845, 7846);
  RANGE (PORT_PROTOCOL_TCP, 7875, 7875);
  RANGE (PORT_PROTOCOL_TCP, 7902, 7902);
  RANGE (PORT_PROTOCOL_TCP, 7913, 7913);
  RANGE (PORT_PROTOCOL_TCP, 7932, 7933);
  RANGE (PORT_PROTOCOL_TCP, 7967, 7967);
  RANGE (PORT_PROTOCOL_TCP, 7979, 7980);
  RANGE (PORT_PROTOCOL_TCP, 7999, 8005);
  RANGE (PORT_PROTOCOL_TCP, 8007, 8010);
  RANGE (PORT_PROTOCOL_TCP, 8022, 8022);
  RANGE (PORT_PROTOCOL_TCP, 8032, 8033);
  RANGE (PORT_PROTOCOL_TCP, 8044, 8044);
  RANGE (PORT_PROTOCOL_TCP, 8074, 8074);
  RANGE (PORT_PROTOCOL_TCP, 8080, 8082);
  RANGE (PORT_PROTOCOL_TCP, 8088, 8089);
  RANGE (PORT_PROTOCOL_TCP, 8098, 8098);
  RANGE (PORT_PROTOCOL_TCP, 8100, 8100);
  RANGE (PORT_PROTOCOL_TCP, 8115, 8116);
  RANGE (PORT_PROTOCOL_TCP, 8118, 8118);
  RANGE (PORT_PROTOCOL_TCP, 8121, 8122);
  RANGE (PORT_PROTOCOL_TCP, 8130, 8132);
  RANGE (PORT_PROTOCOL_TCP, 8160, 8161);
  RANGE (PORT_PROTOCOL_TCP, 8181, 8194);
  RANGE (PORT_PROTOCOL_TCP, 8199, 8201);
  RANGE (PORT_PROTOCOL_TCP, 8204, 8208);
  RANGE (PORT_PROTOCOL_TCP, 8224, 8225);
  RANGE (PORT_PROTOCOL_TCP, 8245, 8245);
  RANGE (PORT_PROTOCOL_TCP, 8311, 8311);
  RANGE (PORT_PROTOCOL_TCP, 8351, 8351);
  RANGE (PORT_PROTOCOL_TCP, 8376, 8380);
  RANGE (PORT_PROTOCOL_TCP, 8400, 8403);
  RANGE (PORT_PROTOCOL_TCP, 8416, 8417);
  RANGE (PORT_PROTOCOL_TCP, 8431, 8431);
  RANGE (PORT_PROTOCOL_TCP, 8443, 8444);
  RANGE (PORT_PROTOCOL_TCP, 8450, 8450);
  RANGE (PORT_PROTOCOL_TCP, 8473, 8473);
  RANGE (PORT_PROTOCOL_TCP, 8554, 8555);
  RANGE (PORT_PROTOCOL_TCP, 8649, 8649);
  RANGE (PORT_PROTOCOL_TCP, 8733, 8733);
  RANGE (PORT_PROTOCOL_TCP, 8763, 8765);
  RANGE (PORT_PROTOCOL_TCP, 8786, 8787);
  RANGE (PORT_PROTOCOL_TCP, 8804, 8804);
  RANGE (PORT_PROTOCOL_TCP, 8863, 8864);
  RANGE (PORT_PROTOCOL_TCP, 8875, 8875);
  RANGE (PORT_PROTOCOL_TCP, 8880, 8880);
  RANGE (PORT_PROTOCOL_TCP, 8888, 8894);
  RANGE (PORT_PROTOCOL_TCP, 8900, 8901);
  RANGE (PORT_PROTOCOL_TCP, 8910, 8911);
  RANGE (PORT_PROTOCOL_TCP, 8954, 8954);
  RANGE (PORT_PROTOCOL_TCP, 8989, 8989);
  RANGE (PORT_PROTOCOL_TCP, 8999, 9002);
  RANGE (PORT_PROTOCOL_TCP, 9006, 9006);
  RANGE (PORT_PROTOCOL_TCP, 9009, 9009);
  RANGE (PORT_PROTOCOL_TCP, 9020, 9026);
  RANGE (PORT_PROTOCOL_TCP, 9080, 9080);
  RANGE (PORT_PROTOCOL_TCP, 9090, 9091);
  RANGE (PORT_PROTOCOL_TCP, 9100, 9103);
  RANGE (PORT_PROTOCOL_TCP, 9110, 9111);
  RANGE (PORT_PROTOCOL_TCP, 9131, 9131);
  RANGE (PORT_PROTOCOL_TCP, 9152, 9152);
  RANGE (PORT_PROTOCOL_TCP, 9160, 9164);
  RANGE (PORT_PROTOCOL_TCP, 9200, 9207);
  RANGE (PORT_PROTOCOL_TCP, 9210, 9211);
  RANGE (PORT_PROTOCOL_TCP, 9217, 9217);
  RANGE (PORT_PROTOCOL_TCP, 9281, 9285);
  RANGE (PORT_PROTOCOL_TCP, 9287, 9287);
  RANGE (PORT_PROTOCOL_TCP, 9292, 9292);
  RANGE (PORT_PROTOCOL_TCP, 9321, 9321);
  RANGE (PORT_PROTOCOL_TCP, 9343, 9344);
  RANGE (PORT_PROTOCOL_TCP, 9346, 9346);
  RANGE (PORT_PROTOCOL_TCP, 9374, 9374);
  RANGE (PORT_PROTOCOL_TCP, 9390, 9390);
  RANGE (PORT_PROTOCOL_TCP, 9396, 9397);
  RANGE (PORT_PROTOCOL_TCP, 9400, 9400);
  RANGE (PORT_PROTOCOL_TCP, 9418, 9418);
  RANGE (PORT_PROTOCOL_TCP, 9495, 9495);
  RANGE (PORT_PROTOCOL_TCP, 9500, 9500);
  RANGE (PORT_PROTOCOL_TCP, 9535, 9537);
  RANGE (PORT_PROTOCOL_TCP, 9593, 9595);
  RANGE (PORT_PROTOCOL_TCP, 9600, 9600);
  RANGE (PORT_PROTOCOL_TCP, 9612, 9612);
  RANGE (PORT_PROTOCOL_TCP, 9704, 9704);
  RANGE (PORT_PROTOCOL_TCP, 9747, 9747);
  RANGE (PORT_PROTOCOL_TCP, 9753, 9753);
  RANGE (PORT_PROTOCOL_TCP, 9797, 9797);
  RANGE (PORT_PROTOCOL_TCP, 9800, 9802);
  RANGE (PORT_PROTOCOL_TCP, 9872, 9872);
  RANGE (PORT_PROTOCOL_TCP, 9875, 9876);
  RANGE (PORT_PROTOCOL_TCP, 9888, 9889);
  RANGE (PORT_PROTOCOL_TCP, 9898, 9901);
  RANGE (PORT_PROTOCOL_TCP, 9909, 9909);
  RANGE (PORT_PROTOCOL_TCP, 9911, 9911);
  RANGE (PORT_PROTOCOL_TCP, 9950, 9952);
  RANGE (PORT_PROTOCOL_TCP, 9990, 10005);
  RANGE (PORT_PROTOCOL_TCP, 10007, 10008);
  RANGE (PORT_PROTOCOL_TCP, 10012, 10012);
  RANGE (PORT_PROTOCOL_TCP, 10080, 10083);
  RANGE (PORT_PROTOCOL_TCP, 10101, 10103);
  RANGE (PORT_PROTOCOL_TCP, 10113, 10116);
  RANGE (PORT_PROTOCOL_TCP, 10128, 10128);
  RANGE (PORT_PROTOCOL_TCP, 10252, 10252);
  RANGE (PORT_PROTOCOL_TCP, 10260, 10260);
  RANGE (PORT_PROTOCOL_TCP, 10288, 10288);
  RANGE (PORT_PROTOCOL_TCP, 10607, 10607);
  RANGE (PORT_PROTOCOL_TCP, 10666, 10666);
  RANGE (PORT_PROTOCOL_TCP, 10752, 10752);
  RANGE (PORT_PROTOCOL_TCP, 10990, 10990);
  RANGE (PORT_PROTOCOL_TCP, 11000, 11001);
  RANGE (PORT_PROTOCOL_TCP, 11111, 11111);
  RANGE (PORT_PROTOCOL_TCP, 11201, 11201);
  RANGE (PORT_PROTOCOL_TCP, 11223, 11223);
  RANGE (PORT_PROTOCOL_TCP, 11319, 11321);
  RANGE (PORT_PROTOCOL_TCP, 11367, 11367);
  RANGE (PORT_PROTOCOL_TCP, 11371, 11371);
  RANGE (PORT_PROTOCOL_TCP, 11600, 11600);
  RANGE (PORT_PROTOCOL_TCP, 11720, 11720);
  RANGE (PORT_PROTOCOL_TCP, 11751, 11751);
  RANGE (PORT_PROTOCOL_TCP, 11965, 11965);
  RANGE (PORT_PROTOCOL_TCP, 11967, 11967);
  RANGE (PORT_PROTOCOL_TCP, 11999, 12006);
  RANGE (PORT_PROTOCOL_TCP, 12076, 12076);
  RANGE (PORT_PROTOCOL_TCP, 12109, 12109);
  RANGE (PORT_PROTOCOL_TCP, 12168, 12168);
  RANGE (PORT_PROTOCOL_TCP, 12172, 12172);
  RANGE (PORT_PROTOCOL_TCP, 12223, 12223);
  RANGE (PORT_PROTOCOL_TCP, 12321, 12321);
  RANGE (PORT_PROTOCOL_TCP, 12345, 12346);
  RANGE (PORT_PROTOCOL_TCP, 12361, 12362);
  RANGE (PORT_PROTOCOL_TCP, 12468, 12468);
  RANGE (PORT_PROTOCOL_TCP, 12701, 12701);
  RANGE (PORT_PROTOCOL_TCP, 12753, 12753);
  RANGE (PORT_PROTOCOL_TCP, 13160, 13160);
  RANGE (PORT_PROTOCOL_TCP, 13223, 13224);
  RANGE (PORT_PROTOCOL_TCP, 13701, 13702);
  RANGE (PORT_PROTOCOL_TCP, 13705, 13706);
  RANGE (PORT_PROTOCOL_TCP, 13708, 13718);
  RANGE (PORT_PROTOCOL_TCP, 13720, 13722);
  RANGE (PORT_PROTOCOL_TCP, 13724, 13724);
  RANGE (PORT_PROTOCOL_TCP, 13782, 13783);
  RANGE (PORT_PROTOCOL_TCP, 13818, 13822);
  RANGE (PORT_PROTOCOL_TCP, 14001, 14001);
  RANGE (PORT_PROTOCOL_TCP, 14033, 14034);
  RANGE (PORT_PROTOCOL_TCP, 14141, 14141);
  RANGE (PORT_PROTOCOL_TCP, 14145, 14145);
  RANGE (PORT_PROTOCOL_TCP, 14149, 14149);
  RANGE (PORT_PROTOCOL_TCP, 14194, 14194);
  RANGE (PORT_PROTOCOL_TCP, 14237, 14237);
  RANGE (PORT_PROTOCOL_TCP, 14936, 14937);
  RANGE (PORT_PROTOCOL_TCP, 15000, 15000);
  RANGE (PORT_PROTOCOL_TCP, 15126, 15126);
  RANGE (PORT_PROTOCOL_TCP, 15345, 15345);
  RANGE (PORT_PROTOCOL_TCP, 15363, 15363);
  RANGE (PORT_PROTOCOL_TCP, 16360, 16361);
  RANGE (PORT_PROTOCOL_TCP, 16367, 16368);
  RANGE (PORT_PROTOCOL_TCP, 16384, 16384);
  RANGE (PORT_PROTOCOL_TCP, 16660, 16661);
  RANGE (PORT_PROTOCOL_TCP, 16959, 16959);
  RANGE (PORT_PROTOCOL_TCP, 16969, 16969);
  RANGE (PORT_PROTOCOL_TCP, 16991, 16991);
  RANGE (PORT_PROTOCOL_TCP, 17007, 17007);
  RANGE (PORT_PROTOCOL_TCP, 17185, 17185);
  RANGE (PORT_PROTOCOL_TCP, 17219, 17219);
  RANGE (PORT_PROTOCOL_TCP, 17300, 17300);
  RANGE (PORT_PROTOCOL_TCP, 17770, 17772);
  RANGE (PORT_PROTOCOL_TCP, 18000, 18000);
  RANGE (PORT_PROTOCOL_TCP, 18181, 18187);
  RANGE (PORT_PROTOCOL_TCP, 18190, 18190);
  RANGE (PORT_PROTOCOL_TCP, 18241, 18241);
  RANGE (PORT_PROTOCOL_TCP, 18463, 18463);
  RANGE (PORT_PROTOCOL_TCP, 18769, 18769);
  RANGE (PORT_PROTOCOL_TCP, 18888, 18888);
  RANGE (PORT_PROTOCOL_TCP, 19191, 19191);
  RANGE (PORT_PROTOCOL_TCP, 19194, 19194);
  RANGE (PORT_PROTOCOL_TCP, 19283, 19283);
  RANGE (PORT_PROTOCOL_TCP, 19315, 19315);
  RANGE (PORT_PROTOCOL_TCP, 19398, 19398);
  RANGE (PORT_PROTOCOL_TCP, 19410, 19412);
  RANGE (PORT_PROTOCOL_TCP, 19540, 19541);
  RANGE (PORT_PROTOCOL_TCP, 19638, 19638);
  RANGE (PORT_PROTOCOL_TCP, 19726, 19726);
  RANGE (PORT_PROTOCOL_TCP, 20000, 20001);
  RANGE (PORT_PROTOCOL_TCP, 20005, 20005);
  RANGE (PORT_PROTOCOL_TCP, 20011, 20012);
  RANGE (PORT_PROTOCOL_TCP, 20034, 20034);
  RANGE (PORT_PROTOCOL_TCP, 20200, 20200);
  RANGE (PORT_PROTOCOL_TCP, 20202, 20203);
  RANGE (PORT_PROTOCOL_TCP, 20222, 20222);
  RANGE (PORT_PROTOCOL_TCP, 20670, 20670);
  RANGE (PORT_PROTOCOL_TCP, 20999, 21000);
  RANGE (PORT_PROTOCOL_TCP, 21490, 21490);
  RANGE (PORT_PROTOCOL_TCP, 21544, 21544);
  RANGE (PORT_PROTOCOL_TCP, 21590, 21590);
  RANGE (PORT_PROTOCOL_TCP, 21800, 21800);
  RANGE (PORT_PROTOCOL_TCP, 21845, 21849);
  RANGE (PORT_PROTOCOL_TCP, 22000, 22001);
  RANGE (PORT_PROTOCOL_TCP, 22222, 22222);
  RANGE (PORT_PROTOCOL_TCP, 22273, 22273);
  RANGE (PORT_PROTOCOL_TCP, 22289, 22289);
  RANGE (PORT_PROTOCOL_TCP, 22305, 22305);
  RANGE (PORT_PROTOCOL_TCP, 22321, 22321);
  RANGE (PORT_PROTOCOL_TCP, 22370, 22370);
  RANGE (PORT_PROTOCOL_TCP, 22555, 22555);
  RANGE (PORT_PROTOCOL_TCP, 22800, 22800);
  RANGE (PORT_PROTOCOL_TCP, 22951, 22951);
  RANGE (PORT_PROTOCOL_TCP, 23456, 23456);
  RANGE (PORT_PROTOCOL_TCP, 24000, 24006);
  RANGE (PORT_PROTOCOL_TCP, 24242, 24242);
  RANGE (PORT_PROTOCOL_TCP, 24249, 24249);
  RANGE (PORT_PROTOCOL_TCP, 24345, 24347);
  RANGE (PORT_PROTOCOL_TCP, 24386, 24386);
  RANGE (PORT_PROTOCOL_TCP, 24554, 24554);
  RANGE (PORT_PROTOCOL_TCP, 24677, 24678);
  RANGE (PORT_PROTOCOL_TCP, 24922, 24922);
  RANGE (PORT_PROTOCOL_TCP, 25000, 25009);
  RANGE (PORT_PROTOCOL_TCP, 25378, 25378);
  RANGE (PORT_PROTOCOL_TCP, 25544, 25544);
  RANGE (PORT_PROTOCOL_TCP, 25793, 25793);
  RANGE (PORT_PROTOCOL_TCP, 25867, 25867);
  RANGE (PORT_PROTOCOL_TCP, 25901, 25901);
  RANGE (PORT_PROTOCOL_TCP, 25903, 25903);
  RANGE (PORT_PROTOCOL_TCP, 26000, 26000);
  RANGE (PORT_PROTOCOL_TCP, 26208, 26208);
  RANGE (PORT_PROTOCOL_TCP, 26260, 26264);
  RANGE (PORT_PROTOCOL_TCP, 27000, 27010);
  RANGE (PORT_PROTOCOL_TCP, 27345, 27345);
  RANGE (PORT_PROTOCOL_TCP, 27374, 27374);
  RANGE (PORT_PROTOCOL_TCP, 27504, 27504);
  RANGE (PORT_PROTOCOL_TCP, 27665, 27665);
  RANGE (PORT_PROTOCOL_TCP, 27999, 27999);
  RANGE (PORT_PROTOCOL_TCP, 28001, 28001);
  RANGE (PORT_PROTOCOL_TCP, 29559, 29559);
  RANGE (PORT_PROTOCOL_TCP, 29891, 29891);
  RANGE (PORT_PROTOCOL_TCP, 30001, 30002);
  RANGE (PORT_PROTOCOL_TCP, 30100, 30102);
  RANGE (PORT_PROTOCOL_TCP, 30303, 30303);
  RANGE (PORT_PROTOCOL_TCP, 30999, 30999);
  RANGE (PORT_PROTOCOL_TCP, 31337, 31337);
  RANGE (PORT_PROTOCOL_TCP, 31339, 31339);
  RANGE (PORT_PROTOCOL_TCP, 31416, 31416);
  RANGE (PORT_PROTOCOL_TCP, 31457, 31457);
  RANGE (PORT_PROTOCOL_TCP, 31554, 31554);
  RANGE (PORT_PROTOCOL_TCP, 31556, 31556);
  RANGE (PORT_PROTOCOL_TCP, 31620, 31620);
  RANGE (PORT_PROTOCOL_TCP, 31765, 31765);
  RANGE (PORT_PROTOCOL_TCP, 31785, 31787);
  RANGE (PORT_PROTOCOL_TCP, 32261, 32261);
  RANGE (PORT_PROTOCOL_TCP, 32666, 32666);
  RANGE (PORT_PROTOCOL_TCP, 32768, 32780);
  RANGE (PORT_PROTOCOL_TCP, 32786, 32787);
  RANGE (PORT_PROTOCOL_TCP, 32896, 32896);
  RANGE (PORT_PROTOCOL_TCP, 33270, 33270);
  RANGE (PORT_PROTOCOL_TCP, 33331, 33331);
  RANGE (PORT_PROTOCOL_TCP, 33434, 33434);
  RANGE (PORT_PROTOCOL_TCP, 33911, 33911);
  RANGE (PORT_PROTOCOL_TCP, 34249, 34249);
  RANGE (PORT_PROTOCOL_TCP, 34324, 34324);
  RANGE (PORT_PROTOCOL_TCP, 34952, 34952);
  RANGE (PORT_PROTOCOL_TCP, 36865, 36865);
  RANGE (PORT_PROTOCOL_TCP, 37475, 37475);
  RANGE (PORT_PROTOCOL_TCP, 37651, 37651);
  RANGE (PORT_PROTOCOL_TCP, 38037, 38037);
  RANGE (PORT_PROTOCOL_TCP, 38201, 38201);
  RANGE (PORT_PROTOCOL_TCP, 38292, 38293);
  RANGE (PORT_PROTOCOL_TCP, 39681, 39681);
  RANGE (PORT_PROTOCOL_TCP, 40412, 40412);
  RANGE (PORT_PROTOCOL_TCP, 40841, 40843);
  RANGE (PORT_PROTOCOL_TCP, 41111, 41111);
  RANGE (PORT_PROTOCOL_TCP, 41508, 41508);
  RANGE (PORT_PROTOCOL_TCP, 41794, 41795);
  RANGE (PORT_PROTOCOL_TCP, 42508, 42510);
  RANGE (PORT_PROTOCOL_TCP, 43118, 43118);
  RANGE (PORT_PROTOCOL_TCP, 43188, 43190);
  RANGE (PORT_PROTOCOL_TCP, 44321, 44322);
  RANGE (PORT_PROTOCOL_TCP, 44333, 44334);
  RANGE (PORT_PROTOCOL_TCP, 44442, 44443);
  RANGE (PORT_PROTOCOL_TCP, 44818, 44818);
  RANGE (PORT_PROTOCOL_TCP, 45000, 45000);
  RANGE (PORT_PROTOCOL_TCP, 45054, 45054);
  RANGE (PORT_PROTOCOL_TCP, 45678, 45678);
  RANGE (PORT_PROTOCOL_TCP, 45966, 45966);
  RANGE (PORT_PROTOCOL_TCP, 47000, 47000);
  RANGE (PORT_PROTOCOL_TCP, 47557, 47557);
  RANGE (PORT_PROTOCOL_TCP, 47624, 47624);
  RANGE (PORT_PROTOCOL_TCP, 47806, 47806);
  RANGE (PORT_PROTOCOL_TCP, 47808, 47808);
  RANGE (PORT_PROTOCOL_TCP, 47891, 47891);
  RANGE (PORT_PROTOCOL_TCP, 48000, 48003);
  RANGE (PORT_PROTOCOL_TCP, 48556, 48556);
  RANGE (PORT_PROTOCOL_TCP, 49400, 49400);
  RANGE (PORT_PROTOCOL_TCP, 50000, 50004);
  RANGE (PORT_PROTOCOL_TCP, 50505, 50505);
  RANGE (PORT_PROTOCOL_TCP, 50776, 50776);
  RANGE (PORT_PROTOCOL_TCP, 51210, 51210);
  RANGE (PORT_PROTOCOL_TCP, 53001, 53001);
  RANGE (PORT_PROTOCOL_TCP, 54320, 54321);
  RANGE (PORT_PROTOCOL_TCP, 57341, 57341);
  RANGE (PORT_PROTOCOL_TCP, 59595, 59595);
  RANGE (PORT_PROTOCOL_TCP, 60177, 60177);
  RANGE (PORT_PROTOCOL_TCP, 60179, 60179);
  RANGE (PORT_PROTOCOL_TCP, 61439, 61441);
  RANGE (PORT_PROTOCOL_TCP, 61446, 61446);
  RANGE (PORT_PROTOCOL_TCP, 65000, 65000);
  RANGE (PORT_PROTOCOL_TCP, 65301, 65301);
}

/**
 * @brief Ensure that the predefined port lists exist.
 */
void
ensure_predefined_port_lists_exist ()
{
  if (sql_int (0, 0,
               "SELECT count(*) FROM port_lists"
               " WHERE uuid = '" PORT_LIST_UUID_DEFAULT "';")
      == 0)
    {
      port_list_t list;
      sql ("INSERT INTO port_lists (uuid, owner, name, comment, creation_time,"
           "                        modification_time)"
           " VALUES ('" PORT_LIST_UUID_DEFAULT "', NULL, 'OpenVAS Default',"
           " '', now (), now ())");
      list = sqlite3_last_insert_rowid (task_db);
      make_port_ranges_openvas_default (list);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM port_lists"
               " WHERE uuid = '" PORT_LIST_UUID_ALL_TCP "';")
      == 0)
    {
      port_list_t list;
      sql ("INSERT INTO port_lists (uuid, owner, name, comment, creation_time,"
           "                        modification_time)"
           " VALUES ('" PORT_LIST_UUID_ALL_TCP "', NULL, 'All TCP',"
           " '', now(), now())");
      list = sqlite3_last_insert_rowid (task_db);
      RANGE (PORT_PROTOCOL_TCP, 1, 65535);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM port_lists"
               " WHERE uuid = '" PORT_LIST_UUID_ALL_TCP_NMAP_5_51_TOP_100 "';")
      == 0)
    {
      port_list_t list;
      sql ("INSERT INTO port_lists (uuid, owner, name, comment, creation_time,"
           "                        modification_time)"
           " VALUES ('" PORT_LIST_UUID_ALL_TCP_NMAP_5_51_TOP_100 "', NULL,"
           " 'All TCP and Nmap 5.51 top 100 UDP', '', now (), now ())");
      list = sqlite3_last_insert_rowid (task_db);
      make_port_ranges_all_tcp_nmap_5_51_top_100 (list);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM port_lists"
               " WHERE uuid = '" PORT_LIST_UUID_ALL_TCP_NMAP_5_51_TOP_1000 "';")
      == 0)
    {
      port_list_t list;
      sql ("INSERT INTO port_lists (uuid, owner, name, comment, creation_time,"
           "                        modification_time)"
           " VALUES ('" PORT_LIST_UUID_ALL_TCP_NMAP_5_51_TOP_1000 "', NULL,"
           " 'All TCP and Nmap 5.51 top 1000 UDP', '', now (), now ())");
      list = sqlite3_last_insert_rowid (task_db);
      make_port_ranges_all_tcp_nmap_5_51_top_1000 (list);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM port_lists"
               " WHERE uuid = '" PORT_LIST_UUID_ALL_PRIV_TCP "';")
      == 0)
    {
      port_list_t list;
      sql ("INSERT INTO port_lists (uuid, owner, name, comment, creation_time,"
           "                        modification_time)"
           " VALUES ('" PORT_LIST_UUID_ALL_PRIV_TCP "', NULL,"
           " 'All privileged TCP', '', now (), now ())");
      list = sqlite3_last_insert_rowid (task_db);
      RANGE (PORT_PROTOCOL_TCP, 1, 1023);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM port_lists"
               " WHERE uuid = '" PORT_LIST_UUID_ALL_PRIV_TCP_UDP "';")
      == 0)
    {
      port_list_t list;
      sql ("INSERT INTO port_lists (uuid, owner, name, comment, creation_time,"
           "                        modification_time)"
           " VALUES ('" PORT_LIST_UUID_ALL_PRIV_TCP_UDP "', NULL,"
           " 'All privileged TCP and UDP', '', now (), now ())");
      list = sqlite3_last_insert_rowid (task_db);
      RANGE (PORT_PROTOCOL_TCP, 1, 1023);
      RANGE (PORT_PROTOCOL_UDP, 1, 1023);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM port_lists"
               " WHERE uuid = '" PORT_LIST_UUID_ALL_IANA_TCP_2012 "';")
      == 0)
    {
      port_list_t list;
      sql ("INSERT INTO port_lists (uuid, owner, name, comment, creation_time,"
           "                        modification_time)"
           " VALUES ('" PORT_LIST_UUID_ALL_IANA_TCP_2012 "', NULL,"
           " 'All IANA assigned TCP 2012-02-10', '', now (), now ())");
      list = sqlite3_last_insert_rowid (task_db);
      make_port_ranges_iana_tcp_2012 (list);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM port_lists"
               " WHERE uuid = '" PORT_LIST_UUID_ALL_IANA_TCP_UDP_2012 "';")
      == 0)
    {
      port_list_t list;
      sql ("INSERT INTO port_lists (uuid, owner, name, comment, creation_time,"
           "                        modification_time)"
           " VALUES ('" PORT_LIST_UUID_ALL_IANA_TCP_UDP_2012 "', NULL,"
           " 'All IANA assigned TCP and UDP 2012-02-10', '', now (), now ())");
      list = sqlite3_last_insert_rowid (task_db);
      make_port_ranges_iana_tcp_udp_2012 (list);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM port_lists"
               " WHERE uuid = '" PORT_LIST_UUID_NMAP_5_51_TOP_2000_TOP_100 "';")
      == 0)
    {
      port_list_t list;
      sql ("INSERT INTO port_lists (uuid, owner, name, comment, creation_time,"
           "                        modification_time)"
           " VALUES ('" PORT_LIST_UUID_NMAP_5_51_TOP_2000_TOP_100 "', NULL,"
           " 'Nmap 5.51 top 2000 TCP and top 100 UDP', '', now (), now ())");
      list = sqlite3_last_insert_rowid (task_db);
      make_port_ranges_nmap_5_51_top_2000_top_100 (list);
    }
}

/**
 * @brief Bring UUIDs for single report format up to date.
 *
 * @param[in]  old  Old UUID.
 * @param[in]  new  New UUID.
 */
static void
update_report_format_uuid (const char *old, const char *new)
{
  gchar *dir;

  dir = g_build_filename (OPENVAS_DATA_DIR,
                          "openvasmd",
                          "global_report_formats",
                          old,
                          NULL);

  if (g_file_test (dir, G_FILE_TEST_EXISTS))
    openvas_file_remove_recurse (dir);
  g_free (dir);

  sql ("UPDATE report_formats"
       " SET uuid = '%s', modification_time = now ()"
       " WHERE uuid = '%s';",
       new,
       old);

  sql ("UPDATE alert_method_data"
       " SET data = '%s'"
       " WHERE data = '%s';",
       new,
       old);
}

/**
 * @brief Bring report format UUIDs in database up to date.
 */
static void
update_report_format_uuids ()
{
  /* Same as migrate_58_to_59, to enable backporting r13519 to OpenVAS-5
   * without backporting the 58 to 59 migrator.  In future these should be
   * done here instead of in a migrator. */

  update_report_format_uuid ("a0704abb-2120-489f-959f-251c9f4ffebd",
                             "5ceff8ba-1f62-11e1-ab9f-406186ea4fc5");

  update_report_format_uuid ("b993b6f5-f9fb-4e6e-9c94-dd46c00e058d",
                             "6c248850-1f62-11e1-b082-406186ea4fc5");

  update_report_format_uuid ("929884c6-c2c4-41e7-befb-2f6aa163b458",
                             "77bd6c4a-1f62-11e1-abf0-406186ea4fc5");

  update_report_format_uuid ("9f1ab17b-aaaa-411a-8c57-12df446f5588",
                             "7fcc3a1a-1f62-11e1-86bf-406186ea4fc5");

  update_report_format_uuid ("f5c2a364-47d2-4700-b21d-0a7693daddab",
                             "9ca6fe72-1f62-11e1-9e7c-406186ea4fc5");

  update_report_format_uuid ("1a60a67e-97d0-4cbf-bc77-f71b08e7043d",
                             "a0b5bfb2-1f62-11e1-85db-406186ea4fc5");

  update_report_format_uuid ("19f6f1b3-7128-4433-888c-ccc764fe6ed5",
                             "a3810a62-1f62-11e1-9219-406186ea4fc5");

  update_report_format_uuid ("d5da9f67-8551-4e51-807b-b6a873d70e34",
                             "a994b278-1f62-11e1-96ac-406186ea4fc5");

  /* New updates go here.  Oldest must come first, so add at the end. */

  update_report_format_uuid ("7fcc3a1a-1f62-11e1-86bf-406186ea4fc5",
                             "a684c02c-b531-11e1-bdc2-406186ea4fc5");

  update_report_format_uuid ("a0b5bfb2-1f62-11e1-85db-406186ea4fc5",
                             "c402cc3e-b531-11e1-9163-406186ea4fc5");
}

/**
 * @brief Initialize the manage library.
 *
 * Ensure all tasks are in a clean initial state.
 *
 * Beware that calling this function while tasks are running may lead to
 * problems.
 *
 * @param[in]  log_config      Log configuration.
 * @param[in]  nvt_cache_mode  True when running in NVT caching mode.
 * @param[in]  database        Location of database.
 *
 * @return 0 success, -1 error, -2 database is wrong version, -3 database needs
 *         to be initialised from server.
 */
int
init_manage (GSList *log_config, int nvt_cache_mode, const gchar *database)
{
  char *database_version;

  g_log_set_handler (G_LOG_DOMAIN,
                     ALL_LOG_LEVELS,
                     (GLogFunc) openvas_log_func,
                     log_config);

  current_credentials.uuid = NULL;
  current_credentials.username = NULL;
  current_credentials.password = NULL;

  init_manage_process (0, database);

  /* Check that the version of the database is correct. */

  database_version = sql_string (0, 0,
                                 "SELECT value FROM main.meta"
                                 " WHERE name = 'database_version';");
  if (nvt_cache_mode)
    {
      if (database_version
          && strcmp (database_version,
                     G_STRINGIFY (OPENVASMD_DATABASE_VERSION)))
        {
          g_message ("%s: database version of database: %s\n",
                     __FUNCTION__,
                     database_version);
          g_message ("%s: database version supported by manager: %s\n",
                     __FUNCTION__,
                     G_STRINGIFY (OPENVASMD_DATABASE_VERSION));
          g_free (database_version);
          return -2;
        }
      g_free (database_version);

      /* If database_version was NULL then meta was missing, so assume
       * that the database is missing, which is OK. */
    }
  else
    {
      long long int count;

      if (database_version)
        {
          if (strcmp (database_version,
                      G_STRINGIFY (OPENVASMD_DATABASE_VERSION)))
            {
              g_message ("%s: database version of database: %s\n",
                         __FUNCTION__,
                         database_version);
              g_message ("%s: database version supported by manager: %s\n",
                         __FUNCTION__,
                         G_STRINGIFY (OPENVASMD_DATABASE_VERSION));
              g_free (database_version);
              return -2;
            }
          g_free (database_version);
        }
      else
        /* Assume database is missing. */
        return -3;

      /* Check that the database was initialised from the scanner.
       *
       * This can also fail after a migration, for example if the database
       * was created before NVT preferences were cached in the database.
       */

      if (sql_int64 (&count, 0, 0,
                     "SELECT count(*) FROM main.meta"
                     " WHERE name = 'nvts_md5sum'"
                     " OR name = 'nvt_preferences_enabled';")
          || count < 2)
        return -3;
    }

  /* Ensure the tables exist. */

  create_tables ();

  /* Ensure the version is set. */

  set_db_version (OPENVASMD_DATABASE_VERSION);

  /* Ensure the special "om" user exists. */

  if (sql_int (0, 0, "SELECT count(*) FROM users WHERE name = 'om';") == 0)
    sql ("INSERT into users (name, password) VALUES ('om', '');");

  /* Ensure the nvti cache update flag exists and is clear. */

  if (sql_int (0, 0,
               "SELECT count(*) FROM main.meta"
               " WHERE name = 'update_nvti_cache';"))
    sql ("UPDATE main.meta SET value = 0 WHERE name = 'update_nvti_cache';");
  else
    sql ("INSERT INTO main.meta (name, value)"
         " VALUES ('update_nvti_cache', 0);");

  /* Ensure that the highest number in a port range is 65535.  At some
   * point ranges were initialised to 65536.
   *
   * This should be a migrator, but this way is easier to backport.  */

  sql ("UPDATE port_ranges SET end = 65535 WHERE end = 65536;");
  sql ("UPDATE port_ranges SET start = 65535 WHERE start = 65536;");

  /* Ensure every part of the predefined selector exists.
   *
   * This restores entries lost due to the error solved 2010-08-13 by r8805.  */

  if (sql_int (0, 0,
               "SELECT count(*) FROM nvt_selectors WHERE name ="
               " '" MANAGE_NVT_SELECTOR_UUID_ALL "'"
               " AND type = " G_STRINGIFY (NVT_SELECTOR_TYPE_ALL) ";")
      == 0)
    {
      sql ("INSERT into nvt_selectors (name, exclude, type, family_or_nvt)"
           " VALUES ('" MANAGE_NVT_SELECTOR_UUID_ALL "', 0, "
           G_STRINGIFY (NVT_SELECTOR_TYPE_ALL) ", NULL);");
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM nvt_selectors WHERE name ="
               " '" MANAGE_NVT_SELECTOR_UUID_ALL "'"
               " AND type = " G_STRINGIFY (NVT_SELECTOR_TYPE_FAMILY)
               " AND family_or_nvt = 'Port scanners';")
      == 0)
    {
      sql ("INSERT into nvt_selectors"
           " (name, exclude, type, family_or_nvt, family)"
           " VALUES ('" MANAGE_NVT_SELECTOR_UUID_ALL "', 1, "
           G_STRINGIFY (NVT_SELECTOR_TYPE_FAMILY) ","
           " 'Port scanners', 'Port scanners');");
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM nvt_selectors WHERE name ="
               " '" MANAGE_NVT_SELECTOR_UUID_ALL "'"
               " AND type = " G_STRINGIFY (NVT_SELECTOR_TYPE_NVT)
               " AND family_or_nvt = '1.3.6.1.4.1.25623.1.0.14259';")
      == 0)
    {
      sql ("INSERT into nvt_selectors"
           " (name, exclude, type, family_or_nvt, family)"
           " VALUES ('" MANAGE_NVT_SELECTOR_UUID_ALL "', 0, "
           G_STRINGIFY (NVT_SELECTOR_TYPE_NVT) ","
           /* OID of the "Nmap (NASL wrapper)" NVT. */
           " '1.3.6.1.4.1.25623.1.0.14259', 'Port scanners');");
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM nvt_selectors WHERE name ="
               " '" MANAGE_NVT_SELECTOR_UUID_ALL "'"
               " AND type = " G_STRINGIFY (NVT_SELECTOR_TYPE_NVT)
               " AND family_or_nvt = '1.3.6.1.4.1.25623.1.0.100315';")
      == 0)
    {
      sql ("INSERT into nvt_selectors"
           " (name, exclude, type, family_or_nvt, family)"
           " VALUES ('" MANAGE_NVT_SELECTOR_UUID_ALL "', 0, "
           G_STRINGIFY (NVT_SELECTOR_TYPE_NVT) ","
           /* OID of the "Ping Host" NVT. */
           " '1.3.6.1.4.1.25623.1.0.100315', 'Port scanners');");
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM nvt_selectors WHERE name ="
               " '" MANAGE_NVT_SELECTOR_UUID_ALL "'"
               " AND type = " G_STRINGIFY (NVT_SELECTOR_TYPE_NVT)
               " AND family_or_nvt = '1.3.6.1.4.1.25623.1.0.80109';")
      == 0)
    {
      sql ("INSERT into nvt_selectors"
           " (name, exclude, type, family_or_nvt, family)"
           " VALUES ('" MANAGE_NVT_SELECTOR_UUID_ALL "', 1, "
           G_STRINGIFY (NVT_SELECTOR_TYPE_NVT) ","
           /* OID of the "w3af (NASL wrapper)" NVT. */
           " '1.3.6.1.4.1.25623.1.0.80109', 'Web application abuses');");
    }

  /* Ensure the predefined configs exist. */

  if (sql_int (0, 0,
               "SELECT count(*) FROM configs"
               " WHERE name = 'Full and fast';")
      == 0)
    {
      config_t config;

      sql ("INSERT into configs (id, uuid, owner, name, nvt_selector, comment,"
           " family_count, nvt_count, nvts_growing, families_growing,"
           " creation_time, modification_time)"
           " VALUES (" G_STRINGIFY (CONFIG_ID_FULL_AND_FAST) ","
           " '" CONFIG_UUID_FULL_AND_FAST "', NULL, 'Full and fast',"
           " '" MANAGE_NVT_SELECTOR_UUID_ALL "',"
           " 'Most NVT''s; optimized by using previously collected information.',"
           " %i, %i, 1, 1, now (), now ());",
           family_nvt_count (NULL) - family_nvt_count ("Port scanners") + 1,
           family_count ());

      /* Setup preferences for the config. */
      config = sqlite3_last_insert_rowid (task_db);
      setup_full_config_prefs (config, 1, 1, 0);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM configs"
               " WHERE name = 'Full and fast ultimate';")
      == 0)
    {
      config_t config;

      sql ("INSERT into configs (id, uuid, owner, name, nvt_selector, comment,"
           " family_count, nvt_count, nvts_growing, families_growing,"
           " creation_time, modification_time)"
           " VALUES (" G_STRINGIFY (CONFIG_ID_FULL_AND_FAST_ULTIMATE) ","
           " '" CONFIG_UUID_FULL_AND_FAST_ULTIMATE "', NULL,"
           " 'Full and fast ultimate', '" MANAGE_NVT_SELECTOR_UUID_ALL "',"
           " 'Most NVT''s including those that can stop services/hosts;"
           " optimized by using previously collected information.',"
           " %i, %i, 1, 1, now (), now ());",
           family_nvt_count (NULL) - family_nvt_count ("Port scanners") + 1,
           family_count ());

      /* Setup preferences for the config. */
      config = sqlite3_last_insert_rowid (task_db);
      setup_full_config_prefs (config, 0, 1, 0);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM configs"
               " WHERE name = 'Full and very deep';")
      == 0)
    {
      config_t config;

      sql ("INSERT into configs (id, uuid, owner, name, nvt_selector, comment,"
           " family_count, nvt_count, nvts_growing, families_growing,"
           " creation_time, modification_time)"
           " VALUES (" G_STRINGIFY (CONFIG_ID_FULL_AND_VERY_DEEP) ","
           " '" CONFIG_UUID_FULL_AND_VERY_DEEP "', NULL,"
           " 'Full and very deep', '" MANAGE_NVT_SELECTOR_UUID_ALL "',"
           " 'Most NVT''s; don''t trust previously collected information; slow.',"
           " %i, %i, 1, 1, now (), now ());",
           family_nvt_count (NULL) - family_nvt_count ("Port scanners") + 1,
           family_count ());

      /* Setup preferences for the config. */
      config = sqlite3_last_insert_rowid (task_db);
      setup_full_config_prefs (config, 1, 0, 1);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM configs"
               " WHERE name = 'Full and very deep ultimate';")
      == 0)
    {
      config_t config;

      sql ("INSERT into configs (id, uuid, owner, name, nvt_selector, comment,"
           " family_count, nvt_count, nvts_growing, families_growing,"
           " creation_time, modification_time)"
           " VALUES (" G_STRINGIFY (CONFIG_ID_FULL_AND_VERY_DEEP_ULTIMATE) ","
           " '" CONFIG_UUID_FULL_AND_VERY_DEEP_ULTIMATE "',"
           " NULL, 'Full and very deep ultimate',"
           " '" MANAGE_NVT_SELECTOR_UUID_ALL "',"
           " 'Most NVT''s including those that can stop services/hosts;"
           " don''t trust previously collected information; slow.',"
           " %i, %i, 1, 1, now (), now ());",
           family_nvt_count (NULL) - family_nvt_count ("Port scanners") + 1,
           family_count ());

      /* Setup preferences for the config. */
      config = sqlite3_last_insert_rowid (task_db);
      setup_full_config_prefs (config, 0, 0, 1);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM configs"
               " WHERE name = 'empty';")
      == 0)
    {
      config_t config;

      sql ("INSERT into configs (uuid, name, owner, nvt_selector, comment,"
           " family_count, nvt_count, nvts_growing, families_growing,"
           " creation_time, modification_time)"
           " VALUES ('" CONFIG_UUID_EMPTY "', 'empty', NULL, 'empty',"
           " 'Empty and static configuration template.',"
           " 0, 0, 0, 0, now (), now ());");

      /* Setup preferences for the config. */
      config = sqlite3_last_insert_rowid (task_db);
      setup_full_config_prefs (config, 1, 1, 0);
    }

  /* Ensure the predefined port lists exists. */

  ensure_predefined_port_lists_exist ();

  /* Ensure the predefined target exists. */

  if (sql_int (0, 0, "SELECT count(*) FROM targets WHERE name = 'Localhost';")
      == 0)
    sql ("INSERT INTO targets"
         " (uuid, owner, name, hosts, creation_time, modification_time,"
         "  port_range)"
         " VALUES ('" TARGET_UUID_LOCALHOST "', NULL, 'Localhost',"
         " 'localhost', now (), now (),"
         " (SELECT ROWID FROM port_lists WHERE uuid = '" PORT_LIST_UUID_DEFAULT "'));");
  else
    /* The port list was wrong for a while, so make sure it's correct. */
    sql ("UPDATE targets SET port_range = "
         " (SELECT ROWID FROM port_lists"
         "  WHERE uuid = '" PORT_LIST_UUID_DEFAULT "')"
         " WHERE uuid = '" TARGET_UUID_LOCALHOST "';");

  /* Ensure the predefined example task and report exists. */

  if (sql_int (0, 0,
               "SELECT count(*) FROM tasks"
               " WHERE uuid = '" MANAGE_EXAMPLE_TASK_UUID "';")
      == 0)
    {
      sql ("INSERT into tasks (uuid, owner, name, hidden, comment,"
           " run_status, start_time, end_time, config, target, slave,"
           " creation_time, modification_time)"
           " VALUES ('" MANAGE_EXAMPLE_TASK_UUID "', NULL, 'Example task',"
           " 1, 'This is an example task for the help pages.', %u,"
           " 1251236905, 1251237136,"
           " (SELECT ROWID FROM configs WHERE name = 'Full and fast'),"
           " (SELECT ROWID FROM targets WHERE name = 'Localhost'),"
           " 0, now (), now ());",
           TASK_STATUS_DONE);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM reports"
               " WHERE uuid = '343435d6-91b0-11de-9478-ffd71f4c6f30';")
      == 0)
    {
      task_t task;
      result_t result;
      report_t report;

      /* Setup a dummy user, so that find_task will work. */
      current_credentials.uuid = "";

      if (find_task (MANAGE_EXAMPLE_TASK_UUID, &task))
        g_warning ("%s: error while finding example task", __FUNCTION__);
      else if (task == 0)
        g_warning ("%s: failed to find example task", __FUNCTION__);
      else
        {
          sql ("INSERT into reports (uuid, owner, hidden, task, comment,"
               " start_time, end_time, scan_run_status, slave_progress,"
               " slave_task_uuid, highs, override_highs)"
               " VALUES ('343435d6-91b0-11de-9478-ffd71f4c6f30', NULL, 1, %llu,"
               " 'This is an example report for the help pages.',"
               " 1251236905, 1251237136,"
               " %u, 0, '', -1, -1);",
               task,
               TASK_STATUS_DONE);
          report = sqlite3_last_insert_rowid (task_db);
          sql ("INSERT into results (uuid, task, subnet, host, port, nvt, type,"
               " description)"
               " VALUES ('cb291ec0-1b0d-11df-8aa1-002264764cea', %llu, '',"
               " '127.0.0.1', 'telnet (23/tcp)',"
               " '1.3.6.1.4.1.25623.1.0.10330', 'Security Note',"
               " 'A telnet server seems to be running on this port');",
               task);
          result = sqlite3_last_insert_rowid (task_db);
          report_add_result (report, result);
          sql ("INSERT into report_hosts (report, host, start_time, end_time)"
               " VALUES (%llu, '127.0.0.1', 1251236906, 1251237135)",
               report);
        }

      current_credentials.uuid = NULL;
    }

  /* Bring report format UUIDs in database up to date. */

  update_report_format_uuids ();

  /* Ensure the predefined report formats exist. */

  if (sql_int (0, 0,
               "SELECT count(*) FROM report_formats"
               " WHERE uuid = '910200ca-dc05-11e1-954f-406186ea4fc5';")
      == 0)
    {
      report_format_t report_format;
      sql ("INSERT into report_formats (uuid, owner, name, summary, description,"
           " extension, content_type, signature, trust, trust_time, flags,"
           " creation_time, modification_time)"
           " VALUES ('910200ca-dc05-11e1-954f-406186ea4fc5', NULL, 'ARF',"
           " 'Asset Reporting Format v1.0.0.',"
           " 'NIST Asset Reporting Format 1.1 compliant document.\n',"
           " 'xml', 'text/xml', '', %i, %i, 1, now (), now ());",
           TRUST_YES,
           time (NULL));
      report_format = sqlite3_last_insert_rowid (task_db);
      verify_report_format (report_format);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM report_formats"
               " WHERE uuid = '5ceff8ba-1f62-11e1-ab9f-406186ea4fc5';")
      == 0)
    {
      report_format_t report_format;
      sql ("INSERT into report_formats (uuid, owner, name, summary, description,"
           " extension, content_type, signature, trust, trust_time, flags,"
           " creation_time, modification_time)"
           " VALUES ('5ceff8ba-1f62-11e1-ab9f-406186ea4fc5', NULL, 'CPE',"
           " 'Common Product Enumeration CSV table.',"
           " 'CPE stands for Common Product Enumeration.  It is a structured naming scheme for\n"
           "information technology systems, platforms, and packages.  In other words: CPE\n"
           "provides a unique identifier for virtually any software product that is known for\n"
           "a vulnerability.\n"
           "\n"
           "The CPE dictionary is maintained by MITRE and NIST.  MITRE also maintains CVE\n"
           "(Common Vulnerability Enumeration) and other relevant security standards.\n"
           "\n"
           "The report selects all CPE tables from the results and forms a single table\n"
           "as a comma separated values file.\n',"
           " 'csv', 'text/csv', '', %i, %i, 1, now (), now ());",
           TRUST_YES,
           time (NULL));
      report_format = sqlite3_last_insert_rowid (task_db);
      verify_report_format (report_format);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM report_formats"
               " WHERE uuid = '6c248850-1f62-11e1-b082-406186ea4fc5';")
      == 0)
    {
      report_format_t report_format;
      sql ("INSERT into report_formats (uuid, owner, name, summary, description,"
           " extension, content_type, signature, trust, trust_time, flags,"
           " creation_time, modification_time)"
           " VALUES ('6c248850-1f62-11e1-b082-406186ea4fc5', NULL, 'HTML',"
           " 'Single page HTML report.',"
           " 'A single HTML page listing results of a scan.  Style information is embedded in\n"
           "the HTML, so the page is suitable for viewing in a browser as is.\n',"
           " 'html', 'text/html', '', %i, %i, 1, now (), now ());",
           TRUST_YES,
           time (NULL));
      report_format = sqlite3_last_insert_rowid (task_db);
      verify_report_format (report_format);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM report_formats"
               " WHERE uuid = '77bd6c4a-1f62-11e1-abf0-406186ea4fc5';")
      == 0)
    {
      report_format_t report_format;
      sql ("INSERT into report_formats (uuid, owner, name, summary, description,"
           " extension, content_type, signature, trust, trust_time, flags,"
           " creation_time, modification_time)"
           " VALUES ('77bd6c4a-1f62-11e1-abf0-406186ea4fc5', NULL, 'ITG',"
           " 'German \"IT-Grundschutz-Kataloge\" report.',"
           " 'Tabular report on the German \"IT-Grundschutz-Kataloge\",\n"
           "as published and maintained by the German Federal Agency for IT-Security.\n',"
           " 'csv', 'text/csv', '', %i, %i, 1, now (), now ());",
           TRUST_YES,
           time (NULL));
      report_format = sqlite3_last_insert_rowid (task_db);
      verify_report_format (report_format);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM report_formats"
               " WHERE uuid = 'a684c02c-b531-11e1-bdc2-406186ea4fc5';")
      == 0)
    {
      report_format_t report_format;
      sql ("INSERT into report_formats (uuid, owner, name, summary, description,"
           " extension, content_type, signature, trust, trust_time, flags,"
           " creation_time, modification_time)"
           " VALUES ('a684c02c-b531-11e1-bdc2-406186ea4fc5', NULL, 'LaTeX',"
           " 'LaTeX source file.',"
           " 'Report as LaTeX source file for further processing.\n',"
           " 'tex', 'text/plain', '', %i, %i, 1, now (), now ());",
           TRUST_YES,
           time (NULL));
      report_format = sqlite3_last_insert_rowid (task_db);
      verify_report_format (report_format);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM report_formats"
               " WHERE uuid = '9ca6fe72-1f62-11e1-9e7c-406186ea4fc5';")
      == 0)
    {
      report_format_t report_format;
      sql ("INSERT into report_formats (uuid, owner, name, summary, description,"
           " extension, content_type, signature, trust, trust_time, flags,"
           " creation_time, modification_time)"
           " VALUES ('9ca6fe72-1f62-11e1-9e7c-406186ea4fc5', NULL, 'NBE',"
           " 'Legacy OpenVAS report.',"
           " 'The traditional OpenVAS Scanner text based format.',"
           " 'nbe', 'text/plain', '', %i, %i, 1, now (), now ());",
           TRUST_YES,
           time (NULL));
      report_format = sqlite3_last_insert_rowid (task_db);
      verify_report_format (report_format);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM report_formats"
               " WHERE uuid = 'c402cc3e-b531-11e1-9163-406186ea4fc5';")
      == 0)
    {
      report_format_t report_format;
      sql ("INSERT into report_formats (uuid, owner, name, summary, description,"
           " extension, content_type, signature, trust, trust_time, flags,"
           " creation_time, modification_time)"
           " VALUES ('c402cc3e-b531-11e1-9163-406186ea4fc5', NULL, 'PDF',"
           " 'Portable Document Format report.',"
           " 'Scan results in Portable Document Format (PDF).',"
           "'pdf', 'application/pdf', '', %i, %i, 1, now (), now ());",
           TRUST_YES,
           time (NULL));
      report_format = sqlite3_last_insert_rowid (task_db);
      verify_report_format (report_format);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM report_formats"
               " WHERE uuid = 'a3810a62-1f62-11e1-9219-406186ea4fc5';")
      == 0)
    {
      report_format_t report_format;
      sql ("INSERT into report_formats (uuid, owner, name, summary, description,"
           " extension, content_type, signature, trust, trust_time, flags,"
           " creation_time, modification_time)"
           " VALUES ('a3810a62-1f62-11e1-9219-406186ea4fc5', NULL, 'TXT',"
           " 'Plain text report.',"
           " 'Plain text report, best viewed with fixed font size.',"
           " 'txt', 'text/plain', '', %i, %i, 1, now (), now ());",
           TRUST_YES,
           time (NULL));
      report_format = sqlite3_last_insert_rowid (task_db);
      verify_report_format (report_format);
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM report_formats"
               " WHERE uuid = 'a994b278-1f62-11e1-96ac-406186ea4fc5';")
      == 0)
    {
      report_format_t report_format;
      sql ("INSERT into report_formats (uuid, owner, name, summary, description,"
           " extension, content_type, signature, trust, trust_time, flags,"
           " creation_time, modification_time)"
           " VALUES ('a994b278-1f62-11e1-96ac-406186ea4fc5', NULL, 'XML',"
           " 'Raw XML report.',"
           " 'Complete scan report in OpenVAS Manager XML format.',"
           " 'xml', 'text/xml', '', %i, %i, 1, now (), now ());",
           TRUST_YES,
           time (NULL));
      report_format = sqlite3_last_insert_rowid (task_db);
      verify_report_format (report_format);
    }

  /* Ensure that the report formats trash directory matches the database. */

  {
    gchar *dir;
    GError *error;
    GDir *directory;
    const gchar *entry;

    dir = g_build_filename (OPENVAS_DATA_DIR,
                            "openvasmd",
                            "report_formats_trash",
                            NULL);
    error = NULL;
    directory = g_dir_open (dir, 0, &error);

    if (directory == NULL)
      {
        assert (error);
        if (!g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_NOENT))
          {
            g_warning ("g_dir_open (%s) failed - %s\n",
                       dir,
                       error->message);
            g_error_free (error);
            g_free (dir);
            return -1;
          }
      }
    else
      {
        entry = NULL;
        while ((entry = g_dir_read_name (directory)) != NULL)
          {
            gchar *end;
            if (strtol (entry, &end, 10) < 0)
              /* Only interested in positive numbers. */
              continue;
            if (*end != '\0')
              /* Only interested in numbers. */
              continue;

            /* Check whether the db has a report format with this ID. */

            if (sql_int (0, 0,
                         "SELECT count(*) FROM report_formats_trash"
                         " WHERE ROWID = %s;",
                         entry)
                == 0)
              {
                int ret;
                gchar *entry_path;

                /* Remove the directory. */

                entry_path = g_build_filename (dir, entry, NULL);
                ret = openvas_file_remove_recurse (entry_path);
                g_free (entry_path);
                if (ret)
                  {
                    g_warning ("%s: failed to remove %s from %s",
                               __FUNCTION__, entry, dir);
                    g_dir_close (directory);
                    g_free (dir);
                    return -1;
                  }
              }
          }
        g_dir_close (directory);
      }
    g_free (dir);
  }

  /* Ensure the default settings exist. */

  if (sql_int (0, 0,
               "SELECT count(*) FROM settings"
               " WHERE uuid = '5f5a8712-8017-11e1-8556-406186ea4fc5'"
               " AND owner IS NULL;")
      == 0)
    sql ("INSERT into settings (uuid, owner, name, comment, value)"
         " VALUES"
         " ('5f5a8712-8017-11e1-8556-406186ea4fc5', NULL, 'Rows Per Page',"
         "  'The default number of rows displayed in any listing.',"
         "  10);");

  if (sql_int (0, 0,
               "SELECT count(*) FROM settings"
               " WHERE uuid = '20f3034c-e709-11e1-87e7-406186ea4fc5'"
               " AND owner IS NULL;")
      == 0)
    sql ("INSERT into settings (uuid, owner, name, comment, value)"
         " VALUES"
         " ('20f3034c-e709-11e1-87e7-406186ea4fc5', NULL, 'Wizard Rows',"
         "  'If the number of rows in a listing is above this any wizard"
         " be hidden.',"
         "  3);");

  if (nvt_cache_mode == 0)
    {
      iterator_t tasks;
      get_data_t get;

      /* Set requested, paused and running tasks to stopped. */

      assert (current_credentials.uuid == NULL);
      memset (&get, '\0', sizeof (get));
      init_task_iterator (&tasks, &get);
      while (next (&tasks))
        {
          switch (task_iterator_run_status (&tasks))
            {
              case TASK_STATUS_DELETE_REQUESTED:
              case TASK_STATUS_DELETE_ULTIMATE_REQUESTED:
              case TASK_STATUS_DELETE_ULTIMATE_WAITING:
              case TASK_STATUS_DELETE_WAITING:
              case TASK_STATUS_PAUSE_REQUESTED:
              case TASK_STATUS_PAUSE_WAITING:
              case TASK_STATUS_PAUSED:
              case TASK_STATUS_REQUESTED:
              case TASK_STATUS_RESUME_REQUESTED:
              case TASK_STATUS_RESUME_WAITING:
              case TASK_STATUS_RUNNING:
              case TASK_STATUS_STOP_REQUESTED_GIVEUP:
              case TASK_STATUS_STOP_REQUESTED:
              case TASK_STATUS_STOP_WAITING:
                {
                  task_t index = get_iterator_resource (&tasks);
                  /* Set the current user, for event checks. */
                  current_credentials.uuid = task_owner_uuid (index);
                  set_task_run_status (index, TASK_STATUS_STOPPED);
                  free (current_credentials.uuid);
                  break;
                }
              default:
                break;
            }
        }
      cleanup_iterator (&tasks);
      current_credentials.uuid = NULL;

      /* Set requested and running reports to stopped. */

      sql ("UPDATE reports SET scan_run_status = %u"
           " WHERE scan_run_status = %u"
           " OR scan_run_status = %u"
           " OR scan_run_status = %u"
           " OR scan_run_status = %u"
           " OR scan_run_status = %u"
           " OR scan_run_status = %u"
           " OR scan_run_status = %u"
           " OR scan_run_status = %u"
           " OR scan_run_status = %u"
           " OR scan_run_status = %u"
           " OR scan_run_status = %u"
           " OR scan_run_status = %u"
           " OR scan_run_status = %u"
           " OR scan_run_status = %u;",
           TASK_STATUS_STOPPED,
           TASK_STATUS_DELETE_REQUESTED,
           TASK_STATUS_DELETE_ULTIMATE_REQUESTED,
           TASK_STATUS_DELETE_ULTIMATE_WAITING,
           TASK_STATUS_DELETE_WAITING,
           TASK_STATUS_PAUSE_REQUESTED,
           TASK_STATUS_PAUSE_WAITING,
           TASK_STATUS_PAUSED,
           TASK_STATUS_REQUESTED,
           TASK_STATUS_RESUME_REQUESTED,
           TASK_STATUS_RESUME_WAITING,
           TASK_STATUS_RUNNING,
           TASK_STATUS_STOP_REQUESTED,
           TASK_STATUS_STOP_REQUESTED_GIVEUP,
           TASK_STATUS_STOP_WAITING);
    }

  /* Load the NVT cache into memory. */

  if (nvti_cache == NULL)
    update_nvti_cache ();

  sqlite3_close (task_db);
  task_db = NULL;
  task_db_name = g_strdup (database);
  return 0;
}

/**
 * @brief Cleanup the manage library.
 *
 * Optionally put any running task in the stopped state and close the database.
 *
 * @param[in]  cleanup  If TRUE perform all cleanup operations, else only
 *                      those required at the start of a forked process.
 */
void
cleanup_manage_process (gboolean cleanup)
{
  if (task_db)
    {
      if (cleanup)
        {
          if (current_scanner_task)
            set_task_run_status (current_scanner_task, TASK_STATUS_STOPPED);
          if (sqlite3_close (task_db) == SQLITE_BUSY)
            /* Richard Hipp on how to find the open statements:
             *
             * There is no published way to do this.  If you run in a debugger,
             * you can look at the linked list of "struct Vdbe" objects that
             * sqlite3.pVdbe points to.  This is the list of open statements
             * in the current implementation (and subject to change without
             * notice). */
            g_warning ("%s: attempt to close db with open statement(s)\n",
                       __FUNCTION__);
        }
      task_db = NULL;
    }
}

/**
 * @brief Cleanup as immediately as possible.
 *
 * Put any running task in the error state and close the database.
 *
 * Intended for handlers for signals like SIGSEGV and SIGABRT.
 *
 * @param[in]  signal  Dummy argument for use as signal handler.
 */
void
manage_cleanup_process_error (/*@unused@*/ int signal)
{
  if (task_db)
    {
      if (current_scanner_task)
        set_task_run_status (current_scanner_task, TASK_STATUS_INTERNAL_ERROR);
      sqlite3_close (task_db);
      task_db = NULL;
    }
}

/**
 * @brief Authenticate credentials.
 *
 * The user "om" will never be authenticated with success.
 *
 * @param[in]  credentials  Credentials.
 *
 * @return 0 authentication success, 1 authentication failure, -1 error.
 */
int
authenticate (credentials_t* credentials)
{
  if (credentials->username && credentials->password)
    {
      int fail;

      if (strcmp (credentials->username, "om") == 0) return 1;

      if (authenticate_allow_all)
        {
          /* This flag is set for scheduled tasks only. Take the stored uuid
           * to be able to tell apart locally authenticated vs remotely
           * authenticated users (in order to fetch the correct rules). */
          credentials->uuid = get_scheduled_user_uuid ();
          if (*credentials->uuid)
            return 0;
          return -1;
        }

      fail = openvas_authenticate_uuid (credentials->username,
                                        credentials->password,
                                        &credentials->uuid);
      // Authentication succeeded.
      if (fail == 0)
        {
          gchar* quoted_name;

          credentials->role
            = g_strdup (openvas_is_user_admin (credentials->username)
                         ? "Admin"
                         : (openvas_is_user_observer (credentials->username)
                             ? "Observer"
                             : "User"));

          /* Ensure the user exists in the database.  SELECT then INSERT
           * instead of using "INSERT OR REPLACE", so that the ROWID stays
           * the same. */

          if (sql_int (0, 0,
                       "SELECT count(*) FROM users WHERE uuid = '%s';",
                       credentials->uuid))
            {
              credentials->timezone = sql_string (0, 0,
                                                  "SELECT timezone FROM users"
                                                  " WHERE uuid = '%s';",
                                                  credentials->uuid);
              return 0;
            }

          quoted_name = sql_quote (credentials->username);
          sql ("INSERT INTO users (uuid, name, timezone)"
               " VALUES ('%s', '%s', NULL);",
               credentials->uuid,
               quoted_name);
          g_free (quoted_name);
          credentials->timezone = NULL;
          return 0;
        }
      return fail;
    }
  return 1;
}

/**
 * @brief Return number of resources of a certain type for current user.
 *
 * @param[in]  type  Type.
 * @param[in]  get   GET params.
 *
 * @return The number of resources associated with the current user.
 */
int
resource_count (const char *type, const get_data_t *get)
{
  get_data_t count_get;

  memset (&count_get, '\0', sizeof (count_get));
  count_get.trash = get->trash;
  count_get.filter = "rows=-1 first=1";
  count_get.actions = "g";

  return count (get->subtype ? get->subtype : type,
                &count_get, "1", NULL, 0, NULL,
                strcmp (type, "task")
                 ? NULL
                 : (get->id
                    && (strcmp (get->id, MANAGE_EXAMPLE_TASK_UUID)
                        == 0))
                    ? " AND hidden = 1"
                    : (get->trash
                        ? " AND hidden = 2"
                        : " AND hidden = 0"),
                type_owned (type));
}

/**
 * @brief Return the number of tasks associated with the current user.
 *
 * @param[in]  get  GET params.
 *
 * @return The number of tasks associated with the current user.
 */
unsigned int
task_count (const get_data_t *get)
{
  static const char *extra_columns[] = TASK_ITERATOR_FILTER_COLUMNS;
  char *filter;
  gchar *value;
  int overrides;

  if (get->filt_id && strcmp (get->filt_id, "0"))
    {
      filter = filter_term (get->filt_id);
      if (filter == NULL)
        return 2;
    }
  else
    filter = NULL;
  value = filter_term_value (filter ? filter : get->filter, "apply_overrides");
  free (filter);
  overrides = value && strcmp (value, "0");
  g_free (value);

  return count ("task", get,
                overrides
                 ? TASK_ITERATOR_COLUMNS ("1")
                 : TASK_ITERATOR_COLUMNS ("0"),
                extra_columns, 0, NULL,
                (get->id
                 && (strcmp (get->id, MANAGE_EXAMPLE_TASK_UUID)
                     == 0))
                 ? " AND hidden = 1"
                 : (get->trash
                     ? " AND hidden = 2"
                     : " AND hidden = 0"),
                TRUE);
}

/**
 * @brief Return the number of trash tasks associated with the current user.
 *
 * @return The number of trash tasks associated with the current user.
 */
unsigned int
trash_task_count ()
{
  return (unsigned int) sql_int (0, 0,
                                 "SELECT count(*) FROM tasks WHERE owner ="
                                 " (SELECT ROWID FROM users"
                                 "  WHERE users.uuid = '%s')"
                                 " AND hidden = 2;",
                                 current_credentials.uuid);
}

/**
 * @brief Return the identifier of a task.
 *
 * @param[in]  task  Task.
 *
 * @return ID of task.
 */
unsigned int
task_id (task_t task)
{
  /** @todo The cast is a hack for compatibility with the old, alternate,
   *        FS based storage mechanism. */
  return (unsigned int) task;
}

/**
 * @brief Return the UUID of a task.
 *
 * @param[in]   task  Task.
 * @param[out]  id    Pointer to a newly allocated string.
 *
 * @return 0.
 */
int
task_uuid (task_t task, char ** id)
{
  *id = sql_string (0, 0,
                    "SELECT uuid FROM tasks WHERE ROWID = %llu;",
                    task);
  return 0;
}

/**
 * @brief Return whether a task is in the trashcan.
 *
 * @param[in]  task  Task.
 *
 * @return 1 if in trashcan, else 0.
 */
int
task_in_trash (task_t task)
{
  return sql_int (0, 0,
                  "SELECT hidden = 2"
                  " FROM tasks WHERE ROWID = %llu;",
                  task);
}

/**
 * @brief Return the name of the owner of a task.
 *
 * @param[in]  task  Task.
 *
 * @return Newly allocated user name.
 */
char*
task_owner_name (task_t task)
{
  return sql_string (0, 0,
                     "SELECT name FROM users WHERE ROWID ="
                     " (SELECT owner FROM tasks WHERE ROWID = %llu);",
                     task);
}

/**
 * @brief Return the name of the owner of a task.
 *
 * @param[in]  task  Task.
 *
 * @return Newly allocated user name.
 */
static char*
task_owner_uuid (task_t task)
{
  return sql_string (0, 0,
                     "SELECT uuid FROM users WHERE ROWID ="
                     " (SELECT owner FROM tasks WHERE ROWID = %llu);",
                     task);
}

/**
 * @brief Return the name of a task.
 *
 * @param[in]  task  Task.
 *
 * @return Task name.
 */
char*
task_name (task_t task)
{
  return sql_string (0, 0,
                     "SELECT name FROM tasks WHERE ROWID = %llu;",
                     task);
}

/**
 * @brief Return the comment of a task.
 *
 * @param[in]  task  Task.
 *
 * @return Comment of task.
 */
char*
task_comment (task_t task)
{
  return sql_string (0, 0,
                     "SELECT comment FROM tasks WHERE ROWID = %llu;",
                     task);
}

/**
 * @brief Return the observers of a task.
 *
 * @param[in]  task  Task.
 *
 * @return Observers of task.
 */
char*
task_observers (task_t task)
{
  iterator_t users;
  GString *observers;

  observers = g_string_new ("");

  init_task_user_iterator (&users, task, MANAGE_ACTION_GET);
  if (next (&users))
    {
      g_string_append (observers, task_user_iterator_name (&users));
      while (next (&users))
        g_string_append_printf (observers,
                                " %s",
                                task_user_iterator_name (&users));
    }
  cleanup_iterator (&users);

  return observers->str;
}

/**
 * @brief Return the config of a task.
 *
 * @param[in]  task  Task.
 *
 * @return Config of task.
 */
config_t
task_config (task_t task)
{
  config_t config;
  switch (sql_int64 (&config, 0, 0,
                     "SELECT config FROM tasks WHERE ROWID = %llu;",
                     task))
    {
      case 0:
        return config;
      default:       /* Programming error. */
      case 1:        /* Too few rows in result of query. */
      case -1:       /* Error. */
        /* Every task should have a config. */
        assert (0);
        return 0;
        break;
    }
}

/**
 * @brief Return the UUID of the config of a task.
 *
 * @param[in]  task  Task.
 *
 * @return UUID of config of task.
 */
char*
task_config_uuid (task_t task)
{
  if (task_config_in_trash (task))
    return sql_string (0, 0,
                       "SELECT uuid FROM configs_trash WHERE ROWID ="
                       " (SELECT config FROM tasks WHERE ROWID = %llu);",
                       task);
  return sql_string (0, 0,
                     "SELECT uuid FROM configs WHERE ROWID ="
                     " (SELECT config FROM tasks WHERE ROWID = %llu);",
                     task);
}

/**
 * @brief Return the name of the config of a task.
 *
 * @param[in]  task  Task.
 *
 * @return Name of config of task.
 */
char*
task_config_name (task_t task)
{
  if (task_config_in_trash (task))
    return sql_string (0, 0,
                       "SELECT name FROM configs_trash WHERE ROWID ="
                       " (SELECT config FROM tasks WHERE ROWID = %llu);",
                       task);
  return sql_string (0, 0,
                     "SELECT name FROM configs WHERE ROWID ="
                     " (SELECT config FROM tasks WHERE ROWID = %llu);",
                     task);
}

/**
 * @brief Return whether the config of a task is in the trashcan.
 *
 * @param[in]  task  Task.
 *
 * @return 1 if in trashcan, else 0.
 */
int
task_config_in_trash (task_t task)
{
  return sql_int (0, 0,
                  "SELECT config_location = " G_STRINGIFY (LOCATION_TRASH)
                  " FROM tasks WHERE ROWID = %llu;",
                  task);
}

/**
 * @brief Set the config of a task.
 *
 * @param[in]  task    Task.
 * @param[in]  config  Config.
 */
void
set_task_config (task_t task, config_t config)
{
  sql ("UPDATE tasks SET config = %llu, modification_time = now ()"
       "WHERE ROWID = %llu;",
       config,
       task);
}

/**
 * @brief Return the target of a task.
 *
 * @param[in]  task  Task.
 *
 * @return Target of task.
 */
target_t
task_target (task_t task)
{
  target_t target = 0;
  switch (sql_int64 (&target, 0, 0,
                     "SELECT target FROM tasks WHERE ROWID = %llu;",
                     task))
    {
      case 0:
        return target;
        break;
      case 1:        /* Too few rows in result of query. */
      default:       /* Programming error. */
        assert (0);
      case -1:
        return 0;
        break;
    }
}

/**
 * @brief Set the target of a task.
 *
 * @param[in]  task    Task.
 * @param[in]  target  Target.
 */
void
set_task_target (task_t task, target_t target)
{
  sql ("UPDATE tasks SET target = %llu, modification_time = now ()"
       " WHERE ROWID = %llu;",
       target,
       task);
}

/**
 * @brief Return whether the target of a task is in the trashcan.
 *
 * @param[in]  task  Task.
 *
 * @return 1 if in trash, else 0.
 */
int
task_target_in_trash (task_t task)
{
  return sql_int (0, 0,
                  "SELECT target_location = " G_STRINGIFY (LOCATION_TRASH)
                  " FROM tasks WHERE ROWID = %llu;",
                  task);
}


/**
 * @brief Return the slave of a task.
 *
 * @param[in]  task  Task.
 *
 * @return Slave of task.
 */
slave_t
task_slave (task_t task)
{
  slave_t slave = 0;
  switch (sql_int64 (&slave, 0, 0,
                     "SELECT slave FROM tasks WHERE ROWID = %llu;",
                     task))
    {
      case 0:
        return slave;
        break;
      case 1:        /* Too few rows in result of query. */
      default:       /* Programming error. */
        assert (0);
      case -1:
        return 0;
        break;
    }
}

/**
 * @brief Set the slave of a task.
 *
 * @param[in]  task   Task.
 * @param[in]  slave  Slave.
 */
void
set_task_slave (task_t task, slave_t slave)
{
  sql ("UPDATE tasks SET slave = %llu, modification_time = now ()"
       " WHERE ROWID = %llu;",
       slave,
       task);
}

/**
 * @brief Return whether the slave of a task is in the trashcan.
 *
 * @param[in]  task  Task.
 *
 * @return 1 if in trash, else 0.
 */
int
task_slave_in_trash (task_t task)
{
  return sql_int (0, 0,
                  "SELECT slave_location = " G_STRINGIFY (LOCATION_TRASH)
                  " FROM tasks WHERE ROWID = %llu;",
                  task);
}

/**
 * @brief Return the description of a task.
 *
 * @param[in]  task  Task.
 *
 * @return Description of task.
 */
char*
task_description (task_t task)
{
  return sql_string (0, 0,
                     "SELECT description FROM tasks WHERE ROWID = %llu;",
                     task);
}

/**
 * @brief Set the description of a task.
 *
 * @param[in]  task         Task.
 * @param[in]  description  Description.  Used directly, freed by free_task.
 * @param[in]  length       Length of description.
 */
void
set_task_description (task_t task, char* description, gsize length)
{
  gchar* quote = sql_nquote (description, strlen (description));
  sql ("UPDATE tasks SET description = '%s', modification_time = now ()"
       " WHERE ROWID = %llu;",
       quote,
       task);
  g_free (quote);
}

/**
 * @brief Return the run state of a task.
 *
 * @param[in]  task  Task.
 *
 * @return Task run status.
 */
task_status_t
task_run_status (task_t task)
{
  return (unsigned int) sql_int (0, 0,
                                 "SELECT run_status FROM tasks WHERE ROWID = %llu;",
                                 task);
}

/**
 * @brief Set the run state of a task.
 *
 * @param[in]  task    Task.
 * @param[in]  status  New run status.
 */
void
set_task_run_status (task_t task, task_status_t status)
{
  char *uuid;
  char *name;

  if ((task == current_scanner_task) && current_report)
    sql ("UPDATE reports SET scan_run_status = %u WHERE ROWID = %llu;",
         status,
         current_report);
  sql ("UPDATE tasks SET run_status = %u WHERE ROWID = %llu;",
       status,
       task);

  task_uuid (task, &uuid);
  name = task_name (task);
  g_log ("event task", G_LOG_LEVEL_MESSAGE,
         "Status of task %s (%s) has changed to %s",
         name, uuid, run_status_name (status));
  free (uuid);
  free (name);

  event (task, EVENT_TASK_RUN_STATUS_CHANGED, (void*) status);
}

/**
 * @brief Atomically set the run state of a task to requested.
 *
 * @param[in]  task    Task.
 * @param[out] status  Old run status of task.
 *
 * @return 0 success, 1 task is active already.
 */
int
set_task_requested (task_t task, task_status_t *status)
{
  task_status_t run_status;

  sql ("BEGIN EXCLUSIVE;");

  run_status = task_run_status (task);
  if (run_status == TASK_STATUS_REQUESTED
      || run_status == TASK_STATUS_RUNNING
      || run_status == TASK_STATUS_PAUSE_REQUESTED
      || run_status == TASK_STATUS_PAUSE_WAITING
      || run_status == TASK_STATUS_PAUSED
      || run_status == TASK_STATUS_RESUME_REQUESTED
      || run_status == TASK_STATUS_RESUME_WAITING
      || run_status == TASK_STATUS_STOP_REQUESTED
      || run_status == TASK_STATUS_STOP_REQUESTED_GIVEUP
      || run_status == TASK_STATUS_STOP_WAITING
      || run_status == TASK_STATUS_DELETE_REQUESTED
      || run_status == TASK_STATUS_DELETE_ULTIMATE_REQUESTED
      || run_status == TASK_STATUS_DELETE_ULTIMATE_WAITING
      || run_status == TASK_STATUS_DELETE_WAITING)
    {
      sql ("END;");
      *status = run_status;
      return 1;
    }

  set_task_run_status (task, TASK_STATUS_REQUESTED);

  sql ("COMMIT;");

  *status = run_status;
  return 0;
}

/**
 * @brief Return the running report of a task.
 *
 * @param[in]  task  Task.
 *
 * @return Current report of task if task is active, else (report_t) 0.
 */
report_t
task_running_report (task_t task)
{
  task_status_t run_status = task_run_status (task);
  if (run_status == TASK_STATUS_REQUESTED
      || run_status == TASK_STATUS_RUNNING)
    {
      return (unsigned int) sql_int (0, 0,
                                     "SELECT max(ROWID) FROM reports"
                                     " WHERE task = %llu AND end_time IS NULL"
                                     " AND scan_run_status = %u;",
                                     task,
                                     TASK_STATUS_RUNNING);
    }
  return (report_t) 0;
}

/**
 * @brief Return the current report of a task.
 *
 * @param[in]  task  Task.
 *
 * @return Current report of task if task is active, else (report_t) 0.
 */
report_t
task_current_report (task_t task)
{
  task_status_t run_status = task_run_status (task);
  if (run_status == TASK_STATUS_REQUESTED
      || run_status == TASK_STATUS_RUNNING
      || run_status == TASK_STATUS_DELETE_REQUESTED
      || run_status == TASK_STATUS_DELETE_ULTIMATE_REQUESTED
      || run_status == TASK_STATUS_STOP_REQUESTED
      || run_status == TASK_STATUS_STOP_REQUESTED_GIVEUP
      || run_status == TASK_STATUS_STOPPED
      || run_status == TASK_STATUS_PAUSE_REQUESTED
      || run_status == TASK_STATUS_PAUSED
      || run_status == TASK_STATUS_RESUME_REQUESTED)
    {
      return (unsigned int) sql_int (0, 0,
                                     "SELECT max(ROWID) FROM reports"
                                     " WHERE task = %llu"
                                     " AND (scan_run_status = %u"
                                     " OR scan_run_status = %u"
                                     " OR scan_run_status = %u"
                                     " OR scan_run_status = %u"
                                     " OR scan_run_status = %u"
                                     " OR scan_run_status = %u"
                                     " OR scan_run_status = %u"
                                     " OR scan_run_status = %u"
                                     " OR scan_run_status = %u"
                                     " OR scan_run_status = %u);",
                                     task,
                                     TASK_STATUS_REQUESTED,
                                     TASK_STATUS_RUNNING,
                                     TASK_STATUS_DELETE_REQUESTED,
                                     TASK_STATUS_DELETE_ULTIMATE_REQUESTED,
                                     TASK_STATUS_STOP_REQUESTED,
                                     TASK_STATUS_STOP_REQUESTED_GIVEUP,
                                     TASK_STATUS_STOPPED,
                                     TASK_STATUS_PAUSE_REQUESTED,
                                     TASK_STATUS_PAUSED,
                                     TASK_STATUS_RESUME_REQUESTED);
    }
  return (report_t) 0;
}

/**
 * @brief Return the upload progress of a task.
 *
 * @param[in]  task  Task.
 *
 * @return Task upload progress, as a percentage, or -1 on error.
 */
int
task_upload_progress (task_t task)
{
  report_t report;
  report = task_running_report (task);
  if (report)
    {
      int count;
      if (report_scan_result_count (report, NULL, NULL, 0, NULL, 0, 0, &count))
        return -1;
      return sql_int (0, 0,
                      "SELECT"
                      " max (min (((%i * 100) / upload_result_count), 100), -1)"
                      " FROM tasks"
                      " WHERE ROWID = %llu;",
                      count,
                      task);
    }
  return -1;
}

/**
 * @brief Return the most recent start time of a task.
 *
 * @param[in]  task  Task.
 *
 * @return Task start time.
 */
char*
task_start_time (task_t task)
{
  return sql_string (0, 0,
                     "SELECT iso_time (start_time)"
                     " FROM tasks WHERE ROWID = %llu;",
                     task);
}

/**
 * @brief Set the start time of a task.
 *
 * @param[in]  task  Task.
 * @param[in]  time  New time.  ISO format.  Freed before return.
 */
void
set_task_start_time (task_t task, char* time)
{
  sql ("UPDATE tasks SET start_time = %i, modification_time = now ()"
       " WHERE ROWID = %llu;",
       parse_iso_time (time),
       task);
  free (time);
}

/**
 * @brief Set the start time of a task.
 *
 * @param[in]  task  Task.
 * @param[in]  time  New time.  OTP format (ctime).  Freed before return.
 */
void
set_task_start_time_otp (task_t task, char* time)
{
  sql ("UPDATE tasks SET start_time = %i, modification_time = now ()"
       " WHERE ROWID = %llu;",
       parse_otp_time (time),
       task);
  free (time);
}

/**
 * @brief Return the most recent end time of a task.
 *
 * @param[in]  task  Task.
 *
 * @return Task end time.
 */
char*
task_end_time (task_t task)
{
  return sql_string (0, 0,
                     "SELECT end_time FROM tasks WHERE ROWID = %llu;",
                     task);
}

/**
 * @brief Get the report from the most recently completed invocation of task.
 *
 * @param[in]  task    The task.
 * @param[out] report  Report return, 0 if succesfully failed to select report.
 *
 * @return 0 success, -1 error.
 */
int
task_last_report (task_t task, report_t *report)
{
  switch (sql_int64 (report, 0, 0,
                     "SELECT ROWID FROM reports WHERE task = %llu"
                     " AND scan_run_status = %u"
                     " ORDER BY date DESC LIMIT 1;",
                     task,
                     TASK_STATUS_DONE))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *report = 0;
        return 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        return -1;
        break;
    }
  return 0;
}

/**
 * @brief Get the report from second most recently completed invocation of task.
 *
 * @param[in]  task    The task.
 * @param[out] report  Report return, 0 if succesfully failed to select report.
 *
 * @return 0 success, -1 error.
 */
static int
task_second_last_report (task_t task, report_t *report)
{
  switch (sql_int64 (report, 0, 1,
                     "SELECT ROWID FROM reports WHERE task = %llu"
                     " AND scan_run_status = %u"
                     " ORDER BY date DESC LIMIT 2;",
                     task,
                     TASK_STATUS_DONE))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *report = 0;
        return 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        return -1;
        break;
    }
  return 0;
}

/**
 * @brief Get the report from the most recently stopped invocation of task.
 *
 * @param[in]  task    The task.
 * @param[out] report  Report return, 0 if succesfully failed to select report.
 *
 * @return 0 success, -1 error.
 */
int
task_last_stopped_report (task_t task, report_t *report)
{
  switch (sql_int64 (report, 0, 0,
                     "SELECT ROWID FROM reports WHERE task = %llu"
                     " AND scan_run_status = %u"
                     " ORDER BY date DESC LIMIT 1;",
                     task,
                     TASK_STATUS_STOPPED))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *report = 0;
        return 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        return -1;
        break;
    }
  return 0;
}

/**
 * @brief Get the report ID from the very first completed invocation of task.
 *
 * @param[in]  task  The task.
 *
 * @return The UUID of the task as a newly allocated string.
 */
gchar*
task_first_report_id (task_t task)
{
  return sql_string (0, 0,
                     "SELECT uuid FROM reports WHERE task = %llu"
                     " AND scan_run_status = %u"
                     " ORDER BY date ASC LIMIT 1;",
                     task,
                     TASK_STATUS_DONE);
}

/**
 * @brief Get the report ID from the most recently completed invocation of task.
 *
 * @param[in]  task  The task.
 *
 * @return The UUID of the report as a newly allocated string.
 */
gchar*
task_last_report_id (task_t task)
{
  return sql_string (0, 0,
                     "SELECT uuid FROM reports WHERE task = %llu"
                     " AND scan_run_status = %u"
                     " ORDER BY date DESC LIMIT 1;",
                     task,
                     TASK_STATUS_DONE);
}

/**
 * @brief Get report ID from second most recently completed invocation of task.
 *
 * @param[in]  task  The task.
 *
 * @return The UUID of the report as a newly allocated string.
 */
gchar*
task_second_last_report_id (task_t task)
{
  return sql_string (0, 1,
                     "SELECT uuid FROM reports WHERE task = %llu"
                     " AND scan_run_status = %u"
                     " ORDER BY date DESC LIMIT 2;",
                     task,
                     TASK_STATUS_DONE);
}

/**
 * @brief Add an alert to a task.
 *
 * @param[in]  task       Task.
 * @param[in]  alert  Alert.
 */
void
add_task_alert (task_t task, alert_t alert)
{
  sql ("INSERT INTO task_alerts (task, alert, alert_location)"
       " VALUES (%llu, %llu, " G_STRINGIFY (LOCATION_TABLE) ");",
       task,
       alert);
}

/**
 * @brief Set the alerts on a task, removing any previous alerts.
 *
 * @param[in]  task    Task.
 * @param[in]  alerts  Alerts.
 * @param[out] alert_id_return  ID of alert on "failed to find" error.
 *
 * @return 0 success, -1 error, 1 failed to find alert.
 */
int
set_task_alerts (task_t task, array_t *alerts, gchar **alert_id_return)
{
  alert_t alert = 0;
  guint index;

  sql ("BEGIN IMMEDIATE;");

  sql ("DELETE FROM task_alerts where task = %llu;", task);

  index = alerts->len;
  while (index--)
    {
      gchar *alert_id;

      alert_id = (gchar*) g_ptr_array_index (alerts, index);
      if (strcmp (alert_id, "0") == 0)
        continue;

      if (find_alert (alert_id, &alert))
        {
          sql ("ROLLBACK;");
          return -1;
        }

      if (alert == 0)
        {
          sql ("ROLLBACK;");
          if (alert_id_return) *alert_id_return = alert_id;
          return 1;
        }

      sql ("INSERT INTO task_alerts (task, alert, alert_location)"
           " VALUES (%llu, %llu, " G_STRINGIFY (LOCATION_TABLE) ");",
           task,
           alert);
    }

  sql ("COMMIT;");
  return 0;
}

/**
 * @brief Set the schedule of a task.
 *
 * Stop the task if it is paused.
 *
 * @param[in]  task      Task.
 * @param[in]  schedule  Schedule.
 *
 * @return 0 success, -1 error.
 */
int
set_task_schedule (task_t task, schedule_t schedule)
{
  task_status_t run_status;

  run_status = task_run_status (task);
  if (schedule != task_schedule (task)
      && (run_status == TASK_STATUS_PAUSE_REQUESTED
          || run_status == TASK_STATUS_PAUSE_WAITING
          || run_status == TASK_STATUS_PAUSED))
    switch (stop_task (task))
      {
        case 0:    /* Stopped. */
        case 1:    /* Stop requested. */
          break;
        default:   /* Programming error. */
          assert (0);
        case -1:   /* Error. */
          return -1;
          break;
      }

  sql ("UPDATE tasks SET schedule = %llu, schedule_next_time = "
       " (SELECT schedules.first_time FROM schedules WHERE ROWID = %llu),"
       " modification_time = now ()"
       " WHERE ROWID = %llu;",
       schedule,
       schedule,
       task);

  return 0;
}

/**
 * @brief Return the threat level of a task, taking overrides into account.
 *
 * @param[in]  task       Task.
 * @param[in]  overrides  Whether to apply overrides.
 *
 * @return Threat level of last report on task if there is one, as a static
 *         string, else NULL.
 */
const char*
task_threat_level (task_t task, int overrides)
{
  char *type;
  gchar *ov, *new_type_sql;

  if (current_credentials.uuid == NULL)
    return NULL;

  if (task_target (task) == 0)
    /* Container task. */
    return NULL;

  if (overrides)
    {
      ov = g_strdup_printf
            ("SELECT overrides.new_threat"
             " FROM overrides"
             " WHERE overrides.nvt = results.nvt"
             " AND ((overrides.owner IS NULL)"
             " OR (overrides.owner ="
             " (SELECT ROWID FROM users"
             "  WHERE users.uuid = '%s')))"
             " AND ((overrides.end_time = 0)"
             "      OR (overrides.end_time >= now ()))"
             " AND (overrides.task ="
             "      (SELECT reports.task FROM reports"
             "       WHERE report_results.report = reports.ROWID)"
             "      OR overrides.task = 0)"
             " AND (overrides.result = results.ROWID"
             "      OR overrides.result = 0)"
             " AND (overrides.hosts is NULL"
             "      OR overrides.hosts = \"\""
             "      OR hosts_contains (overrides.hosts, results.host))"
             " AND (overrides.port is NULL"
             "      OR overrides.port = \"\""
             "      OR overrides.port = results.port)"
             " AND (overrides.threat is NULL"
             "      OR overrides.threat = \"\""
             "      OR overrides.threat = results.type)"
             " ORDER BY overrides.result DESC, overrides.task DESC,"
             " overrides.port DESC, overrides.threat"
             " COLLATE collate_message_type ASC",
             current_credentials.uuid);

      new_type_sql = g_strdup_printf ("coalesce ((%s), type)", ov);

      g_free (ov);
    }
  else
    new_type_sql = g_strdup ("type");

  type = sql_string (0, 0,
                     " SELECT %s AS new_type FROM results, report_results"
                     " WHERE report_results.report ="
                     " (SELECT ROWID FROM reports WHERE reports.task = %llu"
                     "  AND reports.scan_run_status = %u"
                     "  ORDER BY reports.date DESC LIMIT 1)"
                     " AND results.ROWID = report_results.result"
                     " ORDER BY new_type COLLATE collate_message_type DESC"
                     " LIMIT 1",
                     new_type_sql,
                     task,
                     TASK_STATUS_DONE);

  g_free (new_type_sql);

  if (type == NULL)
    return NULL;

  if (strcmp (type, "Security Hole") == 0)
    {
      free (type);
      return "High";
    }

  if (strcmp (type, "Security Warning") == 0)
    {
      free (type);
      return "Medium";
    }

  if (strcmp (type, "Security Note") == 0)
    {
      free (type);
      return "Low";
    }

  if (strcmp (type, "Log Message") == 0)
    {
      free (type);
      return "Log";
    }

  if (strcmp (type, "Debug Message") == 0)
    {
      free (type);
      return "Debug";
    }

  if (strcmp (type, "False Positive") == 0)
    {
      free (type);
      return "False Positive";
    }

  free (type);
  return NULL;
}

/**
 * @brief Return the previous threat level of a task.
 *
 * @param[in]  task  Task.
 *
 * @return Threat level of the second last report on task if there is one, as a
 *         static string, else NULL.
 */
static const char*
task_previous_threat_level (task_t task)
{
  char *type;
  gchar *ov, *new_type_sql;

  assert (current_credentials.uuid);

  ov = g_strdup_printf
        ("SELECT overrides.new_threat"
         " FROM overrides"
         " WHERE overrides.nvt = results.nvt"
         " AND ((overrides.owner IS NULL)"
         " OR (overrides.owner ="
         " (SELECT ROWID FROM users"
         "  WHERE users.uuid = '%s')))"
         " AND ((overrides.end_time = 0)"
         "      OR (overrides.end_time >= now ()))"
         " AND (overrides.task ="
         "      (SELECT reports.task FROM reports"
         "       WHERE report_results.report = reports.ROWID)"
         "      OR overrides.task = 0)"
         " AND (overrides.result = results.ROWID"
         "      OR overrides.result = 0)"
         " AND (overrides.hosts is NULL"
         "      OR overrides.hosts = \"\""
         "      OR hosts_contains (overrides.hosts, results.host))"
         " AND (overrides.port is NULL"
         "      OR overrides.port = \"\""
         "      OR overrides.port = results.port)"
         " AND (overrides.threat is NULL"
         "      OR overrides.threat = \"\""
         "      OR overrides.threat = results.type)"
         " ORDER BY overrides.result DESC, overrides.task DESC,"
         " overrides.port DESC, overrides.threat"
         " COLLATE collate_message_type ASC",
         current_credentials.uuid);

  new_type_sql = g_strdup_printf ("coalesce ((%s), type)", ov);

  g_free (ov);

  type = sql_string (0, 0,
                     " SELECT %s AS new_type FROM results, report_results"
                     " WHERE report_results.report ="
                     " (SELECT ROWID FROM reports WHERE reports.task = %llu"
                     "  AND reports.scan_run_status = %u"
                     "  ORDER BY reports.date DESC LIMIT 2 OFFSET 1)"
                     " AND results.ROWID = report_results.result"
                     " ORDER BY new_type COLLATE collate_message_type DESC"
                     " LIMIT 1",
                     new_type_sql,
                     task,
                     TASK_STATUS_DONE);

  g_free (new_type_sql);

  if (type == NULL)
    return NULL;

  if (strcmp (type, "Security Hole") == 0)
    {
      free (type);
      return "High";
    }

  if (strcmp (type, "Security Warning") == 0)
    {
      free (type);
      return "Medium";
    }

  if (strcmp (type, "Security Note") == 0)
    {
      free (type);
      return "Low";
    }

  if (strcmp (type, "Log Message") == 0)
    {
      free (type);
      return "Log";
    }

  if (strcmp (type, "Debug Message") == 0)
    {
      free (type);
      return "Debug";
    }

  if (strcmp (type, "False Positive") == 0)
    {
      free (type);
      return "False Positive";
    }

  free (type);
  return NULL;
}

/**
 * @brief Return the schedule of a task.
 *
 * @param[in]  task  Task.
 *
 * @return Schedule.
 */
schedule_t
task_schedule (task_t task)
{
  schedule_t schedule = 0;
  switch (sql_int64 (&schedule, 0, 0,
                     "SELECT schedule FROM tasks WHERE ROWID = %llu;",
                     task))
    {
      case 0:
        return schedule;
        break;
      case 1:        /* Too few rows in result of query. */
      default:       /* Programming error. */
        assert (0);
      case -1:
        return 0;
        break;
    }
}

/**
 * @brief Get whether the task schedule is in the trash.
 *
 * @param[in]  task  Task.
 *
 * @return 1 if in trash, else 0.
 */
int
task_schedule_in_trash (task_t task)
{
  return sql_int (0, 0,
                  "SELECT schedule_location = " G_STRINGIFY (LOCATION_TRASH)
                  " FROM tasks"
                  " WHERE ROWID = %llu;",
                  task);
}

/**
 * @brief Get next time a scheduled task will run, following schedule timezone.
 *
 * @param[in]  task  Task.
 *
 * @return If the task has a schedule, the next time the task will run (0 if it
 *         has already run), otherwise 0.
 */
int
task_schedule_next_time_tz (task_t task)
{
  int next_time;
  int ret;
  iterator_t schedules;
  get_data_t get;
  schedule_t schedule;

  schedule = task_schedule (task);
  memset (&get, '\0', sizeof (get));
  get.id = schedule_uuid (schedule);

  next_time = sql_int (0, 0,
                       "SELECT schedule_next_time FROM tasks"
                       " WHERE ROWID = %llu;",
                       task);
  if (next_time == 0)
    return 0;

  ret = init_schedule_iterator (&schedules, &get);

  if (ret)
    return next_time;

  if (next (&schedules))
    next_time += schedule_iterator_initial_offset (&schedules)
                  - time_offset (schedule_iterator_timezone (&schedules),
                                 next_time);
  cleanup_iterator (&schedules);
  return next_time;
}

/**
 * @brief Set the next time a scheduled task will be due.
 *
 * @param[in]  task  Task.
 * @param[in]  time  New next time.
 */
void
set_task_schedule_next_time (task_t task, time_t time)
{
  sql ("UPDATE tasks SET schedule_next_time = %i WHERE ROWID = %llu;",
       time, task);
}

/**
 * @brief Find a user given a name.
 *
 * @param[in]   name  A user name.
 * @param[out]  user  User return, 0 if succesfully failed to find user.
 *
 * @return FALSE on success (including if failed to find user), TRUE on error.
 */
static gboolean
find_user (const char* name, user_t *user)
{
  gchar *quoted_name;
  quoted_name = sql_quote (name);
  switch (sql_int64 (user, 0, 0,
                     "SELECT ROWID FROM users WHERE name = '%s'"
                     " ORDER BY ROWID DESC;",
                     quoted_name))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *user = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        g_free (quoted_name);
        return TRUE;
        break;
    }

  g_free (quoted_name);
  return FALSE;
}

/**
 * @brief Set the observers of a task.
 *
 * @param[in]  task       Task.
 * @param[in]  observers  Observers.
 *
 * @return 0 success, -1 error, 1 user name validation failed, 2 failed to find
 *         user.
 */
int
set_task_observers (task_t task, const gchar *observers)
{
  gchar **split, **point;
  GList *added;

  assert (current_credentials.username);

  added = NULL;
  split = g_strsplit_set (observers, " ,", 0);

  sql ("BEGIN IMMEDIATE;");

  sql ("DELETE FROM task_users WHERE task = %llu;", task);

  point = split;
  while (*point)
    {
      user_t user;
      gchar *name;

      name = *point;

      g_strstrip (name);

      if (strcmp (name, "") == 0)
        {
          point++;
          continue;
        }

      if ((strcmp (name, current_credentials.username) == 0)
          || g_list_find_custom (added, name, (GCompareFunc) strcmp))
        {
          point++;
          continue;
        }

      added = g_list_prepend (added, name);

      if (openvas_user_exists (name) == 0)
        {
          g_list_free (added);
          g_strfreev (split);
          sql ("ROLLBACK;");
          return 2;
        }

      if (find_user (name, &user))
        {
          g_list_free (added);
          g_strfreev (split);
          sql ("ROLLBACK;");
          return -1;
        }

      if (user == 0)
        {
          gchar *uuid;

          /** @todo Similar to validate_user in openvas-administrator. */
          if (g_regex_match_simple ("^[[:alnum:]-_]+$", name, 0, 0) == 0)
            {
              g_list_free (added);
              g_strfreev (split);
              sql ("ROLLBACK;");
              return 1;
            }

          uuid = openvas_user_uuid (name);

          if (uuid == NULL)
            {
              g_list_free (added);
              g_strfreev (split);
              sql ("ROLLBACK;");
              return -1;
            }

          if (sql_int (0, 0,
                       "SELECT count(*) FROM users WHERE uuid = '%s';",
                       uuid)
              == 0)
            {
              gchar *quoted_name;
              quoted_name = sql_quote (name);
              sql ("INSERT INTO users (uuid, name) VALUES ('%s', '%s');",
                   uuid,
                   quoted_name);
              g_free (quoted_name);

              user = sqlite3_last_insert_rowid (task_db);
            }
          else
            {
              /* user_find should have found it. */
              assert (0);
              g_list_free (added);
              g_strfreev (split);
              sql ("ROLLBACK;");
              return -1;
            }
        }

      sql ("INSERT INTO task_users (task, user, actions)"
           " VALUES (%llu, %llu, %llu)",
           task, user, (unsigned long long int) MANAGE_ACTION_GET);

      point++;
    }

  g_list_free (added);
  g_strfreev (split);
  sql ("COMMIT;");
  return 0;
}


/**
 * @brief Generate rcfile in task from config and target.
 *
 * @param[in]  task  The task.
 *
 * @return 0 success, -1 error.
 */
int
make_task_rcfile (task_t task)
{
  config_t config;
  target_t target;
  char *config_name, *selector, *hosts, *rc;
  iterator_t prefs;
  GString *buffer;

  config = task_config (task);

  config_name = task_config_name (task);
  if (config_name == NULL) return -1;

  target = task_target (task);
  if (target == 0)
    {
      free (config_name);
      return -1;
    }

  selector = config_nvt_selector (config);
  if (selector == NULL)
    {
      free (config_name);
      return -1;
    }

  /* Header. */

  buffer = g_string_new ("# This file was automatically created"
                         " by openvasmd, the OpenVAS Manager daemon.\n");

  /* General preferences. */

  init_preference_iterator (&prefs, config, NULL);
  while (next (&prefs))
    g_string_append_printf (buffer,
                            "%s = %s\n",
                            preference_iterator_name (&prefs),
                            preference_iterator_value (&prefs));
  cleanup_iterator (&prefs);

  /* Targets for general preferences. */

  hosts = target_hosts (target);
  if (hosts)
    g_string_append_printf (buffer, "targets = %s\n\n", hosts);
  else
    {
      free (hosts);
      free (config_name);
      free (selector);
      g_string_free (buffer, TRUE);
      return -1;
    }
  free (hosts);

  /* Scanner set. */

  g_string_append (buffer, "begin(SCANNER_SET)\n");
  /** @todo How know if scanner? (?) */
  g_string_append (buffer, "end(SCANNER_SET)\n\n");

  /* Scanner preferences. */

  g_string_append (buffer, "begin(SERVER_PREFS)\n");
  init_preference_iterator (&prefs, config, "SERVER_PREFS");
  while (next (&prefs))
    g_string_append_printf (buffer,
                            " %s = %s\n",
                            preference_iterator_name (&prefs),
                            preference_iterator_value (&prefs));
  cleanup_iterator (&prefs);
  g_string_append (buffer, "end(SERVER_PREFS)\n\n");

  /* Client side user rules. */

  g_string_append (buffer, "begin(CLIENTSIDE_USERRULES)\n");
  g_string_append (buffer, "end(CLIENTSIDE_USERRULES)\n\n");

  /* Plugin preferences. */

  g_string_append (buffer, "begin(PLUGINS_PREFS)\n");
  init_preference_iterator (&prefs, config, "PLUGINS_PREFS");
  while (next (&prefs))
    g_string_append_printf (buffer,
                            " %s = %s\n",
                            preference_iterator_name (&prefs),
                            preference_iterator_value (&prefs));
  cleanup_iterator (&prefs);
  g_string_append (buffer, "end(PLUGINS_PREFS)\n\n");

  /* Plugin set. */

  g_string_append (buffer, "begin(PLUGIN_SET)\n");
  {
    /* This block is a modified copy of nvt_selector_plugins (from
     * manage.c). */
    /** @todo This may be better as "config_families_growing (config)". */
    if (nvt_selector_nvts_growing (selector))
      {
        /** @todo Do other cases. (?) */
        if ((sql_int (0, 0,
                      "SELECT COUNT(*) FROM nvt_selectors WHERE name = '%s';",
                      selector)
             == 1)
            && (sql_int (0, 0,
                         "SELECT COUNT(*) FROM nvt_selectors"
                         " WHERE name = '%s'"
                         " AND type = " G_STRINGIFY (NVT_SELECTOR_TYPE_ALL)
                         ";",
                         selector)
                == 1))
          {
            iterator_t nvts;

            init_nvt_iterator (&nvts, (nvt_t) 0, (config_t) 0, NULL, NULL, 1,
                               NULL);
            while (next (&nvts))
              g_string_append_printf (buffer,
                                      " %s = yes\n",
                                      nvt_iterator_oid (&nvts));
            cleanup_iterator (&nvts);
          }
      }
    else
      {
        iterator_t nvts;

        init_nvt_selector_iterator (&nvts, selector, (config_t) 0, 2);
        while (next (&nvts))
          g_string_append_printf (buffer,
                                  " %s = %s\n",
                                  nvt_selector_iterator_nvt (&nvts),
                                  nvt_selector_iterator_include (&nvts)
                                  ? "yes" : "no");
        cleanup_iterator (&nvts);
      }
  }
  g_string_append (buffer, "end(PLUGIN_SET)\n\n");

  /* Scanner info. */

  g_string_append (buffer, "begin(SERVER_INFO)\n");
  g_string_append (buffer, "end(SERVER_INFO)\n");

  free (config_name);
  free (selector);

  rc = g_string_free (buffer, FALSE);

  set_task_description (task, rc, strlen (rc));
  free (rc);

  return 0;
}


/* Results. */

/**
 * @brief Find a result given a UUID.
 *
 * @param[in]   uuid    UUID of result.
 * @param[out]  result  Result return, 0 if succesfully failed to find result.
 *
 * @return FALSE on success (including if failed to find result), TRUE on error.
 */
gboolean
find_result (const char* uuid, result_t* result)
{
  if (user_owns_result (uuid) == 0)
    {
      *result = 0;
      return FALSE;
    }
  switch (sql_int64 (result, 0, 0,
                     "SELECT ROWID FROM results WHERE uuid = '%s';",
                     uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in outcome of query. */
        *result = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        return TRUE;
        break;
    }

  return FALSE;
}

/**
 * @brief Find a result given an identifier.
 *
 * @param[in]   uuid     A result identifier.
 * @param[out]  result   Result return, 0 if succesfully failed to find result.
 * @param[in]   actions  Actions.
 *
 * @return FALSE on success (including if failed to find result), TRUE on error.
 */
gboolean
find_result_for_actions (const char *uuid, result_t *result,
                         const char *actions)
{
  if (user_has_access_uuid ("result", uuid, actions) == 0)
    {
      *result = 0;
      return FALSE;
    }
  switch (sql_int64 (result, 0, 0,
                     "SELECT ROWID FROM results WHERE uuid = '%s';",
                     uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *result = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        return TRUE;
        break;
    }

  return FALSE;
}

/**
 * @brief Make a result.
 *
 * @param[in]  task         The task associated with the result.
 * @param[in]  subnet       Subnet.
 * @param[in]  host         Host.
 * @param[in]  port         The port the result refers to.
 * @param[in]  nvt          The OID of the NVT that produced the result.
 * @param[in]  type         Type of result.  "Security Hole", etc.
 * @param[in]  description  Description of the result.
 *
 * @return A result descriptor for the new result.
 */
result_t
make_result (task_t task, const char* subnet, const char* host,
             const char* port, const char* nvt, const char* type,
             const char* description)
{
  result_t result;
  gchar *quoted_descr = sql_quote (description);
  sql ("INSERT into results"
       " (task, subnet, host, port, nvt, type, description, uuid)"
       " VALUES"
       " (%llu, '%s', '%s', '%s', '%s', '%s', '%s', make_uuid ());",
       task, subnet, host, port, nvt, type, quoted_descr);
  g_free (quoted_descr);
  result = sqlite3_last_insert_rowid (task_db);
  return result;
}

/**
 * @brief Return the UUID of a result.
 *
 * @param[in]   result  Result.
 * @param[out]  id      Pointer to a newly allocated string.
 *
 * @return 0.
 */
int
result_uuid (result_t result, char ** id)
{
  *id = sql_string (0, 0,
                    "SELECT uuid FROM results WHERE ROWID = %llu;",
                    result);
  return 0;
}

/**
 * @brief Get product detection results corresponding to a given vulnerability
 *        detection result.
 *
 * @param[in]   result      Vulnerability detection result.
 * @param[out]  ref         Detection result UUID.
 * @param[out]  product     Product name.
 * @param[out]  location    Product location.
 * @param[out]  oid         Detection script OID.
 * @param[out]  name        Detection script name.
 *
 * @return -1 on error, 0 on success.
 */
int
result_detection_reference (result_t result, char **ref, char **product,
                            char **location, char **oid, char **name)
{
  char *report, *host;

  if ((ref == NULL) || (product == NULL) || (location == NULL) || (oid == NULL)
      || (name == NULL))
    return -1;

  report = NULL;
  host   = NULL;

  *ref = *product = *location = *oid = *name = NULL;

  report = sql_string (0, 0, "SELECT report FROM report_results"
                             " WHERE result = %llu;",
                             result);
  if (report == NULL)
    goto detect_cleanup;

  host = sql_string (0, 0, "SELECT host FROM results where ROWID = %llu;",
                     result);
  if (host == NULL)
    goto detect_cleanup;

  *oid = sql_string (0, 0, "SELECT value"
                           " FROM report_host_details"
                           " WHERE report_host = (SELECT ROWID"
                           "                      FROM report_hosts"
                           "                      WHERE report = %s"
                           "                      AND host = '%s')"
                           " AND name = 'detected_by'"
                           " AND source_name = (SELECT nvt FROM results"
                           "                    WHERE ROWID = %llu);",
                           report, host, result);
  if (*oid == NULL)
    goto detect_cleanup;

  *location = sql_string (0, 0, "SELECT value"
                                " FROM report_host_details"
                                " WHERE report_host = (SELECT ROWID"
                                "                      FROM report_hosts"
                                "                      WHERE report = %s"
                                "                      AND host = '%s')"
                                " AND name = 'detected_at'"
                                " AND source_name = (SELECT nvt"
                                "                    FROM results"
                                "                    WHERE ROWID = %llu);",
                                report, host, result);
  if (*location == NULL)
    goto detect_cleanup;

  *product = sql_string (0, 0, "SELECT name"
                               " FROM report_host_details"
                               " WHERE report_host = (SELECT ROWID"
                               "                      FROM report_hosts"
                               "                      WHERE report = %s"
                               "                      AND host = '%s')"
                               " AND source_name = '%s'"
                               " AND value = '%s';",
                               report, host, *oid, *location);
  if (*product == NULL)
    goto detect_cleanup;

  *name = sql_string (0, 0, "SELECT name FROM nvts WHERE oid = '%s';", *oid);
  if (*name == NULL)
    goto detect_cleanup;

  *ref = sql_string (0, 0, "SELECT uuid"
                           " FROM results"
                           " WHERE ROWID IN (SELECT result"
                           "                 FROM report_results"
                           "                 WHERE report = %s)"
                           " AND host = '%s'"
                           " AND nvt = '%s'"
                           " AND (description LIKE '%%%s%%'"
                           "      OR port LIKE '%%%s%%');",
                           report, host, *oid, *location, *location);
  if (*ref == NULL)
    goto detect_cleanup;

  g_free (report);
  g_free (host);

  return 0;

detect_cleanup:
  g_free (report);
  g_free (host);

  return -1;
}



/* Prognostics. */

/**
 * @brief Return highest CVE for an App.
 *
 * @param[in]  cpe  CPE.
 */
double
cpe_highest_cvss (const char *cpe)
{
  int highest;
  gchar *quoted_cpe;
  quoted_cpe = sql_quote (cpe);
  highest = sql_double (0, 0,
                        "SELECT"
                        " (CASE WHEN (SELECT ROWID FROM cpes WHERE name = '%s')"
                        "  THEN (SELECT max_cvss FROM cpes WHERE name = '%s')"
                        "  ELSE -1"
                        "  END);",
                        quoted_cpe,
                        quoted_cpe);
  g_free (quoted_cpe);
  return highest;
}

/**
 * @brief Initialise a prognosis iterator.
 *
 * @param[in]  iterator  Iterator.
 * @param[in]  cpe       CPE.
 */
void
init_prognosis_iterator (iterator_t *iterator, const char *cpe)
{
  static sqlite3_stmt* stmt = NULL;

  if (stmt == NULL)
    stmt = sql_prepare ("SELECT cves.name, cves.cvss, cves.description,"
                        "       cpes.name"
                        " FROM scap.cves, scap.cpes, scap.affected_products"
                        " WHERE cpes.name=$cpe"
                        " AND cpes.id=affected_products.cpe"
                        " AND cves.id=affected_products.cve"
                        " ORDER BY CAST (cves.cvss AS INTEGER) DESC;");
  else
    {
      sqlite3_clear_bindings (stmt);
      sqlite3_reset (stmt);
    }

  init_prepared_iterator (iterator, stmt);

  /* Bind iterator. */
  while (1)
    {
      int ret;
      ret = sqlite3_bind_text (stmt, 1, cpe, -1, SQLITE_TRANSIENT);
      if (ret == SQLITE_BUSY) continue;
      if (ret == SQLITE_OK) break;
      g_warning ("%s: sqlite3_bind failed: %s\n",
                 __FUNCTION__,
                 sqlite3_errmsg (task_db));
      abort ();
    }
}

DEF_ACCESS (prognosis_iterator_cve, 0);
DEF_ACCESS (prognosis_iterator_cvss, 1);
DEF_ACCESS (prognosis_iterator_description, 2);
DEF_ACCESS (prognosis_iterator_cpe, 3);

/**
 * @brief Get the CVSS from a result iterator as an integer.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return CVSS.
 */
int
prognosis_iterator_cvss_int (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (int) sqlite3_column_int64 (iterator->stmt, 1);
}

/**
 * @brief Get the CVSS from a result iterator as a double.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return CVSS.
 */
double
prognosis_iterator_cvss_double (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return sqlite3_column_double (iterator->stmt, 1);
}

/**
 * @brief Return SQL WHERE for restricting a SELECT to a search phrase.
 *
 * @param[in]  search_phrase  Phrase that results must include.  All results if
 *                            NULL or "".
 *
 * @return WHERE clause for search phrase if one is required, else NULL.
 */
static GString *
prognosis_where_search_phrase (const char* search_phrase)
{
  if (search_phrase)
    {
      GString *phrase_sql;
      gchar *quoted_search_phrase;

      if (strlen (search_phrase) == 0)
        return NULL;

      quoted_search_phrase = sql_quote (search_phrase);
      phrase_sql = g_string_new ("");
      g_string_append_printf (phrase_sql,
                              " AND (cves.description LIKE '%%%%%s%%%%'"
                              " OR cves.name LIKE '%%%%%s%%%%'"
                              " OR cpes.name LIKE '%%%%%s%%%%')",
                              quoted_search_phrase,
                              quoted_search_phrase,
                              quoted_search_phrase);
      g_free (quoted_search_phrase);

      return phrase_sql;
    }
  return NULL;
}

/**
 * @brief Return SQL WHERE for restricting a SELECT to levels.
 *
 * @param[in]  levels  String describing threat levels (message types)
 *                     to include in report (for example, "hmlgd" for
 *                     High, Medium, Low, loG and Debug).  All levels if
 *                     NULL.
 *
 * @return WHERE clause for levels if one is required, else NULL.
 */
static const char *
prognosis_where_levels (const char* levels)
{
  char *high, *medium, *low;

  if (levels == NULL || strlen (levels) == 0)
    return "";

  high = strchr (levels, 'h');
  medium = strchr (levels, 'm');
  low = strchr (levels, 'l');

  if (high && medium && low)
    return "";

  if (high && medium)
    return " AND cves.cvss > 2";

  if (high && low)
    return " AND (cves.cvss > 5 OR cves.cvss <= 2)";

  if (medium && low)
    return " AND cves.cvss <= 5";

  if (high)
    return " AND cves.cvss > 5";

  if (medium)
    return " AND cves.cvss <= 5 AND cves.cvss > 2";

  if (low)
    return " AND cves.cvss <= 2";

  return "";
}

/**
 * @brief Return SQL WHERE for restricting a SELECT to a minimum CVSS base.
 *
 * @param[in]  min_cvss_base  Minimum value for CVSS.
 *
 * @return WHERE clause if one is required, else NULL.
 */
static GString *
prognosis_where_cvss_base (const char* min_cvss_base)
{
  if (min_cvss_base)
    {
      GString *cvss_sql;
      gchar *quoted_min_cvss_base;

      if (strlen (min_cvss_base) == 0)
        return NULL;

      quoted_min_cvss_base = sql_quote (min_cvss_base);
      cvss_sql = g_string_new ("");
      g_string_append_printf (cvss_sql,
                              " AND CAST (cves.cvss AS REAL)"
                              " >= CAST ('%s' AS REAL)",
                              quoted_min_cvss_base);
      g_free (quoted_min_cvss_base);

      return cvss_sql;
    }
  return NULL;
}

/**
 * @brief Initialise a report host prognosis iterator.
 *
 * @param[in]  iterator     Iterator.
 * @param[in]  report_host  Report host whose prognosis the iterator loops over.
 *                          All report_hosts if NULL.
 * @param[in]  first_result   The result to start from.  The results are 0
 *                            indexed.
 * @param[in]  max_results    The maximum number of results returned.
 * @param[in]  levels         String describing threat levels (message types)
 *                            to include in count (for example, "hmlgd" for
 *                            High, Medium, Low, loG and Debug).  All levels if
 *                            NULL.
 * @param[in]  search_phrase  Phrase that results must include.  All results
 * @param[in]  min_cvss_base  Minimum value for CVSS.  All results if NULL.
 */
static void
init_host_prognosis_iterator (iterator_t* iterator, report_host_t report_host,
                              int first_result, int max_results,
                              const char *levels, const char *search_phrase,
                              const char *min_cvss_base)
{
  GString *phrase_sql, *cvss_sql;

  if (levels == NULL) levels = "hmlgdf";

  phrase_sql = prognosis_where_search_phrase (search_phrase);
  cvss_sql = prognosis_where_cvss_base (min_cvss_base);

  init_iterator (iterator,
                 "SELECT cves.name, cves.cvss, cves.description, cpes.name"
                 " FROM scap.cves, scap.cpes, scap.affected_products,"
                 "      report_host_details"
                 " WHERE report_host_details.report_host = %llu"
                 " AND cpes.name = report_host_details.value"
                 " AND report_host_details.name = 'App'"
                 " AND cpes.id=affected_products.cpe"
                 " AND cves.id=affected_products.cve"
                 "%s%s%s"
                 " ORDER BY CAST (cves.cvss AS INTEGER) DESC"
                 " LIMIT %i OFFSET %i;",
                 report_host,
                 phrase_sql ? phrase_sql->str : "",
                 prognosis_where_levels (levels),
                 cvss_sql ? cvss_sql->str : "",
                 max_results,
                 first_result);

  if (phrase_sql) g_string_free (phrase_sql, TRUE);
  if (cvss_sql) g_string_free (cvss_sql, TRUE);
}

/**
 * @brief Count all filtered results for a prognostic report.
 *
 * @param[in]   report_host    Report host for which to count.
 * @param[in]   search_phrase  Phrase that results must include.  All results
 * @param[in]   min_cvss_base  Minimum value for CVSS.  All results if NULL.
 * @param[out]  all            Number of messages to increment.
 * @param[out]  holes          Number of hole messages to increment.
 * @param[out]  infos          Number of info messages to increment.
 * @param[out]  logs           Number of log messages to increment.
 * @param[out]  warnings       Number of warning messages to increment.
 */
static void
prognostic_report_result_count (report_host_t report_host,
                                const char *search_phrase,
                                const char *min_cvss_base, int *all,
                                int *holes, int *infos, int *logs,
                                int *warnings)
{
  GString *phrase_sql, *cvss_sql;
  int host_holes, host_warnings, host_infos;

  phrase_sql = prognosis_where_search_phrase (search_phrase);
  cvss_sql = prognosis_where_cvss_base (min_cvss_base);

  host_holes = sql_int (0, 0,
                        "SELECT count (*)"
                        " FROM scap.cves, scap.cpes, scap.affected_products,"
                        "      report_host_details"
                        " WHERE report_host_details.report_host = %llu"
                        " AND cpes.name = report_host_details.value"
                        " AND report_host_details.name = 'App'"
                        " AND cpes.id=affected_products.cpe"
                        " AND cves.id=affected_products.cve"
                        "%s%s%s"
                        " ORDER BY CAST (cves.cvss AS INTEGER) DESC;",
                        report_host,
                        phrase_sql ? phrase_sql->str : "",
                        prognosis_where_levels ("h"),
                        cvss_sql ? cvss_sql->str : "");

  host_warnings = sql_int (0, 0,
                           "SELECT count (*)"
                           " FROM scap.cves, scap.cpes, scap.affected_products,"
                           "      report_host_details"
                           " WHERE report_host_details.report_host = %llu"
                           " AND cpes.name = report_host_details.value"
                           " AND report_host_details.name = 'App'"
                           " AND cpes.id=affected_products.cpe"
                           " AND cves.id=affected_products.cve"
                           "%s%s%s"
                           " ORDER BY CAST (cves.cvss AS INTEGER) DESC;",
                           report_host,
                           phrase_sql ? phrase_sql->str : "",
                           prognosis_where_levels ("m"),
                           cvss_sql ? cvss_sql->str : "");

  host_infos = sql_int (0, 0,
                        "SELECT count (*)"
                        " FROM scap.cves, scap.cpes, scap.affected_products,"
                        "      report_host_details"
                        " WHERE report_host_details.report_host = %llu"
                        " AND cpes.name = report_host_details.value"
                        " AND report_host_details.name = 'App'"
                        " AND cpes.id=affected_products.cpe"
                        " AND cves.id=affected_products.cve"
                        "%s%s%s"
                        " ORDER BY CAST (cves.cvss AS INTEGER) DESC;",
                        report_host,
                        phrase_sql ? phrase_sql->str : "",
                        prognosis_where_levels ("l"),
                        cvss_sql ? cvss_sql->str : "");

  *all += host_holes + host_warnings + host_infos;

  *holes += host_holes;
  *warnings += host_warnings;
  *infos += host_infos;

  if (phrase_sql) g_string_free (phrase_sql, TRUE);
  if (cvss_sql) g_string_free (cvss_sql, TRUE);
}


/* Reports. */

/**
 * @brief Clear cached report count.
 *
 * @param[in]  override  Flag for override or regular case.
 */
void
reports_clear_count_cache (int override)
{
  if (override)
    sql ("UPDATE reports SET override_highs = -1;");
  else
    sql ("UPDATE reports SET highs = -1;");
}

/**
 * @brief Cached report counts.
 *
 * @param[in]  report  Report.
 */
void
report_cache_counts (report_t report)
{
  int debugs, holes, infos, logs, warnings, false_positives;
  report_counts_id (report, &debugs, &holes, &infos, &logs, &warnings,
                    &false_positives, 0, NULL, 0);
  report_counts_id (report, &debugs, &holes, &infos, &logs, &warnings,
                    &false_positives, 0, NULL, 0);
}

/**
 * @brief Make a report.
 *
 * @param[in]  task    The task associated with the report.
 * @param[in]  uuid    The UUID of the report.
 * @param[in]  status  The run status of the scan associated with the report.
 *
 * @return A report descriptor for the new report.
 */
report_t
make_report (task_t task, const char* uuid, task_status_t status)
{
  report_t report;

  assert (current_credentials.uuid);

  sql ("INSERT into reports (uuid, owner, hidden, task, date, nbefile, comment,"
       " scan_run_status, slave_progress, slave_task_uuid, highs,"
       " override_highs)"
       " VALUES ('%s',"
       " (SELECT ROWID FROM users WHERE users.uuid = '%s'),"
       " 0, %llu, %i, '', '', %u, 0, '', -1, -1);",
       uuid, current_credentials.uuid, task, time (NULL), status);
  report = sqlite3_last_insert_rowid (task_db);
  return report;
}

/**
 * @brief Create the current report for a task.
 *
 * @param[in]   task       The task.
 * @param[out]  report_id  Report ID.
 * @param[in]   status     Run status of scan associated with report.
 *
 * @return 0 success, -1 current_report is already set, -2 failed to generate ID.
 */
int
create_current_report (task_t task, char **report_id, task_status_t status)
{
  char *id;

  assert (current_report == (report_t) 0);

  if (current_report) return -1;

  if (report_id == NULL) report_id = &id;

  /* Generate report UUID. */

  *report_id = openvas_uuid_make ();
  if (*report_id == NULL) return -2;

  /* Create the report. */

  current_report = make_report (task, *report_id, status);

  return 0;
}

/**
 * @brief Free a host detail.
 *
 * @param[in]  detail  Host detail.
 */
void
host_detail_free (host_detail_t *detail)
{
  g_free (detail->ip);
  g_free (detail->name);
  g_free (detail->source_desc);
  g_free (detail->source_name);
  g_free (detail->source_type);
  g_free (detail->value);
}

/**
 * @brief Create a report from an array of results.
 *
 * @param[in]   results       Array of create_report_result_t pointers.
 * @param[in]   task_id       UUID of container task, or NULL to create new one.
 * @param[in]   task_name     Name for container task.
 * @param[in]   task_comment  Comment for container task.
 * @param[in]   scan_start    Scan start time text.
 * @param[in]   scan_end      Scan end time text.
 * @param[in]   host_starts   Array of create_report_result_t pointers.  Host
 *                            name in host, time in description.
 * @param[in]   host_ends     Array of create_report_result_t pointers.  Host
 *                            name in host, time in description.
 * @param[in]   details       Array of host_detail_t pointers.
 * @param[out]  report_id     Report ID.
 *
 * @return 0 success, -1 error, -2 failed to generate ID, -3 task_name is NULL,
 *         -4 failed to find task, -5 task must be container.
 */
int
create_report (array_t *results, const char *task_id, const char *task_name,
               const char *task_comment, const char *scan_start,
               const char *scan_end, array_t *host_starts,
               array_t *host_ends, array_t *details, char **report_id)
{
  int index;
  create_report_result_t *result, *end, *start;
  report_t report;
  task_t task;
  pid_t pid;
  host_detail_t *detail;

  if (task_id == NULL && task_name == NULL)
    return -3;

  /* Find or create the task. */

  /** @todo This should really lock the task for the entire duration, because
   *        someone could remove the task during the upload.   But will probably
   *        cause problems on Debian 5 (sqlite 3.5.9), as below.
   */

  if (task_id)
    {
      if (find_task (task_id, &task))
        return -1;

      if (task == 0)
        return -4;

      if (task_target (task))
        return -5;
    }
  else
    task = make_task (g_strdup (task_name),
                      0,
                      task_comment ? g_strdup (task_comment) : NULL);

  /* Generate report UUID. */

  *report_id = openvas_uuid_make ();
  if (*report_id == NULL) return -2;

  /* Create the report. */

  report = make_report (task, *report_id, TASK_STATUS_RUNNING);

  if (scan_start)
    {
      sql ("UPDATE reports SET start_time = %i WHERE ROWID = %llu;",
           parse_iso_time (scan_start),
           report);
    }

  if (scan_end)
    {
      sql ("UPDATE reports SET end_time = %i WHERE ROWID = %llu;",
           parse_iso_time (scan_end),
           report);
    }

  /* Show that the upload has started. */

  set_task_run_status (task, TASK_STATUS_RUNNING);
  sql ("UPDATE tasks SET upload_result_count = %llu WHERE ROWID = %llu;",
       results->len,
       task);

  /* Fork a child to import the results while the parent responds to the
   * client. */

  pid = fork ();
  switch (pid)
    {
      case 0:
        /* Child.  Reopen the database (required after fork) and carry on
         * to import the reports, . */
        reinit_manage_process ();
        break;
      case -1:
        /* Parent when error. */
        g_warning ("%s: fork: %s\n", __FUNCTION__, strerror (errno));
        set_task_run_status (task, TASK_STATUS_INTERNAL_ERROR);
        return -1;
        break;
      default:
        /* Parent.  Return, in order to respond to client. */
        return 0;
        break;
    }

  /* Add the results. */

  /* This is faster, but causes problems on Debian 5 (sqlite 3.5.9). */
#if 0
  sql ("BEGIN IMMEDIATE;");
#endif

  index = 0;
  while ((start = (create_report_result_t*) g_ptr_array_index (host_starts,
                                                               index++)))
    if (start->host && start->description)
      {
        gchar *quoted_host;

        quoted_host = sql_quote (start->host);

        sql ("INSERT INTO report_hosts (report, host, start_time)"
             " VALUES (%llu, '%s', %i);",
             report,
             quoted_host,
             parse_iso_time (start->description));

        g_free (quoted_host);
      }

  index = 0;
  while ((result = (create_report_result_t*) g_ptr_array_index (results,
                                                                index++)))
    {
      gchar *quoted_subnet, *quoted_host, *quoted_port, *quoted_nvt_oid;
      gchar *quoted_description;

      quoted_subnet = sql_quote (result->subnet ? result->subnet : "");
      quoted_host = sql_quote (result->host ? result->host : "");
      quoted_port = sql_quote (result->port ? result->port : "");
      quoted_nvt_oid = sql_quote (result->nvt_oid ? result->nvt_oid : "");
      quoted_description = sql_quote (result->description
                                       ? result->description
                                       : "");

      sql ("INSERT INTO results"
           " (uuid, task, subnet, host, port, nvt, type, description)"
           " VALUES"
           " (make_uuid (), 0, '%s', '%s', '%s', '%s', '%s', '%s');",
           quoted_subnet,
           quoted_host,
           quoted_port,
           quoted_nvt_oid,
           result->threat
            ? threat_message_type (result->threat)
            : "Log Message",
           quoted_description);

      g_free (quoted_host);
      g_free (quoted_subnet);
      g_free (quoted_port);
      g_free (quoted_nvt_oid);
      g_free (quoted_description);

      report_add_result (report, sqlite3_last_insert_rowid (task_db));
    }

  index = 0;
  while ((end = (create_report_result_t*) g_ptr_array_index (host_ends,
                                                             index++)))
    if (end->host)
      {
        gchar *quoted_host;

        quoted_host = sql_quote (end->host);

        if (end->description)
          sql ("UPDATE report_hosts SET end_time = %i"
               " WHERE report = %llu AND host = '%s';",
               parse_iso_time (end->description),
               report,
               quoted_host);
        else
          sql ("UPDATE report_hosts SET end_time = NULL"
               " WHERE report = %llu AND host = '%s';",
               report,
               quoted_host);

        g_free (quoted_host);
      }

  index = 0;
  while ((detail = (host_detail_t*) g_ptr_array_index (details, index++)))
    if (detail->ip && detail->name)
      {
        gchar *quoted_ip, *quoted_source_type, *quoted_source_name;
        gchar *quoted_source_desc, *quoted_name, *quoted_value;

        quoted_ip = sql_quote (detail->ip);
        quoted_source_type = sql_quote (detail->source_type ?: "");
        quoted_source_name = sql_quote (detail->source_name ?: "");
        quoted_source_desc = sql_quote (detail->source_desc ?: "");
        quoted_name = sql_quote (detail->name);
        quoted_value = sql_quote (detail->value ?: "");

        sql ("INSERT INTO report_host_details"
             " (report_host, source_type, source_name, source_description,"
             "  name, value)"
             " VALUES"
             " ((SELECT ROWID FROM report_hosts"
             "   WHERE report = %llu AND host = '%s'),"
             "  '%s', '%s', '%s', '%s', '%s');",
             report,
             quoted_ip,
             quoted_source_type,
             quoted_source_name,
             quoted_source_desc,
             quoted_name,
             quoted_value);

        g_free (quoted_ip);
        g_free (quoted_source_type);
        g_free (quoted_source_name);
        g_free (quoted_source_desc);
        g_free (quoted_name);
        g_free (quoted_value);
      }

#if 0
  sql ("COMMIT;");
#endif

  current_scanner_task = task;
  current_report = report;
  set_task_run_status (task, TASK_STATUS_DONE);
  current_scanner_task = 0;
  current_report = 0;

  exit (EXIT_SUCCESS);
  /*@notreached@*/
  return 0;
}

/**
 * @brief Return the UUID of a report.
 *
 * @param[in]  report  Report.
 *
 * @return Report UUID.
 */
char*
report_uuid (report_t report)
{
  return sql_string (0, 0,
                     "SELECT uuid FROM reports WHERE ROWID = %llu;",
                     report);
}

/**
 * @brief Return the task of a report.
 *
 * @param[in]   report  A report.
 * @param[out]  task    Task return, 0 if succesfully failed to find task.
 *
 * @return FALSE on success (including if failed to find report), TRUE on error.
 */
gboolean
report_task (report_t report, task_t *task)
{
  switch (sql_int64 (task, 0, 0,
                     "SELECT task FROM reports WHERE ROWID = %llu;",
                     report))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *task = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        return TRUE;
        break;
    }
  return FALSE;
}

/**
 * @brief Add a result to a report.
 *
 * @param[in]  report  The report.
 * @param[in]  result  The result.
 */
void
report_add_result (report_t report, result_t result)
{
  sql ("INSERT into report_results (report, result)"
       " VALUES (%llu, %llu);",
       report, result);
  sql ("UPDATE results SET report = %llu WHERE ROWID = %llu;",
       report, result);
}

/**
 * @brief Initialise a report iterator.
 *
 * @param[in]  iterator  Iterator.
 * @param[in]  task      Task whose reports the iterator loops over.  0 for all.
 *                       Overridden by \arg report.
 * @param[in]  report    Single report to iterate over over.  0 for all.
 */
void
init_report_iterator (iterator_t* iterator, task_t task, report_t report)
{
  if (report)
    init_iterator (iterator,
                   "SELECT ROWID, uuid FROM reports WHERE ROWID = %llu;",
                   report);
  else if (task)
    init_iterator (iterator,
                   "SELECT ROWID, uuid FROM reports WHERE task = %llu;",
                   task);
  else
    {
      assert (current_credentials.uuid);
      init_iterator (iterator,
                     "SELECT ROWID, uuid FROM reports"
                     " WHERE ((owner IS NULL) OR owner ="
                     " (SELECT ROWID FROM users"
                     "  WHERE users.uuid = '%s'))"
                     " AND hidden = 0;",
                     current_credentials.uuid);
    }
}

#if 0
/**
 * @brief Get the NAME from a host iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The NAME of the host.  Caller must use only before calling
 *         cleanup_iterator.
 */
#endif


/**
 * @brief Get the UUID from a report iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return UUID, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (report_iterator_uuid, 1);

/**
 * @brief Read the next report from an iterator.
 *
 * @param[in]   iterator  Task iterator.
 * @param[out]  report    Report.
 *
 * @return TRUE if there was a next task, else FALSE.
 */
gboolean
next_report (iterator_t* iterator, report_t* report)
{
  int ret;

  if (iterator->done) return FALSE;

  while ((ret = sqlite3_step (iterator->stmt)) == SQLITE_BUSY);
  if (ret == SQLITE_DONE)
    {
      iterator->done = TRUE;
      return FALSE;
    }
  if (ret == SQLITE_ERROR || ret == SQLITE_MISUSE)
    {
      if (ret == SQLITE_ERROR) ret = sqlite3_reset (iterator->stmt);
      g_warning ("%s: sqlite3_step failed: %s\n",
                 __FUNCTION__,
                 sqlite3_errmsg (task_db));
      abort ();
    }
  *report = sqlite3_column_int64 (iterator->stmt, 0);
  return TRUE;
}

/**
 * @brief Return SQL WHERE for restricting a SELECT to levels.
 *
 * @param[in]  levels  String describing threat levels (message types)
 *                     to include in report (for example, "hmlgd" for
 *                     High, Medium, Low, loG and Debug).  All levels if
 *                     NULL.
 *
 * @return WHERE clause for levels if one is required, else NULL.
 */
static GString *
where_levels (const char* levels)
{
  int count;
  GString *levels_sql;

  /* Generate SQL for constraints on message type, according to levels. */

  if (levels == NULL || strlen (levels) == 0)
    return NULL;

  levels_sql = NULL;
  count = 0;

  /* High. */
  if (strchr (levels, 'h'))
    {
      count = 1;
      levels_sql = g_string_new (" AND new_type IN ('Security Hole'");
    }

  /* Medium. */
  if (strchr (levels, 'm'))
    {
      if (count == 0)
        levels_sql = g_string_new (" AND new_type IN ('Security Warning'");
      else
        levels_sql = g_string_append (levels_sql,
                                      ", 'Security Warning'");
      count++;
    }

  /* Low. */
  if (strchr (levels, 'l'))
    {
      if (count == 0)
        levels_sql = g_string_new (" AND new_type IN ('Security Note'");
      else
        levels_sql = g_string_append (levels_sql,
                                      ", 'Security Note'");
      count++;
    }

  /* loG. */
  if (strchr (levels, 'g'))
    {
      if (count == 0)
        levels_sql = g_string_new (" AND new_type IN ('Log Message'");
      else
        levels_sql = g_string_append (levels_sql,
                                      ", 'Log Message'");
      count++;
    }

  /* Debug. */
  if (strchr (levels, 'd'))
    {
      if (count == 0)
        levels_sql = g_string_new (" AND new_type IN ('Debug Message'");
      else
        levels_sql = g_string_append (levels_sql,
                                      ", 'Debug Message'");
      count++;
    }

  /* False Positive. */
  if (strchr (levels, 'f'))
    {
      if (count == 0)
        levels_sql = g_string_new (" AND new_type IN ('False Positive')");
      else
        levels_sql = g_string_append (levels_sql,
                                      ", 'False Positive')");
      count++;
    }
  else if (count)
    levels_sql = g_string_append (levels_sql, ")");

  if (count == 6)
    {
      /* All levels. */
      g_string_free (levels_sql, TRUE);
      levels_sql = NULL;
    }

  return levels_sql;
}

/**
 * @brief Return SQL WHERE for restricting a SELECT to levels.
 *
 * @param[in]  levels  String describing threat levels (message types)
 *                     to include in report (for example, "hmlgd" for
 *                     High, Medium, Low, loG and Debug).  All levels if
 *                     NULL.
 *
 * @return WHERE clause for levels if one is required, else NULL.
 */
static GString *
where_levels_auto (const char* levels)
{
  int count;
  GString *levels_sql;

  /* Generate SQL for constraints on message type, according to levels. */

  if (levels == NULL || strlen (levels) == 0)
    return NULL;

  levels_sql = NULL;
  count = 0;

  /* High. */
  if (strchr (levels, 'h'))
    {
      count = 1;
      levels_sql = g_string_new (" AND (((auto_type IS NULL) AND new_type IN ('Security Hole'");
    }

  /* Medium. */
  if (strchr (levels, 'm'))
    {
      if (count == 0)
        levels_sql = g_string_new (" AND (((auto_type IS NULL) AND new_type IN ('Security Warning'");
      else
        levels_sql = g_string_append (levels_sql,
                                      ", 'Security Warning'");
      count++;
    }

  /* Low. */
  if (strchr (levels, 'l'))
    {
      if (count == 0)
        levels_sql = g_string_new (" AND (((auto_type IS NULL) AND new_type IN ('Security Note'");
      else
        levels_sql = g_string_append (levels_sql,
                                      ", 'Security Note'");
      count++;
    }

  /* loG. */
  if (strchr (levels, 'g'))
    {
      if (count == 0)
        levels_sql = g_string_new (" AND (((auto_type IS NULL) AND new_type IN ('Log Message'");
      else
        levels_sql = g_string_append (levels_sql,
                                      ", 'Log Message'");
      count++;
    }

  /* Debug. */
  if (strchr (levels, 'd'))
    {
      if (count == 0)
        levels_sql = g_string_new (" AND (((auto_type IS NULL) AND new_type IN ('Debug Message'");
      else
        levels_sql = g_string_append (levels_sql,
                                      ", 'Debug Message'");
      count++;
    }

  /* False Positive. */
  if (strchr (levels, 'f'))
    {
      if (count == 0)
        levels_sql = g_string_new (" AND (((auto_type IS NULL) AND new_type IN ('False Positive')) OR auto_type = 1)");
      else
        levels_sql = g_string_append (levels_sql,
                                      ", 'False Positive')) OR auto_type = 1)");
      count++;
    }
  else if (count)
    levels_sql = g_string_append (levels_sql, ")))");

  if (count == 6)
    {
      /* All levels. */
      g_string_free (levels_sql, TRUE);
      levels_sql = NULL;
    }

  return levels_sql;
}

/**
 * @brief Return SQL WHERE for restricting a SELECT to levels by type column.
 *
 * @param[in]  levels  String describing threat levels (message types)
 *                     to include in report (for example, "hmlgd" for
 *                     High, Medium, Low, loG and Debug).  All levels if
 *                     NULL.
 *
 * @return WHERE clause for levels if one is required, else NULL.
 */
static GString *
where_levels_type (const char* levels)
{
  int count;
  GString *levels_sql;

  /* Generate SQL for constraints on message type, according to levels. */

  if (levels == NULL || strlen (levels) == 0)
    return NULL;

  levels_sql = NULL;
  count = 0;

  /* High. */
  if (strchr (levels, 'h'))
    {
      count = 1;
      levels_sql = g_string_new (" AND (type = 'Security Hole'");
    }

  /* Medium. */
  if (strchr (levels, 'm'))
    {
      if (count == 0)
        levels_sql = g_string_new (" AND (type = 'Security Warning'");
      else
        levels_sql = g_string_append (levels_sql,
                                      " OR type = 'Security Warning'");
      count++;
    }

  /* Low. */
  if (strchr (levels, 'l'))
    {
      if (count == 0)
        levels_sql = g_string_new (" AND (type = 'Security Note'");
      else
        levels_sql = g_string_append (levels_sql,
                                      " OR type = 'Security Note'");
      count++;
    }

  /* loG. */
  if (strchr (levels, 'g'))
    {
      if (count == 0)
        levels_sql = g_string_new (" AND (type = 'Log Message'");
      else
        levels_sql = g_string_append (levels_sql,
                                      " OR type = 'Log Message'");
      count++;
    }

  /* Debug. */
  if (strchr (levels, 'd'))
    {
      if (count == 0)
        levels_sql = g_string_new (" AND (type = 'Debug Message')");
      else
        levels_sql = g_string_append (levels_sql,
                                      " OR type = 'Debug Message')");
      count++;
    }
  else if (count)
    levels_sql = g_string_append (levels_sql, ")");

  if (count == 5)
    {
      /* All levels. */
      g_string_free (levels_sql, TRUE);
      levels_sql = NULL;
    }

  return levels_sql;
}

/**
 * @brief Return SQL WHERE for restricting a SELECT to a minimum CVSS base.
 *
 * @param[in]  min_cvss_base  Minimum value for CVSS.
 *
 * @return WHERE clause if one is required, else NULL.
 */
static GString *
where_cvss_base (const char* min_cvss_base)
{
  if (min_cvss_base)
    {
      GString *cvss_sql;
      gchar *quoted_min_cvss_base;

      if (strlen (min_cvss_base) == 0)
        return NULL;

      quoted_min_cvss_base = sql_quote (min_cvss_base);
      cvss_sql = g_string_new ("");
      g_string_append_printf (cvss_sql,
                              " AND CAST ((SELECT cvss_base FROM nvts WHERE nvts.oid = results.nvt) AS REAL)"
                              " >= CAST ('%s' AS REAL)",
                              quoted_min_cvss_base);
      g_free (quoted_min_cvss_base);

      return cvss_sql;
    }
  return NULL;
}

/**
 * @brief Return SQL WHERE for restricting a SELECT to a search phrase.
 *
 * @param[in]  search_phrase  Phrase that results must include.  All results if
 *                            NULL or "".
 * @param[in]  exact          Whether match must be exact.
 *
 * @return WHERE clause for search phrase if one is required, else NULL.
 */
static GString *
where_search_phrase (const char* search_phrase, int exact)
{
  if (search_phrase)
    {
      GString *phrase_sql;
      gchar *quoted_search_phrase;

      if (strlen (search_phrase) == 0)
        return NULL;

      quoted_search_phrase = sql_quote (search_phrase);
      phrase_sql = g_string_new ("");
      if (exact)
        g_string_append_printf (phrase_sql,
                                " AND (port = '%s'"
                                " OR host = '%s'"
                                " OR nvt = '%s'"
                                " OR nvt IN (SELECT oid FROM nvts"
                                "            WHERE tag LIKE '%%%%=%s|%%%%'"
                                "             OR cve LIKE '%%%%%s%%%%')"
                                " OR description = '%s')",
                                quoted_search_phrase,
                                quoted_search_phrase,
                                quoted_search_phrase,
                                quoted_search_phrase,
                                quoted_search_phrase,
                                quoted_search_phrase);
      else
        g_string_append_printf (phrase_sql,
                                " AND (port LIKE '%%%%%s%%%%'"
                                " OR host LIKE '%%%%%s%%%%'"
                                " OR nvt LIKE '%%%%%s%%%%'"
                                " OR nvt IN (SELECT oid FROM nvts"
                                "            WHERE tag LIKE '%%=%%%%%s%%%%|%%'"
                                "             OR cve LIKE '%%%%%s%%%%')"
                                " OR description LIKE '%%%%%s%%%%')",
                                quoted_search_phrase,
                                quoted_search_phrase,
                                quoted_search_phrase,
                                quoted_search_phrase,
                                quoted_search_phrase,
                                quoted_search_phrase);
      g_free (quoted_search_phrase);

      return phrase_sql;
    }
  return NULL;
}

/**
 * @brief SQL list of LSC families.
 */
#define LSC_FAMILY_LIST                  \
  "'AIX Local Security Checks',"         \
  " 'CentOS Local Security Checks',"     \
  " 'Debian Local Security Checks',"     \
  " 'Fedora Local Security Checks',"     \
  " 'FreeBSD Local Security Checks',"    \
  " 'Gentoo Local Security Checks',"     \
  " 'HP-UX Local Security Checks',"      \
  " 'Mac OS X Local Security Checks',"   \
  " 'Mandrake Local Security Checks',"   \
  " 'Red Hat Local Security Checks',"    \
  " 'Solaris Local Security Checks',"    \
  " 'SuSE Local Security Checks',"       \
  " 'Ubuntu Local Security Checks',"     \
  " 'Windows : Microsoft Bulletins',"    \
  " 'Privilege escalation'"

/**
 * @brief Return SQL WHERE for restricting a SELECT for auto FP filter.
 *
 * @param[in] autofp  Whether to apply the auto FP filter.
 * @param[in] report  Report.
 *
 * @return WHERE clause for autofp if desired, else NULL.
 */
static GString *
where_autofp (int autofp, report_t report)
{
  GString *autofp_sql;
  switch (autofp)
    {
      case 1:
        autofp_sql = g_string_new ("");
        g_string_append_printf
         (autofp_sql,
          " AND"
          " (((SELECT family FROM nvts WHERE oid = results.nvt)"
          "   IN (" LSC_FAMILY_LIST "))"
          "  OR results.nvt == '0'"
          "  OR"
          "  (SELECT ROWID FROM nvts"
          "   WHERE oid = results.nvt"
          "   AND"
          "   (cve == 'NOCVE'"
          "    OR cve NOT IN (SELECT cve FROM nvts"
          "                   WHERE oid IN (SELECT source_name"
          "                                 FROM report_host_details"
          "                                 WHERE report_host"
          "                                 = (SELECT id"
          "                                    FROM report_hosts"
          "                                    WHERE report = %llu"
          "                                    AND host = results.host)"
          "                                 AND name = 'EXIT_CODE'"
          "                                 AND value = 'EXIT_NOTVULN')"
          "                   AND family IN (" LSC_FAMILY_LIST ")))))",
          report);
        break;
      case 2:
        autofp_sql = g_string_new ("");
        g_string_append_printf
         (autofp_sql,
          " AND"
          " (((SELECT family FROM nvts WHERE oid = results.nvt)"
          "   IN (" LSC_FAMILY_LIST "))"
          "  OR results.nvt == '0'"
          "  OR"
          "  (SELECT ROWID FROM nvts AS outer_nvts"
          "   WHERE oid = results.nvt"
          "   AND"
          "   (cve == 'NOCVE'"
          "    OR NOT EXISTS"
          "       (SELECT cve FROM nvts"
          "        WHERE oid IN (SELECT source_name"
          "                      FROM report_host_details"
          "                      WHERE report_host"
          "                      = (SELECT id"
          "                         FROM report_hosts"
          "                         WHERE report = %llu"
          "                         AND host = results.host)"
          "                      AND name = 'EXIT_CODE'"
          "                      AND value = 'EXIT_NOTVULN')"
          "        AND family IN (" LSC_FAMILY_LIST ")"
          /* The CVE of the result NVT is outer_nvts.cve.  The CVE of the
           * NVT that has registered the "closed" host detail is nvts.cve.
           * Either can be a list of CVEs. */
          "        AND common_cve (nvts.cve, outer_nvts.cve)))))",
          report);
        break;
      default:
        return NULL;
    }
  return autofp_sql;
}

/**
 * @brief Initialise a result iterator.
 *
 * The results are ordered by host, then port and type (severity) according
 * to sort_field.
 *
 * @param[in]  iterator       Iterator.
 * @param[in]  report         Report whose results the iterator loops over,
 *                            or 0 to use result.
 * @param[in]  result         Single result to iterate over.  0 for all.
 *                            Overridden by report.
 * @param[in]  first_result   The result to start from.  The results are 0
 *                            indexed.
 * @param[in]  max_results    The maximum number of results returned.
 * @param[in]  ascending      Whether to sort ascending or descending.
 * @param[in]  sort_field     Field to sort on, or NULL for "type".
 * @param[in]  levels         String describing threat levels (message types)
 *                            to include in report (for example, "hmlgdf" for
 *                            High, Medium, Low, loG, Debug and False positive).
 *                            All levels if NULL.
 * @param[in]  autofp         Whether to apply auto FP filter.
 * @param[in]  search_phrase  Phrase that results must include.  All results if
 *                            NULL or "".
 * @param[in]  search_phrase_exact  Whether search phrase is exact.
 * @param[in]  min_cvss_base  Minimum value for CVSS.  All results if NULL.
 * @param[in]  override       Whether to override the threat.
 */
void
init_result_iterator (iterator_t* iterator, report_t report, result_t result,
                      int first_result, int max_results,
                      int ascending, const char* sort_field, const char* levels,
                      int autofp, const char* search_phrase,
                      int search_phrase_exact, const char* min_cvss_base,
                      int override)
{
  GString *levels_sql, *phrase_sql, *cvss_sql;
  gchar* sql;

  assert ((report && result) == 0);

  /* Allocate the query. */

  if (report)
    {
      gchar *new_type_sql, *auto_type_sql;

      if (sort_field == NULL) sort_field = "type";
      if (levels == NULL) levels = "hmlgdf";

      levels_sql = where_levels_auto (levels);
      phrase_sql = where_search_phrase (search_phrase, search_phrase_exact);
      cvss_sql = where_cvss_base (min_cvss_base);

      if (override)
        {
          gchar *ov;

          assert (current_credentials.uuid);

          ov = g_strdup_printf
                ("SELECT overrides.new_threat"
                 " FROM overrides"
                 " WHERE overrides.nvt = results.nvt"
                 " AND ((overrides.owner IS NULL)"
                 " OR (overrides.owner ="
                 " (SELECT ROWID FROM users"
                 "  WHERE users.uuid = '%s')))"
                 " AND ((overrides.end_time = 0)"
                 "      OR (overrides.end_time >= now ()))"
                 " AND (overrides.task ="
                 "      (SELECT reports.task FROM reports"
                 "       WHERE report_results.report = reports.ROWID)"
                 "      OR overrides.task = 0)"
                 " AND (overrides.result = results.ROWID"
                 "      OR overrides.result = 0)"
                 " AND (overrides.hosts is NULL"
                 "      OR overrides.hosts = \"\""
                 "      OR hosts_contains (overrides.hosts, results.host))"
                 " AND (overrides.port is NULL"
                 "      OR overrides.port = \"\""
                 "      OR overrides.port = results.port)"
                 " AND (overrides.threat is NULL"
                 "      OR overrides.threat = \"\""
                 "      OR overrides.threat = results.type)"
                 " ORDER BY overrides.result DESC, overrides.task DESC,"
                 " overrides.port DESC, overrides.threat"
                 " COLLATE collate_message_type ASC",
                 current_credentials.uuid);

          new_type_sql = g_strdup_printf ("coalesce ((%s), type)", ov);

          g_free (ov);
        }
      else
        new_type_sql = g_strdup ("type");

      switch (autofp)
        {
          case 1:
            auto_type_sql = g_strdup_printf
              ("(CASE WHEN"
               "  (((SELECT family FROM nvts WHERE oid = results.nvt)"
               "    IN (" LSC_FAMILY_LIST "))"
               "   OR results.nvt == '0'" /* Open ports have 0 NVT. */
               "   OR"
               "   (SELECT ROWID FROM nvts"
               "    WHERE oid = results.nvt"
               "    AND"
               "    (cve == 'NOCVE'"
               "     OR cve NOT IN (SELECT cve FROM nvts"
               "                    WHERE oid IN (SELECT source_name"
               "                                  FROM report_host_details"
               "                                  WHERE report_host"
               "                                  = (SELECT id"
               "                                     FROM report_hosts"
               "                                     WHERE report = %llu"
               "                                     AND host = results.host)"
               "                                  AND name = 'EXIT_CODE'"
               "                                  AND value = 'EXIT_NOTVULN')"
               "                    AND family IN (" LSC_FAMILY_LIST ")))))"
               " THEN NULL"
               " ELSE 1 END)",
               report);
            break;

          case 2:
            auto_type_sql = g_strdup_printf
              ("(CASE WHEN"
               "  (((SELECT family FROM nvts WHERE oid = results.nvt)"
               "    IN (" LSC_FAMILY_LIST "))"
               "   OR results.nvt == '0'" /* Open ports have 0 NVT. */
               "   OR"
               "   (SELECT ROWID FROM nvts AS outer_nvts"
               "    WHERE oid = results.nvt"
               "    AND"
               "    (cve == 'NOCVE'"
               "     OR NOT EXISTS"
               "        (SELECT cve FROM nvts"
               "         WHERE oid IN (SELECT source_name"
               "                       FROM report_host_details"
               "                       WHERE report_host"
               "                       = (SELECT id"
               "                          FROM report_hosts"
               "                          WHERE report = %llu"
               "                          AND host = results.host)"
               "                       AND name = 'EXIT_CODE'"
               "                       AND value = 'EXIT_NOTVULN')"
               "         AND family IN (" LSC_FAMILY_LIST ")"
               /* The CVE of the result NVT is outer_nvts.cve.  The CVE of the
                * NVT that has registered the "closed" host detail is nvts.cve.
                * Either can be a list of CVEs. */
               "         AND common_cve (nvts.cve, outer_nvts.cve)))))"
               " THEN NULL"
               " ELSE 1 END)",
               report);
             break;

           default:
             auto_type_sql = g_strdup ("NULL");
             break;
         }

      sql = g_strdup_printf ("SELECT results.ROWID, subnet, host, port,"
                             " nvt, type, %s AS new_type, %s AS auto_type,"
                             " results.description,"
                             " (SELECT cvss_base FROM nvts"
                             "  WHERE nvts.oid = results.nvt)"
                             " AS cvss_base"
                             " FROM results, report_results"
                             " WHERE report_results.report = %llu"
                             "%s"
                             "%s"
                             "%s"
                             " AND report_results.result = results.ROWID"
                             "%s"
                             " LIMIT %i OFFSET %i;",
                             new_type_sql,
                             auto_type_sql,
                             report,
                             levels_sql ? levels_sql->str : "",
                             phrase_sql ? phrase_sql->str : "",
                             cvss_sql ? cvss_sql->str : "",
                             ascending
                              ? ((strcmp (sort_field, "ROWID") == 0)
                                  ? " ORDER BY results.ROWID"
                                  : ((strcmp (sort_field, "port") == 0)
                                      ? " ORDER BY host COLLATE collate_ip,"
                                        " port,"
                                        " (CASE WHEN auto_type IS NULL"
                                        "  THEN new_type ELSE auto_type END)"
                                        " COLLATE collate_message_type DESC,"
                                        " (CAST ((CASE WHEN cvss_base >= 0.0"
                                        "        THEN cvss_base ELSE 0.0 END)"
                                        "       AS REAL)) DESC,"
                                        " nvt,"
                                        " description"
                                      : " ORDER BY host COLLATE collate_ip,"
                                        " (CASE WHEN auto_type IS NULL"
                                        "  THEN new_type ELSE auto_type END)"
                                        " COLLATE collate_message_type,"
                                        " port,"
                                        " (CAST ((CASE WHEN cvss_base >= 0.0"
                                        "        THEN cvss_base ELSE 0.0 END)"
                                        "       AS REAL)) DESC,"
                                        " nvt,"
                                        " description"))
                              : ((strcmp (sort_field, "ROWID") == 0)
                                  ? " ORDER BY results.ROWID DESC"
                                  : ((strcmp (sort_field, "port") == 0)
                                      ? " ORDER BY host COLLATE collate_ip,"
                                        " port DESC,"
                                        " (CASE WHEN auto_type IS NULL"
                                        "  THEN new_type ELSE auto_type END)"
                                        " COLLATE collate_message_type DESC,"
                                        " (CAST ((CASE WHEN cvss_base >= 0.0"
                                        "        THEN cvss_base ELSE 0.0 END)"
                                        "       AS REAL)) DESC,"
                                        " nvt,"
                                        " description"
                                      : " ORDER BY host COLLATE collate_ip,"
                                        " (CASE WHEN auto_type IS NULL"
                                        "  THEN new_type ELSE auto_type END)"
                                        " COLLATE collate_message_type DESC,"
                                        " port,"
                                        " (CAST ((CASE WHEN cvss_base >= 0.0"
                                        "        THEN cvss_base ELSE 0.0 END)"
                                        "       AS REAL)) DESC,"
                                        " nvt,"
                                        " description")),
                             max_results,
                             first_result);

      if (levels_sql) g_string_free (levels_sql, TRUE);
      if (phrase_sql) g_string_free (phrase_sql, TRUE);
      if (cvss_sql) g_string_free (cvss_sql, TRUE);
      g_free (new_type_sql);
      g_free (auto_type_sql);
    }
  else if (result)
    {
      gchar *new_type_sql, *auto_type_sql;

      if (override)
        {
          gchar *ov;

          assert (current_credentials.uuid);

          ov = g_strdup_printf
                ("SELECT overrides.new_threat"
                 " FROM overrides"
                 " WHERE overrides.nvt = results.nvt"
                 " AND ((overrides.owner IS NULL)"
                 " OR (overrides.owner ="
                 " (SELECT ROWID FROM users"
                 "  WHERE users.uuid = '%s')))"
                 " AND ((overrides.end_time = 0)"
                 "      OR (overrides.end_time >= now ()))"
                 " AND (overrides.task ="
                 "      (SELECT reports.task FROM reports, report_results"
                 "       WHERE report_results.result = results.ROWID"
                 "       AND report_results.report = reports.ROWID)"
                 "      OR overrides.task = 0)"
                 " AND (overrides.result = results.ROWID"
                 "      OR overrides.result = 0)"
                 " AND (overrides.hosts is NULL"
                 "      OR overrides.hosts = \"\""
                 "      OR hosts_contains (overrides.hosts, results.host))"
                 " AND (overrides.port is NULL"
                 "      OR overrides.port = \"\""
                 "      OR overrides.port = results.port)"
                 " AND (overrides.threat is NULL"
                 "      OR overrides.threat = \"\""
                 "      OR overrides.threat = results.type)"
                 " ORDER BY overrides.result DESC, overrides.task DESC,"
                 " overrides.port DESC, overrides.threat"
                 " COLLATE collate_message_type ASC",
                 current_credentials.uuid);

          new_type_sql = g_strdup_printf ("coalesce ((%s), type)", ov);

          g_free (ov);
        }
      else
        new_type_sql = g_strdup ("type");

      switch (autofp)
        {
          case 1:
            auto_type_sql = g_strdup_printf
              ("(CASE WHEN"
               "  (((SELECT family FROM nvts WHERE oid = results.nvt)"
               "    IN (" LSC_FAMILY_LIST "))"
               "   OR results.nvt == '0'" /* Open ports have 0 NVT. */
               "   OR"
               "   (SELECT ROWID FROM nvts"
               "    WHERE oid = results.nvt"
               "    AND"
               "    (cve == 'NOCVE'"
               "     OR cve NOT IN"
               "        (SELECT cve FROM nvts"
               "         WHERE oid IN (SELECT source_name"
               "                       FROM report_host_details"
               "                       WHERE report_host"
               "                       = (SELECT id"
               "                          FROM report_hosts"
               "                          WHERE report = (SELECT report"
               "                                          FROM report_results"
               "                                          WHERE result = %llu)"
               "                          AND host = results.host)"
               "                          AND name = 'EXIT_CODE'"
               "                          AND value = 'EXIT_NOTVULN')"
               "         AND family IN (" LSC_FAMILY_LIST ")))))"
               " THEN NULL"
               " ELSE 1 END)",
               result);
            break;

          case 2:
            auto_type_sql = g_strdup_printf
              ("(CASE WHEN"
               "  (((SELECT family FROM nvts WHERE oid = results.nvt)"
               "    IN (" LSC_FAMILY_LIST "))"
               "   OR results.nvt == '0'" /* Open ports have 0 NVT. */
               "   OR"
               "   (SELECT ROWID FROM nvts AS outer_nvts"
               "    WHERE oid = results.nvt"
               "    AND"
               "    (cve == 'NOCVE'"
               "     OR NOT EXISTS"
               "        (SELECT cve FROM nvts"
               "         WHERE oid IN (SELECT source_name"
               "                       FROM report_host_details"
               "                       WHERE report_host"
               "                       = (SELECT id"
               "                          FROM report_hosts"
               "                          WHERE report = (SELECT report"
               "                                          FROM report_results"
               "                                          WHERE result = %llu)"
               "                          AND host = results.host)"
               "                       AND name = 'EXIT_CODE'"
               "                       AND value = 'EXIT_NOTVULN')"
               "         AND family IN (" LSC_FAMILY_LIST ")"
               /* The CVE of the result NVT is outer_nvts.cve.  The CVE of the
                * NVT that has registered the "closed" host detail is nvts.cve.
                * Either can be a list of CVEs. */
               "         AND common_cve (nvts.cve, outer_nvts.cve)))))"
               " THEN NULL"
               " ELSE 1 END)",
               result);
             break;

           default:
             auto_type_sql = g_strdup ("NULL");
             break;
         }

      sql = g_strdup_printf ("SELECT ROWID, subnet, host, port, nvt,"
                             " type, %s, %s, description"
                             " FROM results"
                             " WHERE ROWID = %llu;",
                             new_type_sql,
                             auto_type_sql,
                             result);

      g_free (new_type_sql);
      g_free (auto_type_sql);
    }
  else
    sql = g_strdup_printf ("SELECT results.ROWID, subnet, host, port, nvt,"
                           " type, type, type, description"
                           " FROM results, report_results, reports"
                           " WHERE results.ROWID = report_results.result"
                           " AND report_results.report = reports.ROWID"
                           " AND reports.owner ="
                           " (SELECT ROWID FROM users WHERE uuid = '%s');",
                           current_credentials.uuid);

  init_iterator (iterator, sql);
  g_free (sql);
}

/**
 * @brief Get the result from a result iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The result.
 */
result_t
result_iterator_result (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (result_t) sqlite3_column_int64 (iterator->stmt, 0);
}

#if 0
/**
 * @brief Get the subnet from a result iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The subnet of the result as a newly allocated string, or NULL on
 *         error.
 */
char*
result_iterator_subnet (iterator_t* iterator)
{
  const char *ret;
  if (iterator->done) return NULL;
  ret = (const char*) sqlite3_column_text (iterator->stmt, 1);
  return ret ? g_strdup (ret) : NULL;
}
#endif

/**
 * @brief Get the subnet from a result iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The subnet of the result.  Caller must only use before calling
 *         cleanup_iterator.
 */
DEF_ACCESS (result_iterator_subnet, 1);

/**
 * @brief Get the host from a result iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The host of the result.  Caller must only use before calling
 *         cleanup_iterator.
 */
DEF_ACCESS (result_iterator_host, 2);

/**
 * @brief Get the port from a result iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The port of the result.  Caller must only use before calling
 *         cleanup_iterator.
 */
DEF_ACCESS (result_iterator_port, 3);

/**
 * @brief Get the NVT OID from a result iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The NVT OID of the result.  Caller must only use before calling
 *         cleanup_iterator.
 */
DEF_ACCESS (result_iterator_nvt_oid, 4);

/**
 * @brief Get the NVT name from a result iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The name of the NVT that produced the result, or NULL on error.
 */
const char*
result_iterator_nvt_name (iterator_t *iterator)
{
  nvti_t *nvti;
  if (iterator->done) return NULL;
  nvti = nvtis_lookup (nvti_cache, result_iterator_nvt_oid (iterator));
  if (nvti)
    return nvti_name (nvti);
  return NULL;
}

/**
 * @brief Get the NVT family from a result iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The family of the NVT that produced the result, or NULL on error.
 */
const char*
result_iterator_nvt_family (iterator_t *iterator)
{
  nvti_t *nvti;
  if (iterator->done) return NULL;
  nvti = nvtis_lookup (nvti_cache, result_iterator_nvt_oid (iterator));
  if (nvti)
    return nvti_family (nvti);
  return NULL;
}

/**
 * @brief Get the NVT CVSS base value from a result iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The CVSS base of the NVT that produced the result, or NULL on error.
 */
const char*
result_iterator_nvt_cvss_base (iterator_t *iterator)
{
  nvti_t *nvti;
  if (iterator->done) return NULL;
  nvti = nvtis_lookup (nvti_cache, result_iterator_nvt_oid (iterator));
  if (nvti)
    return nvti_cvss_base (nvti);
  return NULL;
}

/**
 * @brief Get the NVT risk factor from a result iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The risk factor of the NVT that produced the result, or NULL on error.
 */
const char*
result_iterator_nvt_risk_factor (iterator_t *iterator)
{
  nvti_t *nvti;
  if (iterator->done) return NULL;
  nvti = nvtis_lookup (nvti_cache, result_iterator_nvt_oid (iterator));
  if (nvti)
    return nvti_risk_factor (nvti);
  return NULL;
}

/**
 * @brief Get the NVT CVE from a result iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The CVE of the NVT that produced the result, or NULL on error.
 */
const char*
result_iterator_nvt_cve (iterator_t *iterator)
{
  nvti_t *nvti;
  if (iterator->done) return NULL;
  nvti = nvtis_lookup (nvti_cache, result_iterator_nvt_oid (iterator));
  if (nvti)
    return nvti_cve (nvti);
  return NULL;
}

/**
 * @brief Get the NVT BID from a result iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The BID of the NVT that produced the result, or NULL on error.
 */
const char*
result_iterator_nvt_bid (iterator_t *iterator)
{
  nvti_t *nvti;
  if (iterator->done) return NULL;
  nvti = nvtis_lookup (nvti_cache, result_iterator_nvt_oid (iterator));
  if (nvti)
    return nvti_bid (nvti);
  return NULL;
}

/**
 * @brief Get the NVT XREF from a result iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The XREF of the NVT that produced the result, or NULL on error.
 */
const char*
result_iterator_nvt_xref (iterator_t *iterator)
{
  nvti_t *nvti;
  if (iterator->done) return NULL;
  nvti = nvtis_lookup (nvti_cache, result_iterator_nvt_oid (iterator));
  if (nvti)
    return nvti_xref (nvti);
  return NULL;
}

/**
 * @brief Get the NVT tags from a result iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The tags of the NVT that produced the result, or NULL on error.
 */
const char*
result_iterator_nvt_tag (iterator_t *iterator)
{
  nvti_t *nvti;
  if (iterator->done) return NULL;
  nvti = nvtis_lookup (nvti_cache, result_iterator_nvt_oid (iterator));
  if (nvti)
    return nvti_tag (nvti);
  return NULL;
}

/**
 * @brief Get the original type from a result iterator.
 *
 * This is the column 'type'.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The original type of the result.  Caller must only use before calling
 *         cleanup_iterator.
 */
DEF_ACCESS (result_iterator_original_type, 5);

/**
 * @brief Get the original type from a result iterator.
 *
 * This is the the autofp adjusted overridden type.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The type of the result.  Caller must only use before calling
 *         cleanup_iterator.
 */
const char*
result_iterator_type (iterator_t *iterator)
{
  if (iterator->done) return NULL;
  /* auto_type */
  if (sqlite3_column_int (iterator->stmt, 7))
    return "False Positive";
  /* new_type */
  return (const char*) sqlite3_column_text (iterator->stmt, 6);
}

/**
 * @brief Get the descr from a result iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The descr of the result.  Caller must only use before calling
 *         cleanup_iterator.
 */
DEF_ACCESS (result_iterator_descr, 8);

/**
 * @brief Get the CVSS base from a result iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return CVSS base of result NVT.
 */
double
result_iterator_nvt_cvss_base_double (iterator_t* iterator)
{
  if (iterator->done) return -1;
  return sqlite3_column_double (iterator->stmt, 9);
}

/**
 * @brief Initialise a host iterator.
 *
 * @param[in]  iterator  Iterator.
 * @param[in]  report    Report whose hosts the iterator loops over.
 * @param[in]  host      Single host to iterate over.  All hosts if NULL.
 * @param[in]  report_host  Single report host to iterate over.  All if 0.
 */
void
init_host_iterator (iterator_t* iterator, report_t report, const char *host,
                    report_host_t report_host)
{
  if (report)
    {
      if (report_host)
        init_iterator (iterator,
                       "SELECT ROWID, host, iso_time (start_time),"
                       " iso_time (end_time), attack_state, current_port,"
                       " max_port, report,"
                       " (SELECT uuid FROM reports WHERE ROWID = report)"
                       " FROM report_hosts WHERE ROWID = %llu"
                       " AND report = %llu"
                       "%s%s%s"
                       " ORDER BY host COLLATE collate_ip;",
                       report_host,
                       report,
                       host ? " AND host = '" : "",
                       host ? host : "",
                       host ? "'" : "");
      else
        init_iterator (iterator,
                       "SELECT ROWID, host, iso_time (start_time),"
                       " iso_time (end_time), attack_state, current_port,"
                       " max_port, report,"
                       " (SELECT uuid FROM reports WHERE ROWID = report)"
                       " FROM report_hosts WHERE report = %llu"
                       "%s%s%s"
                       " ORDER BY host COLLATE collate_ip;",
                       report,
                       host ? " AND host = '" : "",
                       host ? host : "",
                       host ? "'" : "");
    }
  else
    {
      if (report_host)
        init_iterator (iterator,
                       "SELECT ROWID, host, iso_time (start_time),"
                       " iso_time (end_time), attack_state, current_port,"
                       " max_port, report,"
                       " (SELECT uuid FROM reports WHERE ROWID = report)"
                       " FROM report_hosts WHERE ROWID = %llu"
                       "%s%s%s"
                       " ORDER BY host COLLATE collate_ip;",
                       report_host,
                       host ? " AND host = '" : "",
                       host ? host : "",
                       host ? "'" : "");
      else
        init_iterator (iterator,
                       "SELECT ROWID, host, iso_time (start_time),"
                       " iso_time (end_time), attack_state, current_port,"
                       " max_port, report,"
                       " (SELECT uuid FROM reports WHERE ROWID = report)"
                       " FROM report_hosts"
                       "%s%s%s"
                       " ORDER BY host COLLATE collate_ip;",
                       host ? " WHERE host = '" : "",
                       host ? host : "",
                       host ? "'" : "");
    }
}


/**
 * @brief Get the report host from a host iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Report host.
 */
static report_host_t
host_iterator_report_host (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (report_host_t) sqlite3_column_int64 (iterator->stmt, 0);
}

/**
 * @brief Get the host from a host iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The host of the host.  Caller must use only before calling
 *         cleanup_iterator.
 */
DEF_ACCESS (host_iterator_host, 1);

/**
 * @brief Get the start time from a host iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The start time of the host.  Caller must use only before calling
 *         cleanup_iterator.
 */
DEF_ACCESS (host_iterator_start_time, 2);

/**
 * @brief Get the end time from a host iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The end time of the host.  Caller must use only before calling
 *         cleanup_iterator.
 */
DEF_ACCESS (host_iterator_end_time, 3);

/**
 * @brief Get the attack state from a host iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The attack state of the host.  Caller must use only before calling
 *         cleanup_iterator.
 */
DEF_ACCESS (host_iterator_attack_state, 4);

/**
 * @brief Get the current port from a host iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Current port.
 */
int
host_iterator_current_port (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (int) sqlite3_column_int (iterator->stmt, 5);
  return ret;
}

/**
 * @brief Get the max port from a host iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Current port.
 */
int
host_iterator_max_port (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (int) sqlite3_column_int (iterator->stmt, 6);
  return ret;
}

/**
 * @brief Get the report from a host iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The report of the host.
 */
static report_host_t
host_iterator_report (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (report_host_t) sqlite3_column_int64 (iterator->stmt, 7);
}

/**
 * @brief Get the report UUID from a host iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The UUID of the report of the host.  Caller must use only before
 *         calling cleanup_iterator.
 */
DEF_ACCESS (host_iterator_report_uuid, 8);

/**
 * @brief Return whether a host has results on a report.
 *
 * @param[in]  report  Report.
 * @param[in]  host    Host.
 *
 * @return 1 if host has results, else 0.
 */
int
manage_report_host_has_results (report_t report, const char *host)
{
  char *quoted_host = sql_quote ((gchar*) host);
  int ret = sql_int (0, 0,
                     "SELECT COUNT(*) > 0 FROM results, report_results"
                     " WHERE report_results.report = %llu"
                     " AND report_results.result = results.ROWID"
                     " AND results.host = '%s';",
                     report,
                     quoted_host);
  g_free (quoted_host);
  return ret ? 1 : 0;
}

/**
 * @brief Initialise a report host details iterator.
 *
 * @param[in]  iterator     Iterator.
 * @param[in]  report_host  Report host whose details the iterator loops over.
 *                          All report_hosts if NULL.
 */
static void
init_report_host_details_iterator (iterator_t* iterator,
                                   report_host_t report_host)
{
  /* The 'detected_at' and 'detected_by' entries are filtered out of the final
   * reports as they are only used internally for product detection. */
  init_iterator (iterator,
                 "SELECT ROWID, name, value, source_type, source_name,"
                 " source_description"
                 " FROM report_host_details WHERE report_host = %llu"
                 " AND NOT name IN ('detected_at', 'detected_by')"
                 " UNION"
                 " SELECT 0, 'Closed CVE', cve, 'openvasmd', oid, name"
                 " FROM nvts"
                 " WHERE cve != 'NOCVE'"
                 " AND family IN (" LSC_FAMILY_LIST ")"
                 " AND oid IN"
                 " (SELECT source_name FROM report_host_details"
                 "  WHERE report_host = %llu"
                 "  AND name = 'EXIT_CODE'"
                 "  AND value = 'EXIT_NOTVULN');",
                 report_host,
                 report_host);
}

/**
 * @brief Get the name from a report host details iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The name of the report host detail.  Caller must use only before
 *         calling cleanup_iterator.
 */
DEF_ACCESS (report_host_details_iterator_name, 1);

/**
 * @brief Get the value from a report host details iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The value of the report host detail.  Caller must use only before
 *         calling cleanup_iterator.
 */
DEF_ACCESS (report_host_details_iterator_value, 2);

/**
 * @brief Get the source type from a report host details iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The source type of the report host detail.  Caller must use only
 *         before calling cleanup_iterator.
 */
DEF_ACCESS (report_host_details_iterator_source_type, 3);

/**
 * @brief Get the source name from a report host details iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The source name of the report host detail.  Caller must use only
 *         before calling cleanup_iterator.
 */
DEF_ACCESS (report_host_details_iterator_source_name, 4);

/**
 * @brief Get the source description from a report host details iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The source description of the report host detail.  Caller must use
 *         only before calling cleanup_iterator.
 */
DEF_ACCESS (report_host_details_iterator_source_desc, 5);

/**
 * @brief Initialise an asset iterator.
 *
 * @param[in]  iterator  Iterator.
 * @param[in]  first_result  The host to start from.  The hosts are 0
 *                           indexed.
 * @param[in]  max_results   The maximum number of hosts returned.
 * @param[in]  levels         String describing threat levels (message types)
 *                            to include in hosts (for example, "hml" for
 *                            High, Medium and Low).  All levels if NULL.
 * @param[in]  search_phrase  Phrase that host IPs must include.  All
 *                            hosts if NULL or "".
 * @param[in]  apply_overrides  Whether to apply overrides.
 */
static void
init_asset_iterator (iterator_t* iterator, int first_result,
                     int max_results, const char *levels,
                     const char *search_phrase, int apply_overrides)
{
  assert (current_credentials.uuid);

  if (levels && strlen (levels))
    {
      GString *levels_sql;
      gchar *new_type_sql;

      if (apply_overrides)
        {
          gchar *ov;

          assert (current_credentials.uuid);

          ov = g_strdup_printf
                ("SELECT overrides.new_threat"
                 " FROM overrides"
                 " WHERE overrides.nvt = results.nvt"
                 " AND ((overrides.owner IS NULL)"
                 " OR (overrides.owner ="
                 " (SELECT ROWID FROM users"
                 "  WHERE users.uuid = '%s')))"
                 " AND ((overrides.end_time = 0)"
                 "      OR (overrides.end_time >= now ()))"
                 /** @todo Include tasks.hidden and task pref in_assets? */
                 " AND (overrides.task ="
                 "      (SELECT reports.task FROM reports, report_results"
                 "       WHERE report_results.result = results.ROWID"
                 "       AND report_results.report = reports.ROWID)"
                 "      OR overrides.task = 0)"
                 " AND (overrides.result = results.ROWID"
                 "      OR overrides.result = 0)"
                 " AND (overrides.hosts is NULL"
                 "      OR overrides.hosts = \"\""
                 "      OR hosts_contains (overrides.hosts, results.host))"
                 " AND (overrides.port is NULL"
                 "      OR overrides.port = \"\""
                 "      OR overrides.port = results.port)"
                 " AND (overrides.threat is NULL"
                 "      OR overrides.threat = \"\""
                 "      OR overrides.threat = results.type)"
                 " ORDER BY overrides.result DESC, overrides.task DESC,"
                 " overrides.port DESC, overrides.threat"
                 " COLLATE collate_message_type ASC",
                 current_credentials.uuid);

          new_type_sql = g_strdup_printf ("coalesce ((%s), type)", ov);

          g_free (ov);
        }
      else
        new_type_sql = g_strdup ("type");

      levels_sql = where_levels (levels);

      if (search_phrase && strlen (search_phrase))
        {
          gchar *quoted_search_phrase;

          quoted_search_phrase = sql_quote (search_phrase);
          init_iterator (iterator,
                         "SELECT"
                         " distinct_host,"
                         " (SELECT report FROM report_hosts"
                         "  WHERE report_hosts.host = distinct_host"
                         "  AND end_time IS NOT NULL"
                         "  AND end_time != ''"
                         "  AND (SELECT owner FROM reports"
                         "       WHERE ROWID = report)"
                         "      = (SELECT ROWID FROM users"
                         "         WHERE users.uuid = '%s')"
                         "  AND (SELECT reports.scan_run_status = %u"
                         "       FROM reports"
                         "       WHERE reports.ROWID = report)"
                         "  AND (SELECT hidden FROM tasks"
                         "       WHERE tasks.ROWID"
                         "             = (SELECT task FROM reports"
                         "                WHERE reports.ROWID = report))"
                         "      = 0"
                         "  AND (SELECT value FROM task_preferences"
                         "       WHERE task_preferences.task"
                         "             = (SELECT task FROM reports"
                         "                WHERE reports.ROWID = report)"
                         "       AND task_preferences.name = 'in_assets')"
                         "      = 'yes'"
                         "  ORDER BY ROWID DESC)"
                         "  AS last_report"
                         " FROM (SELECT DISTINCT host AS distinct_host"
                         "       FROM report_hosts"
                         "       ORDER BY host COLLATE collate_ip)"
                         /* Search IP. */
                         " WHERE (distinct_host LIKE '%%%s%%%'"
                         /* Search hostname. */
                         "        OR EXISTS"
                         "        (SELECT * FROM report_host_details"
                         "         WHERE report_host"
                         "               = (SELECT ROWID FROM report_hosts"
                         "                  WHERE report = last_report"
                         "                  AND host = distinct_host)"
                         "         AND (name = 'hostname'"
                         "              OR name = 'best_os_txt'"
                         "              OR name = 'best_os_cpe' OR name = 'App'"
                         "              OR name = 'ports')"
                         "         AND source_type = 'nvt'"
                         "         AND value LIKE '%%%s%%'))"
                         /* Filter levels. */
                         " AND EXISTS (SELECT results.ROWID, %s AS new_type"
                         "             FROM results"
                         "             WHERE results.report = last_report"
                         "             AND results.host = distinct_host"
                         "             %s)"
                         " LIMIT %i OFFSET %i;",
                         current_credentials.uuid,
                         TASK_STATUS_DONE,
                         quoted_search_phrase,
                         quoted_search_phrase,
                         new_type_sql,
                         levels_sql ? levels_sql->str : "",
                         max_results,
                         first_result);
          g_free (quoted_search_phrase);
        }
      else
        init_iterator (iterator,
                       "SELECT"
                       " distinct_host,"
                       " (SELECT report FROM report_hosts"
                       "  WHERE report_hosts.host = distinct_host"
                       "  AND end_time IS NOT NULL"
                       "  AND end_time != ''"
                       "  AND (SELECT owner FROM reports"
                       "       WHERE ROWID = report)"
                       "      = (SELECT ROWID FROM users"
                       "         WHERE users.uuid = '%s')"
                       "  AND (SELECT reports.scan_run_status = %u"
                       "       FROM reports"
                       "       WHERE reports.ROWID = report)"
                       "  AND (SELECT hidden FROM tasks"
                       "       WHERE tasks.ROWID"
                       "             = (SELECT task FROM reports"
                       "                WHERE reports.ROWID = report))"
                       "      = 0"
                       "  AND (SELECT value FROM task_preferences"
                       "       WHERE task_preferences.task"
                       "             = (SELECT task FROM reports"
                       "                WHERE reports.ROWID = report)"
                       "       AND task_preferences.name = 'in_assets')"
                       "      = 'yes'"
                       "  ORDER BY ROWID DESC)"
                       "  AS last_report"
                       " FROM (SELECT DISTINCT host AS distinct_host"
                       "       FROM report_hosts"
                       "       ORDER BY host COLLATE collate_ip)"
                       " WHERE EXISTS (SELECT results.ROWID, %s AS new_type"
                       "               FROM results"
                       "               WHERE results.report = last_report"
                       "               AND results.host = distinct_host"
                       "               %s)"
                       " LIMIT %i OFFSET %i;",
                       current_credentials.uuid,
                       TASK_STATUS_DONE,
                       new_type_sql,
                       levels_sql ? levels_sql->str : "",
                       max_results,
                       first_result);

      if (levels_sql)
        g_string_free (levels_sql, TRUE);
      g_free (new_type_sql);
    }
  else if (search_phrase && strlen (search_phrase))
    {
      gchar *quoted_search_phrase;

      quoted_search_phrase = sql_quote (search_phrase);
      init_iterator (iterator,
                     "SELECT host"
                     " FROM report_hosts"
                     " WHERE (SELECT reports.owner FROM reports"
                     "        WHERE reports.ROWID = report_hosts.report)"
                     "       = (SELECT ROWID FROM users"
                     "          WHERE users.uuid = '%s')"
                     " AND (SELECT tasks.hidden FROM tasks, reports"
                     "      WHERE reports.task = tasks.ROWID"
                     "      AND reports.ROWID = report_hosts.report)"
                     "     = 0"
                     " AND (SELECT value FROM task_preferences, tasks,"
                     "                        reports"
                     "      WHERE reports.task = tasks.ROWID"
                     "      AND reports.ROWID = report_hosts.report"
                     "      AND task_preferences.task = tasks.ROWID"
                     "      AND task_preferences.name = 'in_assets')"
                     "     = 'yes'"
                     " AND (report_hosts.end_time IS NOT NULL"
                     "      AND report_hosts.end_time != '')"
                     " GROUP BY host"
                     " HAVING host LIKE '%%%s%%'"
                     " OR EXISTS"
                     " (SELECT * FROM report_host_details"
                     "  WHERE report_hosts.ROWID = report_host"
                     "  AND (name = 'hostname' OR name = 'best_os_txt'"
                     "       OR name = 'best_os_cpe' OR name = 'App'"
                     "       OR name = 'ports')"
                     "  AND source_type = 'nvt'"
                     "  AND value LIKE '%%%s%%')"
                     " ORDER BY host COLLATE collate_ip"
                     " LIMIT %i OFFSET %i;",
                     current_credentials.uuid,
                     quoted_search_phrase,
                     quoted_search_phrase,
                     max_results,
                     first_result);
      g_free (quoted_search_phrase);
    }
  else
    init_iterator (iterator,
                   "SELECT DISTINCT host FROM report_hosts"
                   " WHERE (SELECT reports.owner FROM reports"
                   "        WHERE reports.ROWID = report_hosts.report)"
                   "       = (SELECT ROWID FROM users"
                   "          WHERE users.uuid = '%s')"
                   " AND (SELECT tasks.hidden FROM tasks, reports"
                   "      WHERE reports.task = tasks.ROWID"
                   "      AND reports.ROWID = report_hosts.report)"
                   "     = 0"
                   " AND (SELECT value FROM task_preferences, tasks,"
                   "                        reports"
                   "      WHERE reports.task = tasks.ROWID"
                   "      AND reports.ROWID = report_hosts.report"
                   "      AND task_preferences.task = tasks.ROWID"
                   "      AND task_preferences.name = 'in_assets')"
                   "     = 'yes'"
                   " AND (report_hosts.end_time IS NOT NULL"
                   "      AND report_hosts.end_time != '')"
                   " ORDER BY host COLLATE collate_ip"
                   " LIMIT %i OFFSET %i;",
                   current_credentials.uuid,
                   max_results,
                   first_result);
}

/**
 * @brief Get the IP from a asset iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Host IP.
 */
DEF_ACCESS (asset_iterator_ip, 0);

/**
 * @brief Set the end time of a task.
 *
 * @param[in]  task  Task.
 * @param[in]  time  New time.  Freed before return.  If NULL, clear end time.
 */
void
set_task_end_time (task_t task, char* time)
{
  if (time)
    {
      sql ("UPDATE tasks SET end_time = '%.*s' WHERE ROWID = %llu;",
           strlen (time),
           time,
           task);
      free (time);
    }
  else
    sql ("UPDATE tasks SET end_time = NULL WHERE ROWID = %llu;",
         task);
}

/**
 * @brief Get the start time of a scan.
 *
 * @param[in]  report  The report associated with the scan.
 *
 * @return Start time of scan, in a newly allocated string.
 */
char*
scan_start_time (report_t report)
{
  char *time = sql_string (0, 0,
                           "SELECT iso_time (start_time)"
                           " FROM reports WHERE ROWID = %llu;",
                           report);
  return time ? time : g_strdup ("");
}

/**
 * @brief Set the start time of a scan.
 *
 * @param[in]  report     The report associated with the scan.
 * @param[in]  timestamp  Start time.  In ISO format.
 */
void
set_scan_start_time (report_t report, const char* timestamp)
{
  sql ("UPDATE reports SET start_time = %i WHERE ROWID = %llu;",
       parse_iso_time (timestamp),
       report);
}

/**
 * @brief Set the start time of a scan.
 *
 * @param[in]  report     The report associated with the scan.
 * @param[in]  timestamp  Start time.  In OTP format (ctime).
 */
void
set_scan_start_time_otp (report_t report, const char* timestamp)
{
  sql ("UPDATE reports SET start_time = %i WHERE ROWID = %llu;",
       parse_otp_time (timestamp),
       report);
}

/**
 * @brief Get the end time of a scan.
 *
 * @param[in]  report  The report associated with the scan.
 *
 * @return End time of scan, in a newly allocated string.
 */
char*
scan_end_time (report_t report)
{
  char *time = sql_string (0, 0,
                           "SELECT iso_time (end_time)"
                           " FROM reports WHERE ROWID = %llu;",
                           report);
  return time ? time : g_strdup ("");
}

/**
 * @brief Set the end time of a scan.
 *
 * @param[in]  report     The report associated with the scan.
 * @param[in]  timestamp  End time.  ISO format.  If NULL, clear end time.
 */
void
set_scan_end_time (report_t report, const char* timestamp)
{
  if (timestamp)
    sql ("UPDATE reports SET end_time = %i WHERE ROWID = %llu;",
         parse_iso_time (timestamp), report);
  else
    sql ("UPDATE reports SET end_time = NULL WHERE ROWID = %llu;",
         report);
}

/**
 * @brief Set the end time of a scan.
 *
 * @param[in]  report     The report associated with the scan.
 * @param[in]  timestamp  End time.  OTP format (ctime).  If NULL, clear end
 *                        time.
 */
void
set_scan_end_time_otp (report_t report, const char* timestamp)
{
  if (timestamp)
    sql ("UPDATE reports SET end_time = %i WHERE ROWID = %llu;",
         parse_otp_time (timestamp), report);
  else
    sql ("UPDATE reports SET end_time = NULL WHERE ROWID = %llu;",
         report);

  report_cache_counts (report);
}

/**
 * @brief Set the end time of a scanned host.
 *
 * @param[in]  report     Report associated with the scan.
 * @param[in]  host       Host.
 * @param[in]  timestamp  End time.  ISO format.
 */
void
set_scan_host_end_time (report_t report, const char* host,
                        const char* timestamp)
{
  gchar *quoted_host;
  quoted_host = sql_quote (host);
  if (sql_int (0, 0,
               "SELECT COUNT(*) FROM report_hosts"
               " WHERE report = %llu AND host = '%s';",
               report, quoted_host))
    sql ("UPDATE report_hosts SET end_time = %i"
         " WHERE report = %llu AND host = '%s';",
         parse_iso_time (timestamp), report, quoted_host);
  else
    sql ("INSERT into report_hosts (report, host, end_time)"
         " VALUES (%llu, '%s', %i);",
         report, quoted_host, parse_iso_time (timestamp));
  g_free (quoted_host);
}

/**
 * @brief Set the end time of a scanned host.
 *
 * @param[in]  report     Report associated with the scan.
 * @param[in]  host       Host.
 * @param[in]  timestamp  End time.  OTP format (ctime).
 */
void
set_scan_host_end_time_otp (report_t report, const char* host,
                            const char* timestamp)
{
  gchar *quoted_host;
  quoted_host = sql_quote (host);
  if (sql_int (0, 0,
               "SELECT COUNT(*) FROM report_hosts"
               " WHERE report = %llu AND host = '%s';",
               report, quoted_host))
    sql ("UPDATE report_hosts SET end_time = %i"
         " WHERE report = %llu AND host = '%s';",
         parse_otp_time (timestamp), report, quoted_host);
  else
    sql ("INSERT into report_hosts (report, host, end_time)"
         " VALUES (%llu, '%s', %i);",
         report, quoted_host, parse_otp_time (timestamp));
  g_free (quoted_host);
}

/**
 * @brief Set the start time of a scanned host.
 *
 * @param[in]  report     Report associated with the scan.
 * @param[in]  host       Host.
 * @param[in]  timestamp  Start time.  ISO format.
 */
void
set_scan_host_start_time (report_t report, const char* host,
                          const char* timestamp)
{
  gchar *quoted_host;
  quoted_host = sql_quote (host);
  if (sql_int (0, 0,
               "SELECT COUNT(*) FROM report_hosts"
               " WHERE report = %llu AND host = '%s';",
               report, quoted_host))
    sql ("UPDATE report_hosts SET start_time = %i"
         " WHERE report = %llu AND host = '%s';",
         parse_iso_time (timestamp), report, quoted_host);
  else
    sql ("INSERT into report_hosts (report, host, start_time)"
         " VALUES (%llu, '%s', %i);",
         report, quoted_host, parse_iso_time (timestamp));
  g_free (quoted_host);
}

/**
 * @brief Set the start time of a scanned host.
 *
 * @param[in]  report     Report associated with the scan.
 * @param[in]  host       Host.
 * @param[in]  timestamp  Start time.  OTP format (ctime).
 */
void
set_scan_host_start_time_otp (report_t report, const char* host,
                              const char* timestamp)
{
  gchar *quoted_host;
  quoted_host = sql_quote (host);
  if (sql_int (0, 0,
               "SELECT COUNT(*) FROM report_hosts"
               " WHERE report = %llu AND host = '%s';",
               report, quoted_host))
    sql ("UPDATE report_hosts SET start_time = %i"
         " WHERE report = %llu AND host = '%s';",
         parse_otp_time (timestamp), report, quoted_host);
  else
    sql ("INSERT into report_hosts (report, host, start_time)"
         " VALUES (%llu, '%s', %i);",
         report, quoted_host, parse_otp_time (timestamp));
  g_free (quoted_host);
}

/**
 * @brief Get the timestamp of a report.
 *
 * @todo Lacks permission check.  Caller contexts all have permission
 *       checks before calling this so it's safe.  Rework callers so
 *       they pass report_t instead of UUID string.
 *
 * @param[in]   report_id    UUID of report.
 * @param[out]  timestamp    Timestamp on success.  Caller must free.
 *
 * @return 0 on success, -1 on error.
 */
int
report_timestamp (const char* report_id, gchar** timestamp)
{
  const char* stamp;
  time_t time = sql_int (0, 0,
                         "SELECT date FROM reports where uuid = '%s';",
                         report_id);
  stamp = iso_time (&time);
  if (stamp == NULL) return -1;
  *timestamp = g_strdup (stamp);
  return 0;
}

/**
 * @brief Return the run status of the scan associated with a report.
 *
 * @param[in]   report  Report.
 * @param[out]  status  Scan run status.
 *
 * @return 0 on success, -1 on error.
 */
int
report_scan_run_status (report_t report, int* status)
{
  *status = sql_int (0, 0,
                     "SELECT scan_run_status FROM reports"
                     " WHERE reports.ROWID = %llu;",
                     report);
  return 0;
}

/**
 * @brief Return the run status of the scan associated with a report.
 *
 * @param[in]   report  Report.
 * @param[out]  status  Scan run status.
 *
 * @return 0 on success, -1 on error.
 */
int
set_report_scan_run_status (report_t report, task_status_t status)
{
  sql ("UPDATE reports SET scan_run_status = %u WHERE ROWID = %llu;",
       status,
       report);
  return 0;
}

/**
 * @brief Return SQL for the auto_type column.
 *
 * @param[in]  report     Report.
 * @param[in]  autofp     Whether to apply the auto FP filter.
 *
 * @return Message count.
 */
static gchar *
column_auto_type (report_t report, int autofp)
{
  gchar *auto_type_sql;
  switch (autofp)
    {
      case 1:
        auto_type_sql = g_strdup_printf
          (", (CASE WHEN"
           "   (((SELECT family FROM nvts WHERE oid = results.nvt)"
           "     IN (" LSC_FAMILY_LIST "))"
           "    OR results.nvt == '0'" /* Open ports have 0 NVT. */
           "    OR"
           "    (SELECT ROWID FROM nvts"
           "     WHERE oid = results.nvt"
           "     AND"
           "     (cve == 'NOCVE'"
           "      OR cve NOT IN (SELECT cve FROM nvts"
           "                     WHERE oid IN (SELECT source_name"
           "                                   FROM report_host_details"
           "                                   WHERE report_host"
           "                                   = (SELECT id"
           "                                      FROM report_hosts"
           "                                      WHERE report = %llu"
           "                                      AND host = results.host)"
           "                                   AND name = 'EXIT_CODE'"
           "                                   AND value = 'EXIT_NOTVULN')"
           "                     AND family IN (" LSC_FAMILY_LIST ")))))"
           "   THEN NULL"
           "   ELSE 1 END)"
           "   AS auto_type",
           report);
         break;

      case 2:
        auto_type_sql = g_strdup_printf
          (", (CASE WHEN"
           "   ((SELECT family FROM nvts WHERE oid = results.nvt)"
           "    IN (" LSC_FAMILY_LIST ")"
           "    OR results.nvt == '0'" /* Open ports have 0 NVT. */
           "    OR"
           "    (SELECT ROWID FROM nvts AS outer_nvts"
           "     WHERE oid = results.nvt"
           "     AND"
           "     (cve = 'NOCVE'"
           "      OR NOT EXISTS"
           "         (SELECT cve FROM nvts"
           "          WHERE oid IN (SELECT source_name"
           "                        FROM report_host_details"
           "                        WHERE report_host"
           "                        = (SELECT id"
           "                           FROM report_hosts"
           "                           WHERE report = %llu"
           "                           AND host = results.host)"
           "                        AND name = 'EXIT_CODE'"
           "                        AND value = 'EXIT_NOTVULN')"
           "          AND family IN (" LSC_FAMILY_LIST ")"
           /* The CVE of the result NVT is outer_nvts.cve.  The CVE of the
            * NVT that has registered the "closed" host detail is nvts.cve.
            * Either can be a list of CVEs. */
           "          AND common_cve (nvts.cve, outer_nvts.cve)))))"
           "   THEN NULL"
           "   ELSE 1 END)"
           "   AS auto_type",
           report);
         break;

       default:
         auto_type_sql = g_strdup (", NULL AS auto_type");
         break;
     }
  return auto_type_sql;
}

/**
 * @brief Get the number of results in the scan associated with a report.
 *
 * @param[in]   report         Report.
 * @param[in]   levels         String describing threat levels (message types)
 *                             to include in count (for example, "hmlgd" for
 *                             High, Medium, Low, loG and Debug).  All levels if
 *                             NULL.
 * @param[in]   search_phrase  Phrase that results must include.  All results if
 *                             NULL or "".
 * @param[in]   search_phrase_exact  Whether search phrase is exact.
 * @param[in]   min_cvss_base  Minimum CVSS base of included results.  All
 *                             results if NULL.
 * @param[in]   override       Whether to override threats.
 * @param[in]   autofp         Whether to apply the auto FP filter.
 * @param[out]  count          Total number of results in the scan.
 *
 * @return 0 on success, -1 on error.
 */
int
report_scan_result_count (report_t report, const char* levels,
                          const char* search_phrase, int search_phrase_exact,
                          const char* min_cvss_base, int override, int autofp,
                          int* count)
{
  GString *levels_sql, *phrase_sql, *cvss_sql;
  gchar *new_type_sql = NULL, *auto_type_sql = NULL;

  phrase_sql = where_search_phrase (search_phrase, search_phrase_exact);
  cvss_sql = where_cvss_base (min_cvss_base);

  if (override)
    {
      gchar *ov;

      assert (current_credentials.uuid);

      levels_sql = where_levels_auto (levels);

      ov = g_strdup_printf
            ("SELECT overrides.new_threat"
             " FROM overrides"
             " WHERE overrides.nvt = results.nvt"
             " AND ((overrides.owner IS NULL)"
             " OR (overrides.owner ="
             " (SELECT ROWID FROM users"
             "  WHERE users.uuid = '%s')))"
             " AND ((overrides.end_time = 0)"
             "      OR (overrides.end_time >= now ()))"
             " AND (overrides.task ="
             "      (SELECT reports.task FROM reports"
             "       WHERE report_results.report = reports.ROWID)"
             "      OR overrides.task = 0)"
             " AND (overrides.result = results.ROWID"
             "      OR overrides.result = 0)"
             " AND (overrides.hosts is NULL"
             "      OR overrides.hosts = \"\""
             "      OR hosts_contains (overrides.hosts, results.host))"
             " AND (overrides.port is NULL"
             "      OR overrides.port = \"\""
             "      OR overrides.port = results.port)"
             " AND (overrides.threat is NULL"
             "      OR overrides.threat = \"\""
             "      OR overrides.threat = results.type)"
             " ORDER BY overrides.result DESC, overrides.task DESC,"
             " overrides.port DESC, overrides.threat"
             " COLLATE collate_message_type ASC",
             current_credentials.uuid);

      new_type_sql = g_strdup_printf (", coalesce ((%s), type) AS new_type", ov);

      g_free (ov);
    }
  else
    levels_sql = where_levels_type (levels);

  auto_type_sql = column_auto_type (report, autofp);

  *count = sql_int (0, 0,
                    "SELECT count(results.ROWID)%s%s"
                    " FROM results, report_results"
                    " WHERE results.ROWID = report_results.result"
                    "%s%s%s"
                    " AND report_results.report = %llu;",
                    new_type_sql ? new_type_sql : "",
                    auto_type_sql ? auto_type_sql : "",
                    levels_sql ? levels_sql->str : "",
                    phrase_sql ? phrase_sql->str : "",
                    cvss_sql ? cvss_sql->str : "",
                    report);

  if (levels_sql) g_string_free (levels_sql, TRUE);
  if (phrase_sql) g_string_free (phrase_sql, TRUE);
  if (cvss_sql) g_string_free (cvss_sql, TRUE);
  g_free (new_type_sql);
  g_free (auto_type_sql);

  return 0;
}

/**
 * @brief Get the message count for a report for a specific message type.
 *
 * @param[in]  report     Report.
 * @param[in]  type       Message type.
 * @param[in]  override   Whether to override the threat.
 * @param[in]  host       Host to which to limit the count.  NULL to allow all.
 *
 * @return Message count.
 */
int
report_count (report_t report, const char *type, int override, const char *host)
{
  if (override
      && sql_int (0, 0,
                  "SELECT count(*)"
                  " FROM overrides"
                  " WHERE ((overrides.owner IS NULL)"
                  "        OR (overrides.owner ="
                  "            (SELECT ROWID FROM users"
                  "             WHERE users.uuid = '%s')))"
                  " AND ((overrides.end_time = 0)"
                  "      OR (overrides.end_time >= now ()))",
                  current_credentials.uuid))
    {
      int count;
      iterator_t results;
      task_t task;

      sqlite3_stmt *stmt, *full_stmt;
      gchar *select;
      int ret;

      /* Prepare quick inner statement. */

      select = g_strdup_printf ("SELECT 1 FROM overrides"
                                " WHERE (overrides.nvt = $nvt)"
                                " AND ((overrides.owner IS NULL) OR (overrides.owner ="
                                " (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                                " AND ((overrides.end_time = 0)"
                                "      OR (overrides.end_time >= now ()))",
                                current_credentials.uuid);
      while (1)
        {
          const char* tail;
          ret = sqlite3_prepare (task_db, select, -1, &stmt, &tail);
          if (ret == SQLITE_BUSY) continue;
          g_free (select);
          if (ret == SQLITE_OK)
            {
              if (stmt == NULL)
                {
                  g_warning ("%s: sqlite3_prepare failed with NULL stmt: %s\n",
                             __FUNCTION__,
                             sqlite3_errmsg (task_db));
                  abort ();
                }
              break;
            }
          g_warning ("%s: sqlite3_prepare failed: %s\n",
                     __FUNCTION__,
                     sqlite3_errmsg (task_db));
          /** @todo ROLLBACK if in transaction. */
          abort ();
        }

      /* Prepare full inner statement. */

      report_task (report, &task);

      select = g_strdup_printf
                ("SELECT overrides.new_threat"
                 " FROM overrides"
                 " WHERE overrides.nvt = $nvt" // 1
                 " AND ((overrides.owner IS NULL)"
                 " OR (overrides.owner ="
                 " (SELECT users.ROWID FROM users"
                 "  WHERE users.uuid = '%s')))"
                 " AND ((overrides.end_time = 0)"
                 "      OR (overrides.end_time >= now ()))"
                 " AND (overrides.task = 0"
                 "      OR overrides.task = %llu)"
                 " AND (overrides.result = 0"
                 "      OR overrides.result = $result)" // 2
                 " AND (overrides.hosts is NULL"
                 "      OR overrides.hosts = \"\""
                 "      OR hosts_contains (overrides.hosts, $host))" // 3
                 " AND (overrides.port is NULL"
                 "      OR overrides.port = \"\""
                 "      OR overrides.port = $port)" // 4
                 " AND (overrides.threat is NULL"
                 "      OR overrides.threat = \"\""
                 "      OR overrides.threat = $type)" // 5
                 " ORDER BY overrides.result DESC, overrides.task DESC,"
                 " overrides.port DESC, overrides.threat"
                 " COLLATE collate_message_type ASC;",
                 current_credentials.uuid,
                 task);

      while (1)
        {
          const char* tail;
          ret = sqlite3_prepare (task_db, select, -1, &full_stmt, &tail);
          if (ret == SQLITE_BUSY) continue;
          g_free (select);
          if (ret == SQLITE_OK)
            {
              if (full_stmt == NULL)
                {
                  g_warning ("%s: sqlite3_prepare failed with NULL stmt: %s\n",
                             __FUNCTION__,
                             sqlite3_errmsg (task_db));
                  abort ();
                }
              break;
            }
          g_warning ("%s: sqlite3_prepare failed: %s\n",
                     __FUNCTION__,
                     sqlite3_errmsg (task_db));
          /** @todo ROLLBACK if in transaction. */
          abort ();
        }

      /* Loop through all results. */

      count = 0;
      init_iterator (&results,
                     "SELECT results.ROWID, results.nvt, results.type,"
                     " results.host, results.port"
                     " FROM results, report_results"
                     " WHERE report_results.report = %llu"
                     " AND results.ROWID = report_results.result",
                     report);
      while (next (&results))
        {
          const char *nvt, *new_type;

          nvt = (const char*) sqlite3_column_text (results.stmt, 1);

          /* Bind the current result values into the quick statement. */

          while (1)
            {
              ret = sqlite3_bind_text (stmt, 1, nvt, -1, SQLITE_TRANSIENT);
              if (ret == SQLITE_BUSY) continue;
              if (ret == SQLITE_OK) break;
              g_warning ("%s: sqlite3_prepare failed: %s\n",
                         __FUNCTION__,
                         sqlite3_errmsg (task_db));
              abort ();
            }

          /* Run the quick inner statement to check for overrides. */

          while (1)
            {
              ret = sqlite3_step (stmt);
              if (ret == SQLITE_BUSY) continue;
              if (ret == SQLITE_DONE) break;
              if (ret == SQLITE_ERROR || ret == SQLITE_MISUSE)
                {
                  if (ret == SQLITE_ERROR) ret = sqlite3_reset (stmt);
                  g_warning ("%s: sqlite3_step failed: %s\n",
                             __FUNCTION__,
                             sqlite3_errmsg (task_db));
                  abort ();
                }
              break;
            }

          /* Check the result. */

          if (ret == SQLITE_DONE)
            {
              new_type = (const char*) sqlite3_column_text (results.stmt, 2);
              if (new_type && (strcmp (new_type, type) == 0))
                count++;
            }
          else
            {
              /* There is an override on this NVT, get the new threat value. */

              /* Bind the current result values into the full statement. */

              while (1)
                {
                  ret = sqlite3_bind_text (full_stmt, 1, nvt, -1, SQLITE_TRANSIENT);
                  if (ret == SQLITE_BUSY) continue;
                  if (ret == SQLITE_OK) break;
                  g_warning ("%s: sqlite3_prepare failed: %s\n",
                             __FUNCTION__,
                             sqlite3_errmsg (task_db));
                  abort ();
                }

              while (1)
                {
                  result_t result;
                  result = (result_t) sqlite3_column_int64 (results.stmt, 0);
                  ret = sqlite3_bind_int64 (full_stmt, 2, result);
                  if (ret == SQLITE_BUSY) continue;
                  if (ret == SQLITE_OK) break;
                  g_warning ("%s: sqlite3_prepare failed: %s\n",
                             __FUNCTION__,
                             sqlite3_errmsg (task_db));
                  abort ();
                }

              while (1)
                {
                  const char *host;
                  host = (const char*) sqlite3_column_text (results.stmt, 3);
                  ret = sqlite3_bind_text (full_stmt, 3, host, -1,
                                           SQLITE_TRANSIENT);
                  if (ret == SQLITE_BUSY) continue;
                  if (ret == SQLITE_OK) break;
                  g_warning ("%s: sqlite3_prepare failed: %s\n",
                             __FUNCTION__,
                             sqlite3_errmsg (task_db));
                  abort ();
                }

              while (1)
                {
                  const char *port;
                  port = (const char*) sqlite3_column_text (results.stmt, 4);
                  ret = sqlite3_bind_text (full_stmt, 4, port, -1,
                                           SQLITE_TRANSIENT);
                  if (ret == SQLITE_BUSY) continue;
                  if (ret == SQLITE_OK) break;
                  g_warning ("%s: sqlite3_prepare failed: %s\n",
                             __FUNCTION__,
                             sqlite3_errmsg (task_db));
                  abort ();
                }

              while (1)
                {
                  const char *type;
                  type = (const char*) sqlite3_column_text (results.stmt, 2);
                  ret = sqlite3_bind_text (full_stmt, 5, type, -1,
                                           SQLITE_TRANSIENT);
                  if (ret == SQLITE_BUSY) continue;
                  if (ret == SQLITE_OK) break;
                  g_warning ("%s: sqlite3_prepare failed: %s\n",
                             __FUNCTION__,
                             sqlite3_errmsg (task_db));
                  abort ();
                }

              /* Run the full inner statement. */

              while (1)
                {
                  ret = sqlite3_step (full_stmt);
                  if (ret == SQLITE_BUSY) continue;
                  if (ret == SQLITE_DONE) break;
                  if (ret == SQLITE_ERROR || ret == SQLITE_MISUSE)
                    {
                      if (ret == SQLITE_ERROR) ret = sqlite3_reset (full_stmt);
                      g_warning ("%s: sqlite3_step failed: %s\n",
                                 __FUNCTION__,
                                 sqlite3_errmsg (task_db));
                      abort ();
                    }
                  break;
                }

              /* Check the result. */

              if (ret == SQLITE_DONE)
                new_type = (const char*) sqlite3_column_text (results.stmt, 2);
              else
                new_type = (const char*) sqlite3_column_text (full_stmt, 0);

              if (new_type && (strcmp (new_type, type) == 0))
                count++;

              /* Reset the full inner statement. */

              while (1)
                {
                  ret = sqlite3_reset (full_stmt);
                  if (ret == SQLITE_BUSY) continue;
                  if (ret == SQLITE_DONE || ret == SQLITE_OK) break;
                  if (ret == SQLITE_ERROR || ret == SQLITE_MISUSE)
                    {
                      g_warning ("%s: sqlite3_reset failed: %s\n",
                                 __FUNCTION__,
                                 sqlite3_errmsg (task_db));
                      abort ();
                    }
                }
            }

          /* Reset the quick inner statement. */

          while (1)
            {
              ret = sqlite3_reset (stmt);
              if (ret == SQLITE_BUSY) continue;
              if (ret == SQLITE_DONE || ret == SQLITE_OK) break;
              if (ret == SQLITE_ERROR || ret == SQLITE_MISUSE)
                {
                  g_warning ("%s: sqlite3_reset failed: %s\n",
                             __FUNCTION__,
                             sqlite3_errmsg (task_db));
                  abort ();
                }
            }
        }
      cleanup_iterator (&results);
      sqlite3_finalize (stmt);
      sqlite3_finalize (full_stmt);
      return count;
    }
  else if (host)
    {
      gchar* quoted_host = sql_quote (host);
      int count = sql_int (0, 0,
                           "SELECT count(*) FROM results, report_results"
                           " WHERE results.host = '%s' AND results.type = '%s'"
                           " AND results.ROWID = report_results.result"
                           " AND report_results.report = %llu;",
                           quoted_host,
                           type,
                           report);
      g_free (quoted_host);
      return count;
    }
  else
    return sql_int (0, 0,
                    "SELECT count(*) FROM results, report_results"
                    " WHERE report_results.report = %llu"
                    " AND report_results.result = results.ROWID"
                    " AND results.type = '%s';",
                    report,
                    type);
}

/**
 * @brief Check if a result matches the autofp filter criteria.
 *
 * @param[in]  results        Result iterator.
 * @param[in]  autofp         Whether to apply the auto FP filter.
 *
 * @return 1 if match, 0 otherwise.
 */
static int
report_counts_autofp_match (iterator_t *results, int autofp)
{
  if (strcmp ((const char *) sqlite3_column_text (results->stmt, 1), "0") == 0)
    /* Open port special case. */
    return 1;

  switch (autofp)
    {
      case 1:
        if (sql_int (0, 0,
                     "SELECT count (*) FROM nvts"
                     " WHERE oid = '%s'"
                     " AND"
                     " (family IN (" LSC_FAMILY_LIST ")"
                     "  OR cve == 'NOCVE'"
                     "  OR cve NOT IN (SELECT cve FROM nvts"
                     "                 WHERE oid IN (SELECT source_name"
                     "                               FROM report_host_details"
                     "                               WHERE report_host"
                     "                               = (SELECT id"
                     "                                  FROM report_hosts"
                     "                                  WHERE report = %llu"
                     "                                  AND host = '%s')"
                     "                               AND name = 'EXIT_CODE'"
                     "                               AND value"
                     "                               = 'EXIT_NOTVULN')"
                     "                 AND family IN (" LSC_FAMILY_LIST ")));",
                     (const char*) sqlite3_column_text (results->stmt, 1),
                     sqlite3_column_int64 (results->stmt, 6),
                     (const char*) sqlite3_column_text (results->stmt, 3)))
          return 1;
        break;
      case 2:
        if (sql_int (0, 0,
                     "SELECT count (*) FROM nvts AS outer_nvts"
                     " WHERE oid = '%s'"
                     " AND"
                     " (family IN (" LSC_FAMILY_LIST ")"
                     "  OR cve == 'NOCVE'"
                     "  OR NOT EXISTS"
                     "     (SELECT cve FROM nvts"
                     "      WHERE oid IN (SELECT source_name"
                     "                    FROM report_host_details"
                     "                    WHERE report_host"
                     "                    = (SELECT id FROM report_hosts"
                     "                       WHERE report = %llu"
                     "                       AND host = '%s')"
                     "                    AND name = 'EXIT_CODE'"
                     "                    AND value = 'EXIT_NOTVULN')"
                     "      AND family IN (" LSC_FAMILY_LIST ")"
                     /* The CVE of the result NVT is outer_nvts.cve.  The CVE
                      * of the NVT that has registered the "closed" host
                      * detail is nvts.cve.  Either can be a list of CVEs. */
                     "      AND common_cve (nvts.cve, outer_nvts.cve)));",
                     (const char*) sqlite3_column_text (results->stmt, 1),
                     sqlite3_column_int64 (results->stmt, 6),
                     (const char*) sqlite3_column_text (results->stmt, 3)))
          return 1;
        break;
    }
  return 0;
}

/**
 * @brief Check if a result matches the filter criteria.
 *
 * @param[in]  results        Result iterator.
 * @param[in]  search_phrase  Search phrase.
 * @param[in]  search_phrase_exact  Whether search phrase is exact.
 * @param[in]  min_cvss_base  Minimum CVSS base.
 * @param[in]  autofp         Whether to apply the auto FP filter.
 *
 * @return 1 if match, 0 otherwise.
 */
static int
report_counts_match (iterator_t *results, const char *search_phrase,
                     int search_phrase_exact, const char *min_cvss_base,
                     int autofp)
{
  if (autofp && (report_counts_autofp_match (results, autofp) == 0))
    return 0;

  if (search_phrase && search_phrase_exact)
    {
      if ((strcmp ((const char*) sqlite3_column_text (results->stmt, 5),
                  search_phrase)
           == 0)
          || (strcmp ((const char*) sqlite3_column_text (results->stmt, 4),
                      search_phrase)
              == 0)
          || (strcmp ((const char*) sqlite3_column_text (results->stmt, 1),
                      search_phrase)
              == 0))
        {
          if (min_cvss_base && sqlite3_column_int (results->stmt, 1))
            {
              if (sql_int (0, 0,
                           "SELECT"
                           " (CAST (cvss_base AS REAL))"
                           " >= CAST (%s AS REAL)"
                           " FROM nvts"
                           " WHERE nvts.oid = '%s';",
                           /* Assume valid SQL string. */
                           min_cvss_base,
                           sqlite3_column_text (results->stmt, 1)))
                return 1;
            }
          else
            return 1;
        }
    }
  else if (search_phrase)
    {
      if (strcasestr ((const char*) sqlite3_column_text (results->stmt, 5),
                      search_phrase)
          || strcasestr ((const char*) sqlite3_column_text (results->stmt, 4),
                         search_phrase)
          || strcasestr ((const char*) sqlite3_column_text (results->stmt, 1),
                         search_phrase))
        {
          if (min_cvss_base && sqlite3_column_int (results->stmt, 1))
            {
              if (sql_int (0, 0,
                           "SELECT"
                           " (CAST (cvss_base AS REAL))"
                           " >= CAST (%s AS REAL)"
                           " FROM nvts"
                           " WHERE nvts.oid = '%s';",
                           /* Assume valid SQL string. */
                           min_cvss_base,
                           sqlite3_column_text (results->stmt, 1)))
                return 1;
            }
          else
            return 1;
        }
    }
  else if (min_cvss_base && sqlite3_column_int (results->stmt, 1))
    {
      if (sql_int (0, 0,
                   "SELECT"
                   " (CAST (cvss_base AS REAL))"
                   " >= CAST (%s AS REAL)"
                   " FROM nvts"
                   " WHERE nvts.oid = '%s';",
                   /* Assume valid SQL string. */
                   min_cvss_base,
                   sqlite3_column_text (results->stmt, 1)))
        return 1;
    }
  else
    return 1;
  return 0;
}

/**
 * @brief Get the message count for a report for a specific message type.
 *
 * @param[in]  report     Report.
 * @param[in]  type       Message type.
 * @param[in]  override   Whether to override the threat.
 * @param[in]  host       Host to which to limit the count.  NULL to allow all.
 * @param[in]  min_cvss_base  Minimum CVSS base of filtered results.  All
 *                            results if NULL.
 * @param[in]  search_phrase  Phrase that filtered results must include.  All results
 *                            if NULL or "".
 * @param[in]  search_phrase_exact  Whether search phrase is exact.
 * @param[in]  autofp         Whether to apply the auto FP filter.
 *
 * @return Message count.
 */
int
report_count_filtered (report_t report, const char *type, int override,
                       const char *host, const char *min_cvss_base,
                       const char *search_phrase, int search_phrase_exact,
                       int autofp)
{
  if (search_phrase && strcmp (search_phrase, "") == 0)
    search_phrase = NULL;

  if (min_cvss_base && strcmp (min_cvss_base, "") == 0)
    min_cvss_base = NULL;

  if (override
      && sql_int (0, 0,
                  "SELECT count(*)"
                  " FROM overrides"
                  " WHERE ((overrides.owner IS NULL)"
                  "        OR (overrides.owner ="
                  "            (SELECT ROWID FROM users"
                  "             WHERE users.uuid = '%s')))"
                  " AND ((overrides.end_time = 0)"
                  "      OR (overrides.end_time >= now ()))",
                  current_credentials.uuid))
    {
      int count;
      iterator_t results;
      task_t task;

      sqlite3_stmt *stmt, *full_stmt;
      gchar *select;
      int ret;

      /* Prepare quick inner statement. */

      select = g_strdup_printf ("SELECT 1 FROM overrides"
                                " WHERE (overrides.nvt = $nvt)"
                                " AND ((overrides.owner IS NULL) OR (overrides.owner ="
                                " (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                                " AND ((overrides.end_time = 0)"
                                "      OR (overrides.end_time >= now ()))",
                                current_credentials.uuid);
      while (1)
        {
          const char* tail;
          ret = sqlite3_prepare (task_db, select, -1, &stmt, &tail);
          if (ret == SQLITE_BUSY) continue;
          g_free (select);
          if (ret == SQLITE_OK)
            {
              if (stmt == NULL)
                {
                  g_warning ("%s: sqlite3_prepare failed with NULL stmt: %s\n",
                             __FUNCTION__,
                             sqlite3_errmsg (task_db));
                  abort ();
                }
              break;
            }
          g_warning ("%s: sqlite3_prepare failed: %s\n",
                     __FUNCTION__,
                     sqlite3_errmsg (task_db));
          /** @todo ROLLBACK if in transaction. */
          abort ();
        }

      /* Prepare full inner statement. */

      report_task (report, &task);

      select = g_strdup_printf
                ("SELECT overrides.new_threat"
                 " FROM overrides"
                 " WHERE overrides.nvt = $nvt" // 1
                 " AND ((overrides.owner IS NULL)"
                 " OR (overrides.owner ="
                 " (SELECT users.ROWID FROM users"
                 "  WHERE users.uuid = '%s')))"
                 " AND ((overrides.end_time = 0)"
                 "      OR (overrides.end_time >= now ()))"
                 " AND (overrides.task = 0"
                 "      OR overrides.task = %llu)"
                 " AND (overrides.result = 0"
                 "      OR overrides.result = $result)" // 2
                 " AND (overrides.hosts is NULL"
                 "      OR overrides.hosts = \"\""
                 "      OR hosts_contains (overrides.hosts, $host))" // 3
                 " AND (overrides.port is NULL"
                 "      OR overrides.port = \"\""
                 "      OR overrides.port = $port)" // 4
                 " AND (overrides.threat is NULL"
                 "      OR overrides.threat = \"\""
                 "      OR overrides.threat = $type)" // 5
                 " ORDER BY overrides.result DESC, overrides.task DESC,"
                 " overrides.port DESC, overrides.threat"
                 " COLLATE collate_message_type ASC;",
                 current_credentials.uuid,
                 task);

      while (1)
        {
          const char* tail;
          ret = sqlite3_prepare (task_db, select, -1, &full_stmt, &tail);
          if (ret == SQLITE_BUSY) continue;
          g_free (select);
          if (ret == SQLITE_OK)
            {
              if (full_stmt == NULL)
                {
                  g_warning ("%s: sqlite3_prepare failed with NULL stmt: %s\n",
                             __FUNCTION__,
                             sqlite3_errmsg (task_db));
                  abort ();
                }
              break;
            }
          g_warning ("%s: sqlite3_prepare failed: %s\n",
                     __FUNCTION__,
                     sqlite3_errmsg (task_db));
          /** @todo ROLLBACK if in transaction. */
          abort ();
        }

      /* Loop through all results. */

      count = 0;
      init_iterator (&results,
                     "SELECT results.ROWID, results.nvt, results.type,"
                     " results.host, results.port, results.description"
                     " report_results.report"
                     " FROM results, report_results"
                     " WHERE report_results.report = %llu"
                     " AND results.ROWID = report_results.result",
                     report);
      while (next (&results))
        {
          const char *nvt, *new_type;

          nvt = (const char*) sqlite3_column_text (results.stmt, 1);

          /* Bind the current result values into the quick statement. */

          while (1)
            {
              ret = sqlite3_bind_text (stmt, 1, nvt, -1, SQLITE_TRANSIENT);
              if (ret == SQLITE_BUSY) continue;
              if (ret == SQLITE_OK) break;
              g_warning ("%s: sqlite3_prepare failed: %s\n",
                         __FUNCTION__,
                         sqlite3_errmsg (task_db));
              abort ();
            }

          /* Run the quick inner statement to check for overrides. */

          while (1)
            {
              ret = sqlite3_step (stmt);
              if (ret == SQLITE_BUSY) continue;
              if (ret == SQLITE_DONE) break;
              if (ret == SQLITE_ERROR || ret == SQLITE_MISUSE)
                {
                  if (ret == SQLITE_ERROR) ret = sqlite3_reset (stmt);
                  g_warning ("%s: sqlite3_step failed: %s\n",
                             __FUNCTION__,
                             sqlite3_errmsg (task_db));
                  abort ();
                }
              break;
            }

          /* Check the result. */

          if (ret == SQLITE_DONE)
            {
              new_type = (const char*) sqlite3_column_text (results.stmt, 2);
              if (new_type
                  && (strcmp (new_type, type) == 0)
                  && report_counts_match (&results,
                                          search_phrase,
                                          search_phrase_exact,
                                          min_cvss_base,
                                          autofp))
                count++;
            }
          else
            {
              /* There is an override on this NVT, get the new threat value. */

              /* Bind the current result values into the full statement. */

              while (1)
                {
                  ret = sqlite3_bind_text (full_stmt, 1, nvt, -1, SQLITE_TRANSIENT);
                  if (ret == SQLITE_BUSY) continue;
                  if (ret == SQLITE_OK) break;
                  g_warning ("%s: sqlite3_prepare failed: %s\n",
                             __FUNCTION__,
                             sqlite3_errmsg (task_db));
                  abort ();
                }

              while (1)
                {
                  result_t result;
                  result = (result_t) sqlite3_column_int64 (results.stmt, 0);
                  ret = sqlite3_bind_int64 (full_stmt, 2, result);
                  if (ret == SQLITE_BUSY) continue;
                  if (ret == SQLITE_OK) break;
                  g_warning ("%s: sqlite3_prepare failed: %s\n",
                             __FUNCTION__,
                             sqlite3_errmsg (task_db));
                  abort ();
                }

              while (1)
                {
                  const char *host;
                  host = (const char*) sqlite3_column_text (results.stmt, 3);
                  ret = sqlite3_bind_text (full_stmt, 3, host, -1,
                                           SQLITE_TRANSIENT);
                  if (ret == SQLITE_BUSY) continue;
                  if (ret == SQLITE_OK) break;
                  g_warning ("%s: sqlite3_prepare failed: %s\n",
                             __FUNCTION__,
                             sqlite3_errmsg (task_db));
                  abort ();
                }

              while (1)
                {
                  const char *port;
                  port = (const char*) sqlite3_column_text (results.stmt, 4);
                  ret = sqlite3_bind_text (full_stmt, 4, port, -1,
                                           SQLITE_TRANSIENT);
                  if (ret == SQLITE_BUSY) continue;
                  if (ret == SQLITE_OK) break;
                  g_warning ("%s: sqlite3_prepare failed: %s\n",
                             __FUNCTION__,
                             sqlite3_errmsg (task_db));
                  abort ();
                }

              while (1)
                {
                  const char *type;
                  type = (const char*) sqlite3_column_text (results.stmt, 2);
                  ret = sqlite3_bind_text (full_stmt, 5, type, -1,
                                           SQLITE_TRANSIENT);
                  if (ret == SQLITE_BUSY) continue;
                  if (ret == SQLITE_OK) break;
                  g_warning ("%s: sqlite3_prepare failed: %s\n",
                             __FUNCTION__,
                             sqlite3_errmsg (task_db));
                  abort ();
                }

              /* Run the full inner statement. */

              while (1)
                {
                  ret = sqlite3_step (full_stmt);
                  if (ret == SQLITE_BUSY) continue;
                  if (ret == SQLITE_DONE) break;
                  if (ret == SQLITE_ERROR || ret == SQLITE_MISUSE)
                    {
                      if (ret == SQLITE_ERROR) ret = sqlite3_reset (full_stmt);
                      g_warning ("%s: sqlite3_step failed: %s\n",
                                 __FUNCTION__,
                                 sqlite3_errmsg (task_db));
                      abort ();
                    }
                  break;
                }

              /* Check the result. */

              if (ret == SQLITE_DONE)
                new_type = (const char*) sqlite3_column_text (results.stmt, 2);
              else
                new_type = (const char*) sqlite3_column_text (full_stmt, 0);

              if (new_type
                  && (strcmp (new_type, type) == 0)
                  && report_counts_match (&results,
                                          search_phrase,
                                          search_phrase_exact,
                                          min_cvss_base,
                                          (strcmp (new_type, "False Positive")
                                           && strcmp (new_type, "Log Message"))
                                            ? autofp
                                            : 0))
                count++;

              /* Reset the full inner statement. */

              while (1)
                {
                  ret = sqlite3_reset (full_stmt);
                  if (ret == SQLITE_BUSY) continue;
                  if (ret == SQLITE_DONE || ret == SQLITE_OK) break;
                  if (ret == SQLITE_ERROR || ret == SQLITE_MISUSE)
                    {
                      g_warning ("%s: sqlite3_reset failed: %s\n",
                                 __FUNCTION__,
                                 sqlite3_errmsg (task_db));
                      abort ();
                    }
                }
            }

          /* Reset the quick inner statement. */

          while (1)
            {
              ret = sqlite3_reset (stmt);
              if (ret == SQLITE_BUSY) continue;
              if (ret == SQLITE_DONE || ret == SQLITE_OK) break;
              if (ret == SQLITE_ERROR || ret == SQLITE_MISUSE)
                {
                  g_warning ("%s: sqlite3_reset failed: %s\n",
                             __FUNCTION__,
                             sqlite3_errmsg (task_db));
                  abort ();
                }
            }
        }
      cleanup_iterator (&results);
      sqlite3_finalize (stmt);
      sqlite3_finalize (full_stmt);
      return count;
    }
  else if (strcmp (type, "False Positive") == 0)
    {
      int count;
      GString *phrase_sql, *cvss_sql;
      gchar *auto_type_sql;

      phrase_sql = where_search_phrase (search_phrase, search_phrase_exact);
      cvss_sql = where_cvss_base (min_cvss_base);
      auto_type_sql = column_auto_type (report, autofp);

      count = sql_int (0, 0,
                       "SELECT count(*)%s FROM results, report_results"
                       " WHERE report_results.report = %llu"
                       " AND report_results.result = results.ROWID"
                       "%s%s%s"
                       " AND (results.type = '%s' OR auto_type IS NOT NULL)"
                       "%s%s;",
                       auto_type_sql,
                       report,
                       host ? " AND results.host = '" : "",
                       host ? host : "",
                       host ? "' AND " : "",
                       type,
                       phrase_sql ? phrase_sql->str : "",
                       cvss_sql ? cvss_sql->str : "");

      if (phrase_sql) g_string_free (phrase_sql, TRUE);
      if (cvss_sql) g_string_free (cvss_sql, TRUE);
      g_free (auto_type_sql);
      return count;
    }
  else
    {
      int count;
      GString *autofp_sql, *phrase_sql, *cvss_sql;

      autofp_sql = where_autofp (autofp, report);
      phrase_sql = where_search_phrase (search_phrase, search_phrase_exact);
      cvss_sql = where_cvss_base (min_cvss_base);

      count = sql_int (0, 0,
                       "SELECT count(*) FROM results, report_results"
                       " WHERE report_results.report = %llu"
                       " AND report_results.result = results.ROWID"
                       "%s%s%s"
                       " AND results.type = '%s'"
                       "%s%s%s;",
                       report,
                       host ? " AND results.host = '" : "",
                       host ? host : "",
                       host ? "' AND " : "",
                       type,
                       autofp_sql ? autofp_sql->str : "",
                       phrase_sql ? phrase_sql->str : "",
                       cvss_sql ? cvss_sql->str : "");
      if (autofp_sql) g_string_free (autofp_sql, TRUE);
      if (phrase_sql) g_string_free (phrase_sql, TRUE);
      if (cvss_sql) g_string_free (cvss_sql, TRUE);
      return count;
    }
}

/**
 * @brief Get the message counts for a report given the UUID.
 *
 * @todo Lacks permission check.  Caller contexts all have permission
 *       checks before calling this so it's safe.  Rework callers to
 *       use report_counts_id instead.
 *
 * @param[in]   report_id    ID of report.
 * @param[out]  debugs       Number of debug messages.
 * @param[out]  holes        Number of hole messages.
 * @param[out]  infos        Number of info messages.
 * @param[out]  logs         Number of log messages.
 * @param[out]  warnings     Number of warning messages.
 * @param[out]  false_positives  Number of false positives.
 * @param[in]   override     Whether to override the threat.
 * @param[in]   autofp       Whether to apply the auto FP filter.
 *
 * @return 0 on success, -1 on error.
 */
int
report_counts (const char* report_id, int* debugs, int* holes, int* infos,
               int* logs, int* warnings, int* false_positives, int override,
               int autofp)
{
  report_t report;
  if (find_report_for_actions (report_id, &report, "g"))
    return -1;
  return report_counts_id (report, debugs, holes, infos, logs, warnings,
                           false_positives, override, NULL, autofp);
}

/**
 * @brief Get the message counts for a report.
 *
 * @param[in]   report    Report.
 * @param[in]   override  Whether to override the threat.
 * @param[out]  holes     Number of hole messages.
 * @param[out]  infos     Number of info messages.
 * @param[out]  logs      Number of log messages.
 * @param[out]  warnings  Number of warning messages.
 * @param[out]  false_positives    Number of false positive messages.
 */
static void
cache_report_counts (report_t report, int override, int holes, int warnings,
                     int infos, int logs, int false_positives)
{
  /* Try cache results.  Give up if the database is locked because this could
   * happen while the caller has an SQL statement open.  If another process
   * tries to write to the database between the statement open and
   * cache_report_counts then they'll deadlock. */
  if (override)
    sql_giveup ("UPDATE reports SET override_highs = %i,"
                " override_mediums = %i, override_lows = %i,"
                " override_logs = %i, override_fps = %i"
                " WHERE ROWID = %llu;",
                holes, warnings, infos, logs, false_positives,
                report);
  else
    sql_giveup ("UPDATE reports SET highs = %i, mediums = %i, lows = %i,"
                " logs = %i, fps = %i"
                " WHERE ROWID = %llu;",
                holes, warnings, infos, logs, false_positives,
                report);
}

/**
 * @brief Get the message counts for a report.
 *
 * @param[in]   report    Report.
 * @param[out]  debugs    Number of debug messages.
 * @param[out]  holes     Number of hole messages.
 * @param[out]  infos     Number of info messages.
 * @param[out]  logs      Number of log messages.
 * @param[out]  warnings  Number of warning messages.
 * @param[out]  false_positives    Number of false positive messages.
 * @param[in]   override           Whether to override the threat.
 * @param[in]   host               Host to which to limit the count.  NULL to allow all.
 * @param[in]   min_cvss_base      Minimum CVSS base of filtered results.  All
 *                                 results if NULL.
 * @param[in]   search_phrase      Phrase that filtered results must include.
 *                                 All results if NULL or "".
 * @param[in]   search_phrase_exact  Whether search phrase is exact.
 * @param[in]   autofp             Whether to apply the auto FP filter.
 * @param[out]  filtered_debugs    Number of debug messages after filtering.
 * @param[out]  filtered_holes     Number of hole messages after filtering.
 * @param[out]  filtered_infos     Number of info messages after filtering.
 * @param[out]  filtered_logs      Number of log messages after filtering.
 * @param[out]  filtered_warnings  Number of warning messages after filtering.
 * @param[out]  filtered_false_positives  Number of false positive messages after
 *                                        filtering.
 *
 * @return 0 on success, -1 on error.
 */
static int
report_counts_id_filt (report_t report, int* debugs, int* holes, int* infos,
                       int* logs, int* warnings, int* false_positives,
                       int override, const char *host,
                       const char *min_cvss_base, const char *search_phrase,
                       int search_phrase_exact, int autofp,
                       int* filtered_debugs, int* filtered_holes,
                       int* filtered_infos, int* filtered_logs,
                       int* filtered_warnings, int* filtered_false_positives)
{
  /* This adds time and is out of scope of OMP threat levels, so skip it */
  if (debugs)
    *debugs = 0;

  if (filtered_debugs)
    *filtered_debugs = 0;

  if (search_phrase && strcmp (search_phrase, "") == 0)
    search_phrase = NULL;

  if (min_cvss_base && strcmp (min_cvss_base, "") == 0)
    min_cvss_base = NULL;

  if (holes && infos && logs && warnings && false_positives)
    {
      if (autofp == 0 && host == NULL && filtered_holes == NULL
          && filtered_infos == NULL && filtered_logs == NULL
          && filtered_warnings == NULL && filtered_false_positives == NULL)
        {
          /* Try get from cache. */

          if (override)
            {
              *holes = sql_int (0, 0,
                                "SELECT override_highs FROM reports"
                                " WHERE ROWID = %llu",
                                report);
              if (*holes >= 0)
                {
                  *warnings = sql_int (0, 0,
                                       "SELECT override_mediums FROM reports"
                                       " WHERE ROWID = %llu",
                                       report);
                  *infos = sql_int (0, 0,
                                    "SELECT override_lows FROM reports"
                                    " WHERE ROWID = %llu",
                                    report);
                  *logs = sql_int (0, 0,
                                   "SELECT override_logs FROM reports"
                                   " WHERE ROWID = %llu",
                                   report);
                  *false_positives = sql_int (0, 0,
                                              "SELECT override_fps FROM reports"
                                              " WHERE ROWID = %llu",
                                              report);
                  return 0;
                }
            }
          else
            {
              *holes = sql_int (0, 0,
                                "SELECT highs FROM reports"
                                " WHERE ROWID = %llu",
                                report);
              if (*holes >= 0)
                {
                  *warnings = sql_int (0, 0,
                                       "SELECT mediums FROM reports"
                                       " WHERE ROWID = %llu",
                                       report);
                  *infos = sql_int (0, 0,
                                    "SELECT lows FROM reports"
                                    " WHERE ROWID = %llu",
                                    report);
                  *logs = sql_int (0, 0,
                                   "SELECT logs FROM reports"
                                   " WHERE ROWID = %llu",
                                   report);
                  *false_positives = sql_int (0, 0,
                                              "SELECT fps FROM reports"
                                              " WHERE ROWID = %llu",
                                              report);
                  return 0;
                }
            }
        }

      /* Recalculate. */

      if (override
          && sql_int (0, 0,
                      "SELECT count(*)"
                      " FROM overrides"
                      " WHERE ((overrides.owner IS NULL)"
                      "        OR (overrides.owner ="
                      "            (SELECT ROWID FROM users"
                      "             WHERE users.uuid = '%s')))"
                      " AND ((overrides.end_time = 0)"
                      "      OR (overrides.end_time >= now ()))",
                      current_credentials.uuid))
        {
          iterator_t results;
          task_t task;

          sqlite3_stmt *stmt, *full_stmt;
          gchar *select, *quoted_host;
          int ret, status;

          /* Prepare quick inner statement. */

          select = g_strdup_printf ("SELECT 1 FROM overrides"
                                    " WHERE (overrides.nvt = $nvt)"
                                    " AND ((overrides.owner IS NULL) OR (overrides.owner ="
                                    " (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                                    " AND ((overrides.end_time = 0)"
                                    "      OR (overrides.end_time >= now ()))",
                                    current_credentials.uuid);
          while (1)
            {
              const char* tail;
              ret = sqlite3_prepare (task_db, select, -1, &stmt, &tail);
              if (ret == SQLITE_BUSY) continue;
              g_free (select);
              if (ret == SQLITE_OK)
                {
                  if (stmt == NULL)
                    {
                      g_warning ("%s: sqlite3_prepare failed with NULL stmt: %s\n",
                                 __FUNCTION__,
                                 sqlite3_errmsg (task_db));
                      abort ();
                    }
                  break;
                }
              g_warning ("%s: sqlite3_prepare failed: %s\n",
                         __FUNCTION__,
                         sqlite3_errmsg (task_db));
              /** @todo ROLLBACK if in transaction. */
              abort ();
            }

          /* Prepare full inner statement. */

          report_task (report, &task);

          select = g_strdup_printf
                    ("SELECT overrides.new_threat"
                     " FROM overrides"
                     " WHERE overrides.nvt = $nvt" // 1
                     " AND ((overrides.owner IS NULL)"
                     " OR (overrides.owner ="
                     " (SELECT users.ROWID FROM users"
                     "  WHERE users.uuid = '%s')))"
                     " AND ((overrides.end_time = 0)"
                     "      OR (overrides.end_time >= now ()))"
                     " AND (overrides.task = 0"
                     "      OR overrides.task = %llu)"
                     " AND (overrides.result = 0"
                     "      OR overrides.result = $result)" // 2
                     " AND (overrides.hosts is NULL"
                     "      OR overrides.hosts = \"\""
                     "      OR hosts_contains (overrides.hosts, $host))" // 3
                     " AND (overrides.port is NULL"
                     "      OR overrides.port = \"\""
                     "      OR overrides.port = $port)" // 4
                     " AND (overrides.threat is NULL"
                     "      OR overrides.threat = \"\""
                     "      OR overrides.threat = $type)" // 5
                     " ORDER BY overrides.result DESC, overrides.task DESC,"
                     " overrides.port DESC, overrides.threat"
                     " COLLATE collate_message_type ASC;",
                     current_credentials.uuid,
                     task);

          while (1)
            {
              const char* tail;
              ret = sqlite3_prepare (task_db, select, -1, &full_stmt, &tail);
              if (ret == SQLITE_BUSY) continue;
              g_free (select);
              if (ret == SQLITE_OK)
                {
                  if (full_stmt == NULL)
                    {
                      g_warning ("%s: sqlite3_prepare failed with NULL stmt: %s\n",
                                 __FUNCTION__,
                                 sqlite3_errmsg (task_db));
                      abort ();
                    }
                  break;
                }
              g_warning ("%s: sqlite3_prepare failed: %s\n",
                         __FUNCTION__,
                         sqlite3_errmsg (task_db));
              /** @todo ROLLBACK if in transaction. */
              abort ();
            }

          /* Loop through all results. */

          *holes = *infos = *logs = *warnings = *false_positives = 0;
          if (filtered_holes) *filtered_holes = 0;
          if (filtered_infos) *filtered_infos = 0;
          if (filtered_logs) *filtered_logs = 0;
          if (filtered_warnings) *filtered_warnings = 0;
          if (filtered_false_positives) *filtered_false_positives = 0;
          if (host)
            quoted_host = sql_quote (host);
          init_iterator (&results,
                         "SELECT results.ROWID, results.nvt, results.type,"
                         " results.host, results.port, results.description,"
                         " report_results.report"
                         " FROM results, report_results"
                         " WHERE"
                         "%s%s%s"
                         " report_results.report = %llu"
                         " AND results.ROWID = report_results.result",
                         host ? " results.host = '" : "",
                         host ? quoted_host : "",
                         host ? "' AND" : "",
                         report);
          if (host)
            g_free (quoted_host);
          while (next (&results))
            {
              const char *nvt, *new_type;

              nvt = (const char*) sqlite3_column_text (results.stmt, 1);

              /* Bind the current result values into the quick statement. */

              while (1)
                {
                  ret = sqlite3_bind_text (stmt, 1, nvt, -1, SQLITE_TRANSIENT);
                  if (ret == SQLITE_BUSY) continue;
                  if (ret == SQLITE_OK) break;
                  g_warning ("%s: sqlite3_prepare failed: %s\n",
                             __FUNCTION__,
                             sqlite3_errmsg (task_db));
                  abort ();
                }

              /* Run the quick inner statement to check for overrides. */

              while (1)
                {
                  ret = sqlite3_step (stmt);
                  if (ret == SQLITE_BUSY) continue;
                  if (ret == SQLITE_DONE) break;
                  if (ret == SQLITE_ERROR || ret == SQLITE_MISUSE)
                    {
                      if (ret == SQLITE_ERROR) ret = sqlite3_reset (stmt);
                      g_warning ("%s: sqlite3_step failed: %s\n",
                                 __FUNCTION__,
                                 sqlite3_errmsg (task_db));
                      abort ();
                    }
                  break;
                }

              /* Check the result. */

              if (ret == SQLITE_DONE)
                {
                  new_type = (const char*) sqlite3_column_text (results.stmt, 2);
                  if (new_type)
                    {
                      if (strcmp (new_type, "Security Hole") == 0)
                        {
                          (*holes)++;
                          if (filtered_holes
                              && report_counts_match (&results,
                                                      search_phrase,
                                                      search_phrase_exact,
                                                      min_cvss_base,
                                                      autofp))
                            (*filtered_holes)++;
                        }
                      else if (strcmp (new_type, "Security Warning") == 0)
                        {
                          (*warnings)++;
                          if (filtered_warnings
                              && report_counts_match (&results,
                                                      search_phrase,
                                                      search_phrase_exact,
                                                      min_cvss_base,
                                                      autofp))
                            (*filtered_warnings)++;
                        }
                      else if (strcmp (new_type, "Security Note") == 0)
                        {
                          (*infos)++;
                          if (filtered_infos
                              && report_counts_match (&results,
                                                      search_phrase,
                                                      search_phrase_exact,
                                                      min_cvss_base,
                                                      autofp))
                            (*filtered_infos)++;
                        }
                      else if (strcmp (new_type, "Log Message") == 0)
                        {
                          (*logs)++;
                          if (filtered_logs
                              && report_counts_match (&results,
                                                      search_phrase,
                                                      search_phrase_exact,
                                                      min_cvss_base,
                                                      autofp))
                            (*filtered_logs)++;
                        }
                      else if (strcmp (new_type, "False Positive") == 0)
                        {
                          (*false_positives)++;
                          if (filtered_false_positives
                              && report_counts_match (&results,
                                                      search_phrase,
                                                      search_phrase_exact,
                                                      min_cvss_base,
                                                      autofp))
                            (*filtered_false_positives)++;
                        }
                    }
                }
              else
                {
                  /* There is an override on this NVT, get the new threat value. */

                  /* Bind the current result values into the full statement. */

                  while (1)
                    {
                      ret = sqlite3_bind_text (full_stmt, 1, nvt, -1, SQLITE_TRANSIENT);
                      if (ret == SQLITE_BUSY) continue;
                      if (ret == SQLITE_OK) break;
                      g_warning ("%s: sqlite3_prepare failed: %s\n",
                                 __FUNCTION__,
                                 sqlite3_errmsg (task_db));
                      abort ();
                    }

                  while (1)
                    {
                      result_t result;
                      result = (result_t) sqlite3_column_int64 (results.stmt, 0);
                      ret = sqlite3_bind_int64 (full_stmt, 2, result);
                      if (ret == SQLITE_BUSY) continue;
                      if (ret == SQLITE_OK) break;
                      g_warning ("%s: sqlite3_prepare failed: %s\n",
                                 __FUNCTION__,
                                 sqlite3_errmsg (task_db));
                      abort ();
                    }

                  while (1)
                    {
                      const char *host;
                      host = (const char*) sqlite3_column_text (results.stmt, 3);
                      ret = sqlite3_bind_text (full_stmt, 3, host, -1,
                                               SQLITE_TRANSIENT);
                      if (ret == SQLITE_BUSY) continue;
                      if (ret == SQLITE_OK) break;
                      g_warning ("%s: sqlite3_prepare failed: %s\n",
                                 __FUNCTION__,
                                 sqlite3_errmsg (task_db));
                      abort ();
                    }

                  while (1)
                    {
                      const char *port;
                      port = (const char*) sqlite3_column_text (results.stmt, 4);
                      ret = sqlite3_bind_text (full_stmt, 4, port, -1,
                                               SQLITE_TRANSIENT);
                      if (ret == SQLITE_BUSY) continue;
                      if (ret == SQLITE_OK) break;
                      g_warning ("%s: sqlite3_prepare failed: %s\n",
                                 __FUNCTION__,
                                 sqlite3_errmsg (task_db));
                      abort ();
                    }

                  while (1)
                    {
                      const char *type;
                      type = (const char*) sqlite3_column_text (results.stmt, 2);
                      ret = sqlite3_bind_text (full_stmt, 5, type, -1,
                                               SQLITE_TRANSIENT);
                      if (ret == SQLITE_BUSY) continue;
                      if (ret == SQLITE_OK) break;
                      g_warning ("%s: sqlite3_prepare failed: %s\n",
                                 __FUNCTION__,
                                 sqlite3_errmsg (task_db));
                      abort ();
                    }

                  /* Run the full inner statement. */

                  while (1)
                    {
                      ret = sqlite3_step (full_stmt);
                      if (ret == SQLITE_BUSY) continue;
                      if (ret == SQLITE_DONE) break;
                      if (ret == SQLITE_ERROR || ret == SQLITE_MISUSE)
                        {
                          if (ret == SQLITE_ERROR) ret = sqlite3_reset (full_stmt);
                          g_warning ("%s: sqlite3_step failed: %s\n",
                                     __FUNCTION__,
                                     sqlite3_errmsg (task_db));
                          abort ();
                        }
                      break;
                    }

                  /* Check the result. */

                  if (ret == SQLITE_DONE)
                    new_type = (const char*) sqlite3_column_text (results.stmt, 2);
                  else
                    new_type = (const char*) sqlite3_column_text (full_stmt, 0);

                  if (new_type)
                    {
                      if (strcmp (new_type, "Security Hole") == 0)
                        {
                          (*holes)++;
                          if (filtered_holes
                              && report_counts_match (&results,
                                                      search_phrase,
                                                      search_phrase_exact,
                                                      min_cvss_base,
                                                      autofp))
                            (*filtered_holes)++;
                        }
                      else if (strcmp (new_type, "Security Warning") == 0)
                        {
                          (*warnings)++;
                          if (filtered_warnings
                              && report_counts_match (&results,
                                                      search_phrase,
                                                      search_phrase_exact,
                                                      min_cvss_base,
                                                      autofp))
                            (*filtered_warnings)++;
                        }
                      else if (strcmp (new_type, "Security Note") == 0)
                        {
                          (*infos)++;
                          if (filtered_infos
                              && report_counts_match (&results,
                                                      search_phrase,
                                                      search_phrase_exact,
                                                      min_cvss_base,
                                                      autofp))
                            (*filtered_infos)++;
                        }
                      else if (strcmp (new_type, "Log Message") == 0)
                        {
                          (*logs)++;
                          if (filtered_logs
                              && report_counts_match (&results,
                                                      search_phrase,
                                                      search_phrase_exact,
                                                      min_cvss_base,
                                                      0))
                            (*filtered_logs)++;
                        }
                      else if (strcmp (new_type, "False Positive") == 0)
                        {
                          (*false_positives)++;
                          if (filtered_false_positives
                              && report_counts_match (&results,
                                                      search_phrase,
                                                      search_phrase_exact,
                                                      min_cvss_base,
                                                      0))
                            (*filtered_false_positives)++;
                        }
                    }

                  /* Reset the full inner statement. */

                  while (1)
                    {
                      ret = sqlite3_reset (full_stmt);
                      if (ret == SQLITE_BUSY) continue;
                      if (ret == SQLITE_DONE || ret == SQLITE_OK) break;
                      if (ret == SQLITE_ERROR || ret == SQLITE_MISUSE)
                        {
                          g_warning ("%s: sqlite3_reset failed: %s\n",
                                     __FUNCTION__,
                                     sqlite3_errmsg (task_db));
                          abort ();
                        }
                    }
                }

              /* Reset the quick inner statement. */

              while (1)
                {
                  ret = sqlite3_reset (stmt);
                  if (ret == SQLITE_BUSY) continue;
                  if (ret == SQLITE_DONE || ret == SQLITE_OK) break;
                  if (ret == SQLITE_ERROR || ret == SQLITE_MISUSE)
                    {
                      g_warning ("%s: sqlite3_reset failed: %s\n",
                                 __FUNCTION__,
                                 sqlite3_errmsg (task_db));
                      abort ();
                    }
                }
            }
          cleanup_iterator (&results);
          sqlite3_finalize (stmt);
          sqlite3_finalize (full_stmt);

          report_scan_run_status (report, &status);

          if (autofp == 0 && host == NULL && status == TASK_STATUS_DONE)
            cache_report_counts (report, override, *holes, *warnings, *infos,
                                 *logs, *false_positives);

          return 0;
        }
    }

  if (false_positives)
    *false_positives = report_count (report, "False Positive", override, host);
  if (holes) *holes = report_count (report, "Security Hole", override, host);
  if (infos) *infos = report_count (report, "Security Note", override, host);
  if (logs) *logs = report_count (report, "Log Message", override, host);
  if (warnings)
    *warnings = report_count (report, "Security Warning", override, host);

  if (holes && infos && logs && warnings && false_positives
      && host == NULL)
    {
      int status;

      report_scan_run_status (report, &status);
      if (status == TASK_STATUS_DONE)
        cache_report_counts (report, override, *holes, *warnings, *infos,
                             *logs, *false_positives);
    }

  if (filtered_false_positives)
    *filtered_false_positives
     = report_count_filtered (report, "False Positive", override, host,
                              min_cvss_base, search_phrase, search_phrase_exact,
                              autofp);
  if (filtered_holes)
    *filtered_holes
     = report_count_filtered (report, "Security Hole", override, host,
                              min_cvss_base, search_phrase, search_phrase_exact,
                              autofp);
  if (filtered_infos)
    *filtered_infos
     = report_count_filtered (report, "Security Note", override, host,
                              min_cvss_base, search_phrase, search_phrase_exact,
                              autofp);
  if (filtered_logs)
    *filtered_logs
     = report_count_filtered (report, "Log Message", override, host,
                              min_cvss_base, search_phrase, search_phrase_exact,
                              autofp);
  if (filtered_warnings)
    *filtered_warnings
     = report_count_filtered (report, "Security Warning", override, host,
                              min_cvss_base, search_phrase, search_phrase_exact,
                              autofp);

  return 0;
}

/**
 * @brief Get the message counts for a report.
 *
 * @param[in]   report    Report.
 * @param[out]  debugs    Number of debug messages.
 * @param[out]  holes     Number of hole messages.
 * @param[out]  infos     Number of info messages.
 * @param[out]  logs      Number of log messages.
 * @param[out]  warnings  Number of warning messages.
 * @param[out]  false_positives  Number of false positive messages.
 * @param[in]   override  Whether to override the threat.
 * @param[in]   host      Host to which to limit the count.  NULL to allow all.
 * @param[in]   autofp    Whether to apply the auto FP filter.
 *
 * @return 0 on success, -1 on error.
 */
int
report_counts_id (report_t report, int* debugs, int* holes, int* infos,
                  int* logs, int* warnings, int* false_positives, int override,
                  const char *host, int autofp)
{
  return report_counts_id_filt (report, debugs, holes, infos, logs, warnings,
                                false_positives, override, host, NULL, NULL, 0,
                                autofp, NULL, NULL, NULL, NULL, NULL, NULL);

}

/**
 * @brief Delete a report.
 *
 * It's up to the caller to provide the transaction.
 *
 * @param[in]  report  Report.
 *
 * @return 0 success, 1 report is hidden, 2 report is in use, -1 error.
 */
int
delete_report (report_t report)
{
  task_t task;
  char *slave_task_uuid;

  if (sql_int (0, 0, "SELECT hidden FROM reports WHERE ROWID = %llu;", report))
    return 1;

  if (sql_int (0, 0,
               "SELECT count(*) FROM reports WHERE ROWID = %llu"
               " AND (scan_run_status = %u OR scan_run_status = %u"
               " OR scan_run_status = %u OR scan_run_status = %u"
               " OR scan_run_status = %u OR scan_run_status = %u"
               " OR scan_run_status = %u OR scan_run_status = %u"
               " OR scan_run_status = %u OR scan_run_status = %u);",
               report,
               TASK_STATUS_RUNNING,
               TASK_STATUS_PAUSE_REQUESTED,
               TASK_STATUS_PAUSE_WAITING,
               TASK_STATUS_PAUSED,
               TASK_STATUS_RESUME_REQUESTED,
               TASK_STATUS_RESUME_WAITING,
               TASK_STATUS_REQUESTED,
               TASK_STATUS_DELETE_REQUESTED,
               TASK_STATUS_DELETE_ULTIMATE_REQUESTED,
               TASK_STATUS_STOP_REQUESTED,
               TASK_STATUS_STOP_REQUESTED_GIVEUP,
               TASK_STATUS_STOP_WAITING))
    return 2;

  if (report_task (report, &task))
    return -1;

  /* Remove any associated slave task. */

  slave_task_uuid = report_slave_task_uuid (report);
  if (slave_task_uuid)
    {
      slave_t slave;

      /** @todo Store slave on report, in case task's slave changes. */
      slave = task_slave (task);
      if (slave == 0)
        {
          free (slave_task_uuid);
          return -1;
        }

      delete_slave_task (slave, slave_task_uuid);
    }

  /* Remove the report data. */

  sql ("DELETE FROM report_host_details WHERE report_host IN"
       " (SELECT ROWID FROM report_hosts WHERE report = %llu);",
       report);
  sql ("DELETE FROM report_hosts WHERE report = %llu;", report);
  sql ("DELETE FROM report_results WHERE report = %llu;", report);
  sql ("DELETE FROM reports WHERE ROWID = %llu;", report);

  /* Update the task state. */

  switch (sql_int64 (&report, 0, 0,
                     "SELECT max (ROWID) FROM reports WHERE task = %llu",
                     task))
    {
      case 0:
        if (report)
          {
            int status;
            if (report_scan_run_status (report, &status))
              return -1;
            sql ("UPDATE tasks SET run_status = %u WHERE ROWID = %llu;",
                 status,
                 task);
          }
        else
          sql ("UPDATE tasks SET run_status = %u WHERE ROWID = %llu;",
               TASK_STATUS_NEW,
               task);
        break;
      case 1:        /* Too few rows in result of query. */
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        return -1;
        break;
    }

  return 0;
}

/**
 * @brief Delete a report.
 *
 * @param[in]  report  Report.
 *
 * @return 0 success, 1 report is hidden, 2 report is in use, -1 error.
 */
int
manage_delete_report (report_t report)
{
  int ret;

  sql ("BEGIN EXCLUSIVE;");

  ret = delete_report (report);
  if (ret)
    {
      sql ("ROLLBACK;");
      return ret;
    }

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Return the slave progress of a report.
 *
 * @param[in]  report  Report.
 *
 * @return Number of reports.
 */
int
report_slave_progress (report_t report)
{
  return sql_int (0, 0,
                  "SELECT slave_progress FROM reports WHERE ROWID = %llu;",
                  report);
}

/**
 * @brief Set slave progress of a report.
 *
 * @param[in]  report    The report.
 * @param[in]  progress  The new progress value.
 *
 * @return 0 success.
 */
int
set_report_slave_progress (report_t report, int progress)
{
  sql ("UPDATE reports SET slave_progress = %i WHERE ROWID = %llu;",
       progress,
       report);
  return 0;
}

/**
 * @brief Return the UUID of the task on the slave.
 *
 * @param[in]  report    The report.
 *
 * @return UUID of the slave task if any, else NULL.
 */
char*
report_slave_task_uuid (report_t report)
{
  char *uuid;

  uuid = sql_string (0, 0,
                     "SELECT slave_task_uuid FROM reports WHERE ROWID = %llu;",
                     report);
  if (uuid && strlen (uuid))
    return uuid;
  free (uuid);
  return NULL;
}

/**
 * @brief Set the UUID of the slave task, on the local task.
 *
 * @param[in]  report    The report.
 * @param[in]  uuid  UUID.
 */
void
set_report_slave_task_uuid (report_t report, const char *uuid)
{
  gchar *quoted_uuid = sql_quote (uuid);
  sql ("UPDATE reports SET slave_task_uuid = '%s' WHERE ROWID = %llu;",
       quoted_uuid,
       report);
  g_free (quoted_uuid);
}

/**
 * @brief Set a report parameter.
 *
 * @param[in]  report     The report.
 * @param[in]  parameter  The name of the parameter (in any case): COMMENT.
 * @param[in]  value      The value of the parameter.
 *
 * @return 0 success, -2 parameter name error,
 *         -3 failed to write parameter to disk,
 *         -4 username missing from current_credentials.
 */
int
set_report_parameter (report_t report, const char* parameter, const char* value)
{
  tracef ("   set_report_parameter %llu %s\n", report, parameter);
  if (strcasecmp ("COMMENT", parameter) == 0)
    {
      gchar* quote = sql_nquote (value, strlen (value));
      sql ("UPDATE reports SET comment = '%s' WHERE ROWID = %llu;",
           value,
           report);
      g_free (quote);
    }
  else
    return -2;
  return 0;
}

/**
 * @brief Prepare a partial report for restarting the scan from the beginning.
 *
 * @param[in]  report  The report.
 */
void
trim_report (report_t report)
{
  /* Remove results for all hosts. */

  sql ("DELETE FROM report_results WHERE report = %llu AND result IN"
       " (SELECT results.ROWID FROM report_results, results, report_hosts"
       "  WHERE report_results.report = %llu"
       "  AND report_results.result = results.ROWID"
       "  AND report_hosts.report = %llu"
       "  AND results.host = report_hosts.host);",
       report,
       report,
       report);

  sql ("DELETE FROM results WHERE ROWID IN"
       " (SELECT results.ROWID FROM report_results, results, report_hosts"
       "  WHERE report_results.report = %llu"
       "  AND report_results.result = results.ROWID"
       "  AND report_hosts.report = %llu"
       "  AND results.host = report_hosts.host);",
       report,
       report);

  /* Remove all hosts and host details. */

  sql ("DELETE FROM report_host_details WHERE report_host IN"
       " (SELECT ROWID FROM report_hosts WHERE report = %llu);",
       report);
  sql ("DELETE FROM report_hosts"
       " WHERE report = %llu;",
       report);
}

/**
 * @brief Prepare a partial report for resumption of the scan.
 *
 * @param[in]  report  The report.
 */
void
trim_partial_report (report_t report)
{
  /* Remove results for partial hosts. */

  sql ("DELETE FROM report_results WHERE report = %llu AND result IN"
       " (SELECT results.ROWID FROM report_results, results, report_hosts"
       "  WHERE report_results.report = %llu"
       "  AND report_results.result = results.ROWID"
       "  AND report_hosts.report = %llu"
       "  AND results.host = report_hosts.host"
       "  AND (report_hosts.end_time is NULL OR report_hosts.end_time = ''));",
       report,
       report,
       report);

  sql ("DELETE FROM results WHERE ROWID IN"
       " (SELECT results.ROWID FROM report_results, results, report_hosts"
       "  WHERE report_results.report = %llu"
       "  AND report_results.result = results.ROWID"
       "  AND report_hosts.report = %llu"
       "  AND results.host = report_hosts.host"
       "  AND (report_hosts.end_time is NULL OR report_hosts.end_time = ''));",
       report,
       report);

  /* Remove partial hosts and host details. */

  sql ("DELETE FROM report_host_details WHERE report_host IN"
       " (SELECT results.ROWID FROM report_results, results, report_hosts"
       "  WHERE report_results.report = %llu"
       "  AND report_results.result = results.ROWID"
       "  AND report_hosts.report = %llu"
       "  AND results.host = report_hosts.host"
       "  AND (report_hosts.end_time is NULL OR report_hosts.end_time = ''));",
       report,
       report);

  sql ("DELETE FROM report_hosts"
       " WHERE report = %llu"
       " AND (end_time is NULL OR end_time = '');",
       report);
}

/**
 * @brief Compares two textual threat level representations, sorting
 * @brief descending.
 *
 * @param[in]  arg_one  First threat level.
 * @param[in]  arg_two  Second threat level.
 *
 * @return 1, 0 or -1 if first given threat is less than, equal to or greater
 *         than second.
 */
static gint
compare_message_types_desc (gconstpointer arg_one, gconstpointer arg_two)
{
  gchar *one_type, *two_type;
  gchar *one = *((gchar**) arg_one);
  gchar *two = *((gchar**) arg_two);
  gint host;

  one += strlen (one) + 1;
  two += strlen (two) + 1;
  one_type = one;
  two_type = two;

  one += strlen (one) + 1;
  two += strlen (two) + 1;
  host = strcmp (one, two);
  if (host == 0)
    {
      gint type;
      type = collate_message_type (NULL,
                                   strlen (two_type), two_type,
                                   strlen (one_type), one_type);
      if (type == 0)
        {
          one = *((gchar**) arg_one);
          two = *((gchar**) arg_two);
          return strcmp (one, two);
        }

      return type;
    }
  return host;
}

/**
 * @brief Compares two textual threat level representations, sorting ascending.
 *
 * @param[in]  arg_one  First threat level.
 * @param[in]  arg_two  Second threat level.
 *
 * @return -1, 0 or 1 if first given threat is less than, equal to or greater
 *         than second.
 */
static gint
compare_message_types_asc (gconstpointer arg_one, gconstpointer arg_two)
{
  gchar *one_type, *two_type;
  gchar *one = *((gchar**) arg_one);
  gchar *two = *((gchar**) arg_two);
  gint host;

  one += strlen (one) + 1;
  two += strlen (two) + 1;
  one_type = one;
  two_type = two;

  one += strlen (one) + 1;
  two += strlen (two) + 1;
  host = strcmp (one, two);
  if (host == 0)
    {
      gint type;
      type = collate_message_type (NULL,
                                   strlen (one_type), one_type,
                                   strlen (two_type), two_type);
      if (type == 0)
        {
          one = *((gchar**) arg_one);
          two = *((gchar**) arg_two);
          return strcmp (two, one);
        }

      return type;
    }
  return host;
}

/**
 * @brief Compares two buffered results, sorting by port then threat.
 *
 * @param[in]  arg_one  First result.
 * @param[in]  arg_two  Second result.
 *
 * @return -1, 0 or 1 if first given result is less than, equal to or greater
 *         than second.
 */
static gint
compare_port_threat (gconstpointer arg_one, gconstpointer arg_two)
{
  int host;
  gchar *one = *((gchar**) arg_one);
  gchar *two = *((gchar**) arg_two);
  gchar *one_threat = one + strlen (one) + 1;
  gchar *two_threat = two + strlen (two) + 1;

  host = strcmp (one_threat + strlen (one_threat) + 1,
                 two_threat + strlen (two_threat) + 1);
  if (host == 0)
    {
      int port = strcmp (one, two);
      if (port == 0)
        return collate_message_type (NULL,
                                     strlen (two_threat), two_threat,
                                     strlen (one_threat), one_threat);
      return port;
    }
  return host;
}

/** @todo Defined in omp.c! */
void buffer_results_xml (GString *, iterator_t *, task_t, int, int, int, int,
                         const char *, iterator_t *, int);

/**
 * @brief Comparison returns.
 */
typedef enum
{
  COMPARE_RESULTS_CHANGED,
  COMPARE_RESULTS_ERROR,
  COMPARE_RESULTS_GONE,
  COMPARE_RESULTS_NEW,
  COMPARE_RESULTS_SAME
} compare_results_t;

/**
 * @brief Return the sort order of two results.
 *
 * @param[in]  results        Iterator containing first result.
 * @param[in]  delta_results  Iterator containing second result.
 * @param[in]  sort_order     Whether to sort ascending or descending.
 * @param[in]  sort_field     Field to sort on, or NULL for "type".
 *
 * @return < 0 if first comes before second, 0 if equal, > 0 if first comes
 *         after second.
 */
static compare_results_t
result_cmp (iterator_t *results, iterator_t *delta_results, int sort_order,
            const char* sort_field)
{
  const char *host, *delta_host, *port, *delta_port, *type, *delta_type;
  const char *nvt, *delta_nvt;
  int ret;
  double cvss, delta_cvss;

  if (sort_field == NULL) sort_field = "type";

  host = result_iterator_host (results);
  delta_host = result_iterator_host (delta_results);

  port = result_iterator_port (results);
  delta_port = result_iterator_port (delta_results);

  type = result_iterator_type (results);
  delta_type = result_iterator_type (delta_results);

  cvss = result_iterator_nvt_cvss_base_double (results);
  delta_cvss = result_iterator_nvt_cvss_base_double (delta_results);

  nvt = result_iterator_nvt_oid (results);
  delta_nvt = result_iterator_nvt_oid (delta_results);

  /*
     The part of the SQL that determines the result iterator sorting.

                                   ascending
                                    ? ((strcmp (sort_field, "ROWID") == 0)
                                        ? " ORDER BY results.ROWID"
                                        : ((strcmp (sort_field, "port") == 0)
                                            ? " ORDER BY host COLLATE collate_ip,"
                                              " port,"
                                              " new_type"
                                              " COLLATE collate_message_type DESC,"
                                              " (CAST ((CASE WHEN cvss_base >= 0.0"
                                              "        THEN cvss_base ELSE 0.0 END)"
                                              "  AS REAL)) DESC,"
                                              " nvt,"
                                              " description"
                                            : " ORDER BY host COLLATE collate_ip,"
                                              " new_type COLLATE collate_message_type,"
                                              " port,"
                                              " (CAST ((CASE WHEN cvss_base >= 0.0"
                                              "        THEN cvss_base ELSE 0.0 END)"
                                              "  AS REAL)) DESC,"
                                              " nvt,"
                                              " description"))
                                    : ((strcmp (sort_field, "port") == 0)
                                        ? " ORDER BY host COLLATE collate_ip,"
                                          " port DESC,"
                                          " new_type"
                                          " COLLATE collate_message_type DESC,"
                                          " (CAST ((CASE WHEN cvss_base >= 0.0"
                                          "        THEN cvss_base ELSE 0.0 END)"
                                          "  AS REAL)) DESC,"
                                          " nvt,"
                                          " description"
                                        : " ORDER BY host COLLATE collate_ip,"
                                          " new_type"
                                          " COLLATE collate_message_type DESC,"
                                          " port,"
                                          " (CAST ((CASE WHEN cvss_base >= 0.0"
                                          "        THEN cvss_base ELSE 0.0 END)"
                                          "  AS REAL)) DESC,"
                                          " nvt,"
                                          " description")),
  */

  if (sort_order == 0)
    {
      /* Descending. */

      tracef ("   delta: %s: descending", __FUNCTION__);

      if (strcmp (sort_field, "ROWID") == 0)
        return result_iterator_result (results)
                < result_iterator_result (delta_results);

      ret = collate_ip (NULL, strlen (host), host, strlen (delta_host), delta_host);
      tracef ("   delta: %s: host: %s VS %s (%i)",
              __FUNCTION__, host, delta_host, ret);
      if (ret)
        return ret;

      if (strcmp (sort_field, "port") == 0)
        {
          /* Sorting port first. */

          tracef ("   delta: %s: port first", __FUNCTION__);

          ret = strcmp (port, delta_port);
          tracef ("   delta: %s: port: %s VS %s (%i)",
                  __FUNCTION__, port, delta_port, ret);
          if (ret)
            return -ret;

          ret = collate_message_type (NULL,
                                      strlen (type), type,
                                      strlen (delta_type), delta_type);
          tracef ("   delta: %s: threat: %s VS %s (%i)",
                  __FUNCTION__, type, delta_type, ret);
          if (ret)
            return -ret;

          tracef ("   delta: %s: cvss: %e VS %e",
                  __FUNCTION__, cvss, delta_cvss);
          if (cvss >= 0 && delta_cvss >= 0)
            {
              tracef ("   delta: %s: (NVTs: %s AND %s)",
                      __FUNCTION__, nvt, delta_nvt);
              if (cvss > delta_cvss)
                return -1;
              if (cvss < delta_cvss)
                return 1;
            }

          ret = strcmp (nvt, delta_nvt);
          tracef ("   delta: %s: NVT: %s VS %s (%i)",
                  __FUNCTION__, nvt, delta_nvt, ret);
          if (ret)
            return ret;

          return 0;
        }

      /* Sorting threat first. */

      tracef ("   delta: %s: threat first", __FUNCTION__);

      ret = collate_message_type (NULL,
                                  strlen (type), type,
                                  strlen (delta_type), delta_type);
      tracef ("   delta: %s: threat: %s VS %s (%i)",
              __FUNCTION__, type, delta_type, ret);
      if (ret)
        return -ret;

      ret = strcmp (port, delta_port);
      tracef ("   delta: %s: port: %s VS %s (%i)",
              __FUNCTION__, port, delta_port, ret);
      if (ret)
        return ret;

      tracef ("   delta: %s: cvss: %e VS %e",
              __FUNCTION__, cvss, delta_cvss);
      if (cvss >= 0 && delta_cvss >= 0)
        {
          tracef ("   delta: %s: (NVTs: %s AND %s)",
                  __FUNCTION__, nvt, delta_nvt);
          if (cvss > delta_cvss)
            return -1;
          if (cvss < delta_cvss)
            return 1;
        }

      ret = strcmp (nvt, delta_nvt);
      tracef ("   delta: %s: NVT: %s VS %s (%i)",
              __FUNCTION__, nvt, delta_nvt, ret);
      if (ret)
        return ret;

      return 0;
    }

  /* Ascending. */

  tracef ("   delta: %s: ascending", __FUNCTION__);

  if (strcmp (sort_field, "ROWID") == 0)
    return result_iterator_result (results)
            > result_iterator_result (delta_results);

  ret = collate_ip (NULL, strlen (host), host, strlen (delta_host), delta_host);
  if (ret)
    return ret;

  if (strcmp (sort_field, "port") == 0)
    {
      /* Sorting by port. */

      tracef ("   delta: %s: port first", __FUNCTION__);

      ret = strcmp (port, delta_port);
      if (ret)
        return ret;

      tracef ("   delta: %s: cvss: %e VS %e",
              __FUNCTION__, cvss, delta_cvss);
      if (cvss >= 0 && delta_cvss >= 0)
        {
          tracef ("   delta: %s: (NVTs: %s AND %s)",
                  __FUNCTION__, nvt, delta_nvt);
          if (cvss > delta_cvss)
            return -1;
          if (cvss < delta_cvss)
            return 1;
        }

      ret = collate_message_type (NULL,
                                  strlen (type), type,
                                  strlen (delta_type), delta_type);
      if (ret)
        return -ret;

      ret = strcmp (nvt, delta_nvt);
      tracef ("   delta: %s: NVT: %s VS %s (%i)",
              __FUNCTION__, nvt, delta_nvt, ret);
      if (ret)
        return ret;

      return 0;
    }

  /* Sorting by threat. */

  tracef ("   delta: %s: threat first", __FUNCTION__);

  ret = collate_message_type (NULL,
                              strlen (type), type,
                              strlen (delta_type), delta_type);
  if (ret)
    return ret;

  ret = strcmp (port, delta_port);
  if (ret)
    return ret;

  tracef ("   delta: %s: cvss: %e VS %e",
          __FUNCTION__, cvss, delta_cvss);
  if (cvss >= 0 && delta_cvss >= 0)
    {
      tracef ("   delta: %s: (NVTs: %s AND %s)",
              __FUNCTION__, nvt, delta_nvt);
      if (cvss > delta_cvss)
        return -1;
      if (cvss < delta_cvss)
        return 1;
    }

  ret = strcmp (nvt, delta_nvt);
  tracef ("   delta: %s: NVT: %s VS %s (%i)",
          __FUNCTION__, nvt, delta_nvt, ret);
  if (ret)
    return ret;

  return 0;
}

/**
 * @brief Compare two results.
 *
 * @param[in]  results        Iterator containing first result.
 * @param[in]  delta_results  Iterator containing second result.
 * @param[in]  sort_order     Whether to sort ascending or descending.
 * @param[in]  sort_field     Field to sort on, or NULL for "type".
 *
 * @return Result of comparison.
 */
static compare_results_t
compare_results (iterator_t *results, iterator_t *delta_results, int sort_order,
                 const char* sort_field)
{
  int ret;
  const char *descr, *delta_descr;

  tracef ("   delta: %s", __FUNCTION__);

  ret = result_cmp (results, delta_results, sort_order, sort_field);
  if (ret > 0)
    /* The delta result sorts first, so it is new. */
    return COMPARE_RESULTS_NEW;
  if (ret < 0)
    /* The 'results' result sorts first, so it has gone. */
    return COMPARE_RESULTS_GONE;

  descr = result_iterator_descr (results);
  delta_descr = result_iterator_descr (delta_results);

  tracef ("   delta: %s: descr: %s VS %s (%i)",
          __FUNCTION__, descr, delta_descr, strcmp (descr, delta_descr));

  ret = strcmp (descr, delta_descr);
  if (ret)
    return COMPARE_RESULTS_CHANGED;

  return COMPARE_RESULTS_SAME;
}

/**
 * @brief Compare two results, writing associated XML to a buffer.
 *
 * @param[in]  buffer         Buffer.
 * @param[in]  results        Iterator containing first result.
 * @param[in]  delta_results  Iterator containing second result.
 * @param[in]  task           Task associated with report.
 * @param[in]  notes              Whether to include notes.
 * @param[in]  notes_details      If notes, Whether to include details.
 * @param[in]  overrides          Whether to include overrides.
 * @param[in]  overrides_details  If overrides, Whether to include details.
 * @param[in]  sort_order     Whether to sort ascending or descending.
 * @param[in]  sort_field     Field to sort on, or NULL for "type".
 * @param[in]  changed        Whether to include changed results.
 * @param[in]  gone           Whether to include gone results.
 * @param[in]  new            Whether to include new results.
 * @param[in]  same           Whether to include same results.
 * @param[in]  max_results    Value to decrement if result is buffered.
 * @param[in]  first_result   Skip result and decrement if positive.
 * @param[in]  used           0 if used, 1 if skipped.
 * @param[in]  would_use      0 if would use (first_result aside), 1 if skipped.
 *
 * @return Result of comparison.
 */
static compare_results_t
compare_and_buffer_results (GString *buffer, iterator_t *results,
                            iterator_t *delta_results, task_t task, int notes,
                            int notes_details, int overrides,
                            int overrides_details, int sort_order,
                            const char* sort_field, int changed, int gone,
                            int new, int same, int *max_results,
                            int *first_result, int *used, int *would_use)
{
  compare_results_t state;
  state = compare_results (results, delta_results, sort_order, sort_field);
  *used = 0;
  *would_use = 0;
  switch (state)
    {
      case COMPARE_RESULTS_CHANGED:
        if (changed)
          {
            *would_use = 1;
            if (*first_result)
              {
                tracef ("   delta: skip");
                (*first_result)--;
                break;
              }
            *used = 1;
            (*max_results)--;
            if (buffer)
              buffer_results_xml (buffer,
                                  results,
                                  task,
                                  notes,
                                  notes_details,
                                  overrides,
                                  overrides_details,
                                  "changed",
                                  delta_results,
                                  1);
          }
        break;

      case COMPARE_RESULTS_GONE:
        if (gone)
          {
            *would_use = 1;
            if (*first_result)
              {
                tracef ("   delta: skip");
                (*first_result)--;
                break;
              }
            *used = 1;
            (*max_results)--;
            if (buffer)
              buffer_results_xml (buffer,
                                  results,
                                  task,
                                  notes,
                                  notes_details,
                                  overrides,
                                  overrides_details,
                                  "gone",
                                  delta_results,
                                  0);
          }
        break;

      case COMPARE_RESULTS_NEW:
        if (new)
          {
            *would_use = 1;
            if (*first_result)
              {
                tracef ("   delta: skip");
                (*first_result)--;
                break;
              }
            *used = 1;
            (*max_results)--;
            if (buffer)
              buffer_results_xml (buffer,
                                  delta_results,
                                  task,
                                  notes,
                                  notes_details,
                                  overrides,
                                  overrides_details,
                                  "new",
                                  delta_results,
                                  0);
          }
        break;

      case COMPARE_RESULTS_SAME:
        if (same)
          {
            *would_use = 1;
            if (*first_result)
              {
                tracef ("   delta: skip");
                (*first_result)--;
                break;
              }
            *used = 1;
            (*max_results)--;
            if (buffer)
              buffer_results_xml (buffer,
                                  results,
                                  task,
                                  notes,
                                  notes_details,
                                  overrides,
                                  overrides_details,
                                  "same",
                                  delta_results,
                                  0);
          }
        break;

      default:
        return COMPARE_RESULTS_ERROR;
    }

  return state;
}

/**
 * @brief Write to a file or close stream and exit.
 *
 * @param[in]   stream    Stream to write to.
 * @param[in]   format    Format specification.
 * @param[in]   args      Arguments.
 */
#define PRINT(stream, format, args...)                                       \
  do                                                                         \
    {                                                                        \
      gchar *msg;                                                            \
      msg = g_markup_printf_escaped (format, ## args);                       \
      if (fprintf (stream, "%s", msg) < 0)                                   \
        {                                                                    \
          g_free (msg);                                                      \
          fclose (stream);                                                   \
          return -1;                                                         \
        }                                                                    \
      g_free (msg);                                                          \
    }                                                                        \
  while (0)

/**
 * @brief Write XML to a file or close stream and return.
 *
 * @param[in]   stream  Stream to write to.
 * @param[in]   xml     XML.
 */
#define PRINT_XML(stream, xml)                                               \
  do                                                                         \
    {                                                                        \
      if (fprintf (stream, "%s", xml) < 0)                                   \
        {                                                                    \
          fclose (stream);                                                   \
          return -1;                                                         \
        }                                                                    \
    }                                                                        \
  while (0)

#if 0
void
dump (GArray *ports)
{
  int index;
  for (index = 0; index < ports->len; index++)
    {
      char *port = g_array_index (ports, char*, index);
      char *threat = port + strlen (port) + 1;
      tracef ("  == %s %s %s", threat + strlen (threat) + 1, port, threat);
    }
}
#endif

/**
 * @brief Add a port to a port tree.
 *
 * @param[in]  ports    The tree.
 * @param[in]  results  Result iterator on result whose port to add.
 */
static void
add_port (GTree *ports, iterator_t *results)
{
  const char *old_type, *type, *port, *host;
  GTree *host_ports;

  /* Ensure there's an inner tree for the host. */

  host = result_iterator_host (results);
  host_ports = g_tree_lookup (ports, host);
  if (host_ports == NULL)
    {
      host_ports = g_tree_new_full ((GCompareDataFunc) strcmp, NULL, g_free,
                                    g_free);
      g_tree_insert (ports, g_strdup (host), host_ports);
    }

  /* Ensure the highest threat is recorded for the port in the inner tree. */

  port = result_iterator_port (results);
  type = result_iterator_type (results);
  old_type = g_tree_lookup (host_ports, port);
  tracef ("   delta: %s: adding %s threat %s on host %s", __FUNCTION__,
          port, type, host);
  if (old_type == NULL)
    g_tree_insert (host_ports, g_strdup (port), g_strdup (type));
  else if (collate_message_type (NULL,
                                 strlen (type), type,
                                 strlen (old_type), old_type)
           > 0)
    g_tree_replace (host_ports, g_strdup (port), g_strdup (type));
}

/**
 * @brief Print delta host ports.
 *
 * @param[in]  key     Port.
 * @param[in]  value   Threat.
 * @param[in]  data    Host and stream.
 */
static gboolean
print_host_port (gpointer key, gpointer value, gpointer data)
{
  gpointer *host_and_stream;
  host_and_stream = (gpointer*) data;
  tracef ("   delta: %s: host %s port %s", __FUNCTION__,
          (gchar*) host_and_stream[0], (gchar*) key);
  fprintf ((FILE*) host_and_stream[1],
           "<port>"
           "<host>%s</host>"
           "%s"
           "<threat>%s</threat>"
           "</port>",
           (gchar*) host_and_stream[0],
           (gchar*) key,
           manage_result_type_threat ((gchar*) value));
  return FALSE;
}

/**
 * @brief Print delta ports.
 *
 * @param[in]  key     Host.
 * @param[in]  value   Port tree.
 * @param[in]  stream  Stream.
 */
static gboolean
print_host_ports (gpointer key, gpointer value, gpointer stream)
{
  gpointer host_and_stream[2];
  host_and_stream[0] = key;
  host_and_stream[1] = stream;
  tracef ("   delta: %s: host %s", __FUNCTION__, (gchar*) key);
  g_tree_foreach ((GTree*) value, print_host_port, host_and_stream);
  return FALSE;
}

/**
 * @brief Add port to ports array.
 *
 * @param[in]  key     Port.
 * @param[in]  value   Threat.
 * @param[in]  ports   Ports array.
 */
static gboolean
array_add_port (gpointer key, gpointer value, gpointer ports)
{
  gpointer *port_threat;
  port_threat = g_malloc (2 * sizeof (gpointer));
  port_threat[0] = key;
  port_threat[1] = value;
  array_add ((array_t*) ports, port_threat);
  return FALSE;
}

/**
 * @brief Print delta ports, in descending order.
 *
 * @param[in]  key     Host.
 * @param[in]  value   Port tree.
 * @param[in]  stream  Stream.
 */
static gboolean
print_host_ports_desc (gpointer key, gpointer value, gpointer stream)
{
  guint index;
  array_t *ports;

  tracef ("   delta: %s: host %s", __FUNCTION__, (gchar*) key);

  /* Convert tree to array. */

  ports = make_array ();
  g_tree_foreach ((GTree*) value, array_add_port, ports);

  /* Print the array backwards. */

  index = ports->len;
  while (index--)
    {
      gpointer *port_threat;
      port_threat = g_ptr_array_index (ports, index);
      fprintf ((FILE*) stream,
               "<port>"
               "<host>%s</host>"
               "%s"
               "<threat>%s</threat>"
               "</port>",
               (gchar*) key,
               (gchar*) port_threat[0],
               manage_result_type_threat ((gchar*) port_threat[1]));
    }

  array_free (ports);

  return FALSE;
}

/**
 * @brief Compare port threats, ascending.
 *
 * @param[in]  one  First.
 * @param[in]  two  Second.
 */
static gint
compare_ports_threat (gconstpointer one, gconstpointer two)
{
  gpointer *port_threat_one, *port_threat_two;
  port_threat_one = *((gpointer**) one);
  port_threat_two = *((gpointer**) two);
  return collate_message_type (NULL,
                               strlen (port_threat_one[1]), port_threat_one[1],
                               strlen (port_threat_two[1]), port_threat_two[1]);
}

/**
 * @brief Compare port threats, descending.
 *
 * @param[in]  one  First.
 * @param[in]  two  Second.
 */
static gint
compare_ports_threat_desc (gconstpointer one, gconstpointer two)
{
  gpointer *port_threat_one, *port_threat_two;
  port_threat_one = *((gpointer**) one);
  port_threat_two = *((gpointer**) two);
  return - collate_message_type (NULL,
                                 strlen (port_threat_one[1]), port_threat_one[1],
                                 strlen (port_threat_two[1]), port_threat_two[1]);
}

/**
 * @brief Print delta ports, ordering by threat.
 *
 * @param[in]  key        Host.
 * @param[in]  value      Port tree.
 * @param[in]  stream     Stream.
 * @param[in]  ascending  Ascending or descending.
 */
static gboolean
print_host_ports_by_type (gpointer key, gpointer value, gpointer stream,
                          int ascending)
{
  guint index, len;
  array_t *ports;

  tracef ("   delta: %s: host %s", __FUNCTION__, (gchar*) key);

  /* Convert tree to array. */

  ports = make_array ();
  g_tree_foreach ((GTree*) value, array_add_port, ports);

  /* Sort the array. */

  if (ascending)
    g_ptr_array_sort (ports, compare_ports_threat);
  else
    g_ptr_array_sort (ports, compare_ports_threat_desc);

  /* Print the sorted array. */

  index = 0;
  len = ports->len;
  while (index < len)
    {
      gpointer *port_threat;
      port_threat = g_ptr_array_index (ports, index);
      fprintf ((FILE*) stream,
               "<port>"
               "<host>%s</host>"
               "%s"
               "<threat>%s</threat>"
               "</port>",
               (gchar*) key,
               (gchar*) port_threat[0],
               manage_result_type_threat ((gchar*) port_threat[1]));
      index++;
    }

  array_free (ports);

  return FALSE;
}

/**
 * @brief Print delta ports, ordering by threat descending.
 *
 * @param[in]  key     Host.
 * @param[in]  value   Port tree.
 * @param[in]  stream  Stream.
 */
static gboolean
print_host_ports_by_type_desc (gpointer key, gpointer value, gpointer stream)
{
  return print_host_ports_by_type (key, value, stream, 0);
}

/**
 * @brief Print delta ports, ordering by threat ascending.
 *
 * @param[in]  key     Host.
 * @param[in]  value   Port tree.
 * @param[in]  stream  Stream.
 */
static gboolean
print_host_ports_by_type_asc (gpointer key, gpointer value, gpointer stream)
{
  return print_host_ports_by_type (key, value, stream, 1);
}

/**
 * @brief Free delta host ports.
 *
 * @param[in]  host_ports  Ports.
 * @param[in]  dummy       Dummy.
 */
static gboolean
free_host_ports (GTree *host_ports, gpointer dummy)
{
  g_tree_destroy (host_ports);
  return FALSE;
}

/**
 * @brief Get N'th last report_host given a host.
 *
 * The last report_host is at position 1, the second last at position 2, and
 * so on.
 *
 * @param[in]  host         Host.
 * @param[in]  report_host  Report host.
 * @param[in]  position     Position from end.
 */
static gboolean
host_nthlast_report_host (const char *host, report_host_t *report_host,
                          int position)
{
  gchar *quoted_host;

  assert (current_credentials.uuid);

  if (position == 0)
    position = 1;

  quoted_host = sql_quote (host);
  switch (sql_int64 (report_host, 0, position - 1,
                     "SELECT ROWID FROM report_hosts WHERE host = '%s'"
                     " AND (SELECT reports.owner FROM reports"
                     "      WHERE reports.ROWID = report_hosts.report)"
                     "     = (SELECT ROWID FROM users"
                     "        WHERE users.uuid = '%s')"
                     " AND (SELECT tasks.hidden FROM tasks, reports"
                     "      WHERE reports.task = tasks.ROWID"
                     "      AND reports.ROWID = report_hosts.report)"
                     "     = 0"
                     " AND (SELECT value FROM task_preferences, tasks,"
                     "                        reports"
                     "      WHERE reports.task = tasks.ROWID"
                     "      AND reports.ROWID = report_hosts.report"
                     "      AND task_preferences.task = tasks.ROWID"
                     "      AND task_preferences.name = 'in_assets')"
                     "     = 'yes'"
                     " AND (report_hosts.end_time IS NOT NULL"
                     "      AND report_hosts.end_time != '')"
                     " ORDER BY ROWID DESC LIMIT %i;",
                     quoted_host,
                     current_credentials.uuid,
                     position))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *report_host = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        return TRUE;
        break;
    }

  g_free (quoted_host);
  return FALSE;
}

/**
 * @brief Count host reports.
 *
 * @param[in]  host  Host.
 *
 * @return Report count.
 */
static int
host_report_count (const char *host)
{
  int count;
  gchar *quoted_host;
  assert (current_credentials.uuid);
  quoted_host = sql_quote (host);
  count = sql_int (0, 0,
                   "SELECT count (*) FROM report_hosts WHERE host = '%s'"
                   "  AND (SELECT reports.owner FROM reports"
                   "       WHERE reports.ROWID = report_hosts.report)"
                   "      = (SELECT ROWID FROM users"
                   "         WHERE users.uuid = '%s')"
                   "  AND (SELECT tasks.hidden FROM tasks, reports"
                   "       WHERE reports.task = tasks.ROWID"
                   "       AND reports.ROWID = report_hosts.report)"
                   "      = 0"
                   "  AND (SELECT reports.scan_run_status FROM reports"
                   "       WHERE reports.ROWID = report_hosts.report)"
                   "      = %u;",
                   quoted_host,
                   current_credentials.uuid,
                   TASK_STATUS_DONE);
  g_free (quoted_host);
  return count;
}

/**
 * @brief Count hosts.
 *
 * @return Host count.
 */
static int
host_count ()
{
  return sql_int (0, 0,
                  "SELECT count (DISTINCT host) FROM report_hosts"
                  " WHERE host != 'localhost';");
}

/**
 * @brief Count hosts with filtering.
 *
 * @param[in]  levels         Levels.
 * @param[in]  search_phrase  Phrase that host IPs must include.  All hosts
 *                            if NULL or "".
 * @param[in]  apply_overrides  Whether to apply overrides.
 *
 * @return Host count.
 */
static int
filtered_host_count (const char *levels, const char *search_phrase,
                     int apply_overrides)
{
  assert (current_credentials.uuid);

  if (levels && strlen (levels))
    {
      int ret;
      GString *levels_sql;
      gchar *new_type_sql;

      if (apply_overrides)
        {
          gchar *ov;

          assert (current_credentials.uuid);

          ov = g_strdup_printf
                ("SELECT overrides.new_threat"
                 " FROM overrides"
                 " WHERE overrides.nvt = results.nvt"
                 " AND ((overrides.owner IS NULL)"
                 " OR (overrides.owner ="
                 " (SELECT ROWID FROM users"
                 "  WHERE users.uuid = '%s')))"
                 " AND ((overrides.end_time = 0)"
                 "      OR (overrides.end_time >= now ()))"
                 " AND (overrides.task ="
                 "      (SELECT reports.task FROM reports, report_results"
                 "       WHERE report_results.result = results.ROWID"
                 "       AND report_results.report = reports.ROWID)"
                 "      OR overrides.task = 0)"
                 " AND (overrides.result = results.ROWID"
                 "      OR overrides.result = 0)"
                 " AND (overrides.hosts is NULL"
                 "      OR overrides.hosts = \"\""
                 "      OR hosts_contains (overrides.hosts, results.host))"
                 " AND (overrides.port is NULL"
                 "      OR overrides.port = \"\""
                 "      OR overrides.port = results.port)"
                 " AND (overrides.threat is NULL"
                 "      OR overrides.threat = \"\""
                 "      OR overrides.threat = results.type)"
                 " ORDER BY overrides.result DESC, overrides.task DESC,"
                 " overrides.port DESC, overrides.threat"
                 " COLLATE collate_message_type ASC",
                 current_credentials.uuid);

          new_type_sql = g_strdup_printf ("coalesce ((%s), type)", ov);

          g_free (ov);
        }
      else
        new_type_sql = g_strdup ("type");

      levels_sql = where_levels (levels);

      if (search_phrase && strlen (search_phrase))
        {
          gchar *quoted_search_phrase;

          quoted_search_phrase = sql_quote (search_phrase);
          ret = sql_int (0, 0,
                         "SELECT"
                         " count (*),"
                         " distinct_host,"
                         " (SELECT report FROM report_hosts"
                         "  WHERE report_hosts.host = distinct_host"
                         "  AND end_time IS NOT NULL"
                         "  AND end_time != ''"
                         "  AND (SELECT owner FROM reports"
                         "       WHERE ROWID = report)"
                         "      = (SELECT ROWID FROM users"
                         "         WHERE users.uuid = '%s')"
                         "  AND (SELECT reports.scan_run_status = %u"
                         "       FROM reports"
                         "       WHERE reports.ROWID = report)"
                         "  AND (SELECT hidden FROM tasks"
                         "       WHERE tasks.ROWID"
                         "             = (SELECT task FROM reports"
                         "                WHERE reports.ROWID = report))"
                         "      = 0"
                         "  AND (SELECT value FROM task_preferences"
                         "       WHERE task_preferences.task"
                         "             = (SELECT task FROM reports"
                         "                WHERE reports.ROWID = report)"
                         "       AND task_preferences.name = 'in_assets')"
                         "      = 'yes'"
                         "  ORDER BY ROWID DESC)"
                         "  AS last_report"
                         " FROM (SELECT DISTINCT host AS distinct_host"
                         "       FROM report_hosts)"
                         /* Search IP. */
                         " WHERE (distinct_host LIKE '%%%s%%%'"
                         /* Search hostname. */
                         "        OR EXISTS"
                         "        (SELECT * FROM report_host_details"
                         "         WHERE report_host"
                         "               = (SELECT ROWID FROM report_hosts"
                         "                  WHERE report = last_report"
                         "                  AND host = distinct_host)"
                         "         AND (name = 'hostname'"
                         "              OR name = 'best_os_txt'"
                         "              OR name = 'best_os_cpe' OR name = 'App'"
                         "              OR name = 'ports')"
                         "         AND source_type = 'nvt'"
                         "         AND value LIKE '%%%s%%'))"
                         " AND EXISTS (SELECT results.ROWID, %s AS new_type"
                         "             FROM results"
                         "             WHERE results.report = last_report"
                         "             AND results.host = distinct_host"
                         "             %s);",
                         current_credentials.uuid,
                         TASK_STATUS_DONE,
                         quoted_search_phrase,
                         quoted_search_phrase,
                         new_type_sql,
                         levels_sql ? levels_sql->str : "");
          g_free (quoted_search_phrase);
        }
      else
        ret = sql_int (0, 0,
                       "SELECT"
                       " count (*),"
                       " distinct_host,"
                       " (SELECT report FROM report_hosts"
                       "  WHERE report_hosts.host = distinct_host"
                       "  AND end_time IS NOT NULL"
                       "  AND end_time != ''"
                       "  AND (SELECT owner FROM reports"
                       "       WHERE ROWID = report)"
                       "      = (SELECT ROWID FROM users"
                       "         WHERE users.uuid = '%s')"
                       "  AND (SELECT reports.scan_run_status = %u"
                       "       FROM reports"
                       "       WHERE reports.ROWID = report)"
                       "  AND (SELECT hidden FROM tasks"
                       "       WHERE tasks.ROWID"
                       "             = (SELECT task FROM reports"
                       "                WHERE reports.ROWID = report))"
                       "      = 0"
                       "  AND (SELECT value FROM task_preferences"
                       "       WHERE task_preferences.task"
                       "             = (SELECT task FROM reports"
                       "                WHERE reports.ROWID = report)"
                       "       AND task_preferences.name = 'in_assets')"
                       "      = 'yes'"
                       "  ORDER BY ROWID DESC)"
                       "  AS last_report"
                       " FROM (SELECT DISTINCT host AS distinct_host"
                       "       FROM report_hosts)"
                       " WHERE EXISTS (SELECT results.ROWID, %s AS new_type"
                       "               FROM results"
                       "               WHERE results.report = last_report"
                       "               AND results.host = distinct_host"
                       "               %s);",
                       current_credentials.uuid,
                       TASK_STATUS_DONE,
                       new_type_sql,
                       levels_sql ? levels_sql->str : "");

      if (levels_sql)
        g_string_free (levels_sql, TRUE);
      g_free (new_type_sql);

      return ret;
    }
  else if (search_phrase && strlen (search_phrase))
    {
      int retn;
      gchar *quoted_search_phrase;

      quoted_search_phrase = sql_quote (search_phrase);
      retn = sql_int (0, 0,
                      "SELECT count(*) FROM"
                      " (SELECT host"
                      "  FROM report_hosts"
                      "  WHERE (SELECT reports.owner FROM reports"
                      "         WHERE reports.ROWID = report_hosts.report)"
                      "        = (SELECT ROWID FROM users"
                      "           WHERE users.uuid = '%s')"
                      "  AND (SELECT tasks.hidden FROM tasks, reports"
                      "       WHERE reports.task = tasks.ROWID"
                      "       AND reports.ROWID = report_hosts.report)"
                      "      = 0"
                      "  AND (report_hosts.end_time IS NOT NULL"
                      "       AND report_hosts.end_time != '')"
                      "  GROUP BY host"
                      "  HAVING host LIKE '%%%s%%'"
                      "  OR EXISTS"
                      "  (SELECT * FROM report_host_details"
                      "   WHERE report_hosts.ROWID = report_host"
                      "   AND (name = 'hostname' OR name = 'best_os_txt'"
                      "        OR name = 'best_os_cpe' OR name = 'App'"
                      "        OR name = 'ports')"
                      "   AND source_type = 'nvt'"
                      "   AND value LIKE '%%%s%%')"
                      "  ORDER BY host COLLATE collate_ip);",
                      current_credentials.uuid,
                      quoted_search_phrase,
                      quoted_search_phrase);
      g_free (quoted_search_phrase);
      return retn;
    }

  return sql_int (0, 0,
                  "SELECT count(*) FROM"
                  " (SELECT DISTINCT host FROM report_hosts"
                  "  WHERE (SELECT reports.owner FROM reports"
                  "         WHERE reports.ROWID = report_hosts.report)"
                  "        = (SELECT ROWID FROM users"
                  "           WHERE users.uuid = '%s')"
                  "  AND (SELECT tasks.hidden FROM tasks, reports"
                  "       WHERE reports.task = tasks.ROWID"
                  "       AND reports.ROWID = report_hosts.report)"
                  "      = 0"
                  "  AND (report_hosts.end_time IS NOT NULL"
                  "       AND report_hosts.end_time != ''));",
                  current_credentials.uuid);
}

/**
 * @brief Buffer host.
 */
struct buffer_host
{
  gchar *ip;                  ///< IP of host.
  report_host_t report_host;  ///< Report host of host.
};

/**
 * @brief Buffer host type.
 */
typedef struct buffer_host buffer_host_t;

/**
 * @brief Free print_report_xml prognostic host buffer.
 *
 * @param[in]  buffer  The buffer.
 */
static void
free_buffer (array_t *buffer)
{
  guint index;
  /* Free the buffer. */
  index = buffer->len;
  while (index--)
    {
      buffer_host_t *buffer_host;
      buffer_host = (buffer_host_t*) g_ptr_array_index (buffer, index);
      if (buffer_host)
        {
          g_free (buffer_host->ip);
          g_free (buffer_host);
        }
    }
  g_ptr_array_free (buffer, TRUE);
}

/**
 * @brief Buffer CVE for print_report_xml.
 *
 * @param[in]  cves     CVEs.
 * @param[in]  details  Report host details iterator.
 */
static void
buffer_cve (array_t *cves, iterator_t *details)
{
  const char *detail_name;
  detail_name = report_host_details_iterator_name (details);
  if (strcmp (detail_name, "Closed CVE") == 0)
    {
      gchar **point, **split;

      /* Buffer each CVE. */
      split = g_strsplit (report_host_details_iterator_value (details),
                          ",",
                          0);
      point = split;
      while (*point)
        {
          g_strstrip (*point);
          if (array_find_string (cves, *point) == NULL)
            array_add (cves, g_strdup (*point));
          point++;
        }
      g_strfreev (split);
    }
}

/**
 * @brief Get filter term corresponding to report filtering.
 *
 * @param[in]  sort_order  Whether to sort ascending or descending.
 * @param[in]  sort_field  Field to sort on, or NULL for "type".
 * @param[in]  result_hosts_only  Whether to show only hosts with results.
 * @param[in]  min_cvss_base      Minimum CVSS base of included results.  All
 *                                results if NULL.
 * @param[in]  levels         String describing threat levels (message types)
 *                            to include in count (for example, "hmlgd" for
 *                            High, Medium, Low, loG and Debug).  All levels if
 *                            NULL.
 * @param[in]  delta_states   String describing delta states to include in count
 *                            (for example, "sngc" Same, New, Gone and Changed).
 *                            All levels if NULL.
 * @param[in]  search_phrase      Phrase that results must include.  All results
 *                                if NULL or "".
 * @param[in]  search_phrase_exact  Whether search phrase is exact.
 * @param[in]  autofp             Whether to apply the auto FP filter.
 * @param[in]  show_closed_cves   Whether to include the Closed CVEs host detail.
 * @param[in]  notes              Whether to include notes.
 * @param[in]  overrides          Whether to include overrides.
 * @param[in]  first_result       The result to start from.  The results are 0
 *                                indexed.
 * @param[in]  max_results        The maximum number of results returned.
 *
 * @return Filter term.
 */
static gchar *
report_filter_term (int sort_order, const char* sort_field,
                    int result_hosts_only,
                    const char *min_cvss_base,
                    const char *levels, const char *delta_states,
                    const char *search_phrase, int search_phrase_exact,
                    int autofp, int show_closed_cves, int notes, int overrides,
                    int first_result, int max_results)
{
  return g_strdup_printf ("%s%s%s"
                          "%s%s=%s"
                          " result_hosts_only=%i"
                          " min_cvss_base=%s"
                          " levels=%s"
                          " autofp=%i"
                          " show_closed_cves=%i"
                          " notes=%i"
                          " overrides=%i"
                          " first=%i"
                          " rows=%i"
                          " delta_states=%s",
                          (search_phrase
                           && strlen (search_phrase)
                           && search_phrase_exact)
                            ? "=" : "",
                          search_phrase && strlen (search_phrase) ? "\"" : "",
                          search_phrase ? search_phrase : "",
                          search_phrase && strlen (search_phrase) ? "\" " : "",
                          sort_order ? "sort" : "sort-reverse",
                          sort_field ? sort_field : "ROWID",
                          result_hosts_only,
                          min_cvss_base ? min_cvss_base : "",
                          levels ? levels : "hmlgd",
                          autofp,
                          show_closed_cves,
                          notes,
                          overrides,
                          first_result + 1,
                          max_results,
                          delta_states ? delta_states : "");
}

/**
 * @brief Print the XML for a report to a file.
 *
 * @param[in]  report      The report.
 * @param[in]  delta       Report to compare with the report.
 * @param[in]  task        Task associated with report.
 * @param[in]  xml_file    File name.
 * @param[in]  get         GET command data.
 * @param[in]  sort_order  Whether to sort ascending or descending.
 * @param[in]  given_sort_field   Field to sort on, or NULL for "type".
 * @param[in]  result_hosts_only  Whether to show only hosts with results.
 * @param[in]  given_min_cvss_base  Minimum CVSS base of included results.  All
 *                                  results if NULL.
 * @param[in]  report_format  Format of report that will be created from XML.
 * @param[in]  given_levels   String describing threat levels (message types)
 *                            to include in count (for example, "hmlgd" for
 *                            High, Medium, Low, loG and Debug).  All levels if
 *                            NULL.
 * @param[in]  given_delta_states  String describing delta states to include in
 *                                 count (for example, "sngc" Same, New, Gone
 *                                 and Changed).  All levels if NULL.
 * @param[in]  apply_overrides    Whether to apply overrides.
 * @param[in]  given_search_phrase  Phrase that results must include.  All
 *                                  results if NULL or "".
 * @param[in]  autofp             Whether to apply the auto FP filter.
 * @param[in]  show_closed_cves   Whether to include the Closed CVEs host detail.
 * @param[in]  notes              Whether to include notes.
 * @param[in]  notes_details      If notes, Whether to include details.
 * @param[in]  overrides          Whether to include overrides.
 * @param[in]  overrides_details  If overrides, Whether to include details.
 * @param[in]  first_result       The result to start from.  The results are 0
 *                                indexed.
 * @param[in]  max_results        The maximum number of results returned.
 * @param[in]  type               Type of report, NULL, "scan" or "assets".
 * @param[in]  host               Host or NULL, when type "assets".
 * @param[in]  pos                Position of report from end, when type
 *                                "assets".
 * @param[in]  host_search_phrase  Phrase that results must include.  All results
 *                                 if NULL or "".  For hosts.
 * @param[in]  host_levels         String describing threat levels (message types)
 *                                 to include in count (for example, "hmlgd" for
 *                                 High, Medium, Low, loG and Debug).  All levels if
 *                                 NULL.
 * @param[in]  host_first_result   The host result to start from.  The results
 *                                 are 0 indexed.
 * @param[in]  host_max_results    The host maximum number of results returned.
 *
 * @return 0 on success, -1 error, 2 failed to find filter (before any printing).
 */
static int
print_report_xml (report_t report, report_t delta, task_t task, gchar* xml_file,
                  const get_data_t *get,
                  int sort_order, const char *given_sort_field, int result_hosts_only,
                  const char *given_min_cvss_base, report_format_t report_format,
                  const char *given_levels, const char *given_delta_states,
                  int apply_overrides, const char *given_search_phrase, int autofp,
                  int show_closed_cves, int notes, int notes_details,
                  int overrides, int overrides_details, int first_result,
                  int max_results, const char *type, const char *host, int pos,
                  const char *host_search_phrase, const char *host_levels,
                  int host_first_result, int host_max_results)
{
  FILE *out;
  gchar *term, *sort_field, *levels, *search_phrase, *min_cvss_base;
  gchar *delta_states;
  char *uuid, *tsk_uuid = NULL, *start_time, *end_time;
  int result_count, filtered_result_count, run_status;
  array_t *result_hosts;
  iterator_t results, delta_results, params;
  int debugs, holes, infos, logs, warnings, false_positives;
  int f_debugs, f_holes, f_infos, f_logs, f_warnings, f_false_positives;
  int orig_f_debugs, orig_f_holes, orig_f_infos, orig_f_logs;
  int orig_f_warnings, orig_f_false_positives, orig_filtered_result_count;
  int search_phrase_exact;

  /* Init some vars to prevent warnings from older compilers. */
  result_count = 0;
  orig_filtered_result_count = 0;
  orig_f_false_positives = orig_f_warnings = orig_f_logs = orig_f_infos = 0;
  orig_f_holes = orig_f_debugs = 0;

  /** @todo Leaks on error in PRINT.  The process normally exits then anyway. */

  /* run_status is set by report_scan_run_status when either of "delta" and
   * "report" are true.  run_status is only used by run_status_name, only when
   * either of "delta" and "report" are true, and only after a
   * report_scan_run_status call.  Still GCC 4.4.5 (Debian 4.4.5-8) gives a
   * "may be used uninitialized" warning, so init it here to quiet the
   * warning. */
  run_status = TASK_STATUS_INTERNAL_ERROR;

  if ((type == NULL) || (strcmp (type, "scan") == 0))
    {
      type = NULL;
      if (report == 0)
        {
          assert (0);
          return -1;
        }
    }

  out = fopen (xml_file, "w");

  if (out == NULL)
    {
      g_warning ("%s: fopen failed: %s\n",
                 __FUNCTION__,
                 strerror (errno));
      return -1;
    }

  if (get
      && ((get->filt_id && strlen (get->filt_id) && strcmp (get->filt_id, "0"))
          || (get->filter && strlen (get->filter))))
    {
      term = NULL;
      if (get->filt_id && strlen (get->filt_id) && strcmp (get->filt_id, "0"))
        {
          term = filter_term (get->filt_id);
          if (term == NULL)
            return 2;
        }

      /* Set the filter parameters from the filter term. */
      manage_report_filter_controls (term ? term : get->filter,
                                     &first_result, &max_results, &sort_field,
                                     &sort_order, &result_hosts_only,
                                     &min_cvss_base, &levels, &delta_states,
                                     &search_phrase, &search_phrase_exact,
                                     &autofp, &show_closed_cves, &notes,
                                     &overrides);
    }
  else
    {
      sort_field = g_strdup (given_sort_field);
      levels = g_strdup (given_levels);
      search_phrase = g_strdup (given_search_phrase);
      search_phrase_exact = 0;
      min_cvss_base = g_strdup (given_min_cvss_base);
      delta_states = g_strdup (given_delta_states);

      /* Build the filter term from the old style GET attributes. */
      term = report_filter_term (sort_order, sort_field, result_hosts_only,
                                 min_cvss_base, levels, delta_states,
                                 search_phrase, search_phrase_exact, autofp,
                                 show_closed_cves, notes, overrides,
                                 first_result, max_results);
    }

  levels = levels ? levels : g_strdup ("hmlgd");

  if (task && task_uuid (task, &tsk_uuid))
    {
      fclose (out);
      g_free (sort_field);
      g_free (levels);
      g_free (search_phrase);
      g_free (min_cvss_base);
      g_free (delta_states);
      return -1;
    }

  if (delta && report)
    {
      uuid = report_uuid (report);
      PRINT (out, "<report type=\"delta\" id=\"%s\">", uuid);
      free (uuid);
    }
  else if (report)
    {
      uuid = report_uuid (report);
      PRINT (out, "<report id=\"%s\">", uuid);
      free (uuid);
    }
  else if (type && (strcmp (type, "assets") == 0))
    PRINT (out, "<report scap_loaded=\"%i\" type=\"%s\">",
           manage_scap_loaded (),
           type);
  else
    PRINT (out, "<report type=\"%s\">", type);

  if (delta)
    {
      delta_states = delta_states ? delta_states : "cgns";
      report_scan_run_status (delta, &run_status);

      uuid = report_uuid (delta);
      PRINT (out,
             "<delta>"
             "<report id=\"%s\">"
             "<scan_run_status>%s</scan_run_status>",
             uuid,
             run_status_name (run_status
                               ? run_status
                               : TASK_STATUS_INTERNAL_ERROR));

      start_time = scan_start_time (delta);
      PRINT (out,
             "<scan_start>%s</scan_start>",
             start_time);
      free (start_time);

      end_time = scan_end_time (delta);
      PRINT (out,
             "<scan_end>%s</scan_end>",
             end_time);
      free (end_time);

      PRINT (out,
             "</report>"
             "</delta>");
    }

  PRINT (out, "<report_format>");
  init_report_format_param_iterator (&params, report_format, 0, 1, NULL);
  while (next (&params))
    PRINT (out,
           "<param><name>%s</name><value>%s</value></param>",
           report_format_param_iterator_name (&params),
           report_format_param_iterator_value (&params));
  cleanup_iterator (&params);
  PRINT (out, "</report_format>");

  if (report)
    {
      if (delta == 0)
        {
          report_scan_result_count (report, NULL, NULL, 0, NULL,
                                    apply_overrides, autofp,
                                    &result_count);
        }
      report_scan_result_count (report,
                                levels,
                                search_phrase,
                                search_phrase_exact,
                                min_cvss_base,
                                apply_overrides,
                                autofp,
                                &filtered_result_count);
      report_scan_run_status (report, &run_status);
    }

  PRINT
   (out,
    "<sort><field>%s<order>%s</order></field></sort>"
    "<filters id=\"%s\">"
    "<term>%s</term>"
    "%s"
    "<phrase>%s</phrase>"
    "<autofp>%i</autofp>"
    "<show_closed_cves>%i</show_closed_cves>"
    "<notes>%i</notes>"
    "<overrides>%i</overrides>"
    "<apply_overrides>%i</apply_overrides>"
    "<result_hosts_only>%i</result_hosts_only>"
    "<min_cvss_base>%s</min_cvss_base>",
    sort_field ? sort_field : "type",
    sort_order ? "ascending" : "descending",
    get && get->filt_id ? get->filt_id : "0",
    term ? term : (get && get->filter ? get->filter : ""),
    levels,
    search_phrase ? search_phrase : "",
    autofp,
    show_closed_cves,
    notes ? 1 : 0,
    overrides ? 1 : 0,
    apply_overrides ? 1 : 0,
    result_hosts_only ? 1 : 0,
    min_cvss_base ? min_cvss_base : "");

  g_free (term);

  if (strchr (levels, 'h'))
    PRINT (out, "<filter>High</filter>");
  if (strchr (levels, 'm'))
    PRINT (out, "<filter>Medium</filter>");
  if (strchr (levels, 'l'))
    PRINT (out, "<filter>Low</filter>");
  if (strchr (levels, 'g'))
    PRINT (out, "<filter>Log</filter>");
  if (strchr (levels, 'd'))
    PRINT (out, "<filter>Debug</filter>");
  if (strchr (levels, 'f'))
    PRINT (out, "<filter>False Positive</filter>");

  if (delta)
    {
      PRINT (out,
             "<host><ip>%s</ip></host>"
             "<delta>"
             "%s"
             "<changed>%i</changed>"
             "<gone>%i</gone>"
             "<new>%i</new>"
             "<same>%i</same>"
             "</delta>",
             host ? host : "",
             delta_states,
             strchr (delta_states, 'c') != NULL,
             strchr (delta_states, 'g') != NULL,
             strchr (delta_states, 'n') != NULL,
             strchr (delta_states, 's') != NULL);
    }
  else if (type && (strcmp (type, "prognostic") == 0))
    PRINT (out,
           "<host><ip>%s</ip></host>",
           host ? host : "");

  PRINT (out, "</filters>");

  if (report)
    PRINT
     (out,
      "<scan_run_status>%s</scan_run_status>",
      run_status_name (run_status
                        ? run_status
                        : TASK_STATUS_INTERNAL_ERROR));

  if (task && tsk_uuid)
    {
      char *tsk_name, *task_target_uuid, *comment;
      target_t target;

      tsk_name = task_name (task);

      comment = task_comment (task);

      target = task_target (task);
      if (task_target_in_trash (task))
        task_target_uuid = trash_target_uuid (target);
      else
        task_target_uuid = target_uuid (target);

      PRINT (out,
             "<task id=\"%s\">"
             "<name>%s</name>"
             "<comment>%s</comment>"
             "<target id=\"%s\">"
             "<trash>%i</trash>"
             "</target>"
             "</task>",
             tsk_uuid,
             tsk_name ? tsk_name : "",
             comment ? comment : "",
             task_target_uuid ? task_target_uuid : "",
             task_target_in_trash (task));
      free (comment);
      free (tsk_name);
      free (tsk_uuid);
    }

  /** @todo Rename to "hosts" because there will be other types of assets. */
  if (type && (strcmp (type, "assets") == 0))
    {
      iterator_t hosts;

      if (host)
        {
          PRINT (out,
                 "<host_count>"
                 "<full>1</full>"
                 "<filtered>1</filtered>"
                 "</host_count>"
                 "<hosts start=\"1\" max=\"1\"/>");
        }
      else
        {
          // TODO Slow (about 30% of assets page).
          init_asset_iterator (&hosts, first_result, max_results, levels,
                               search_phrase, apply_overrides);
          PRINT (out,
                 "<host_count>"
                 "<full>%i</full>"
                 "<filtered>%i</filtered>"
                 "</host_count>",
                 host_count (),
                 // TODO Slow (about 30% of assets page).
                 filtered_host_count (levels, search_phrase, apply_overrides));
          PRINT (out,
                 "<hosts start=\"%i\" max=\"%i\"/>",
                 /* Add 1 for 1 indexing. */
                 first_result + 1,
                 max_results);
        }

      while (host || next (&hosts))
        {
          iterator_t report_hosts;
          report_host_t report_host;
          const char *ip;

          ip = host ? host : asset_iterator_ip (&hosts);

          if (host_nthlast_report_host (ip, &report_host, pos))
            {
              if (host == NULL)
                cleanup_iterator (&hosts);
              g_free (sort_field);
              g_free (levels);
              g_free (search_phrase);
              g_free (min_cvss_base);
              g_free (delta_states);
              return -1;
            }

          if (report_host)
            {
              init_host_iterator (&report_hosts, 0, NULL, report_host);
              if (next (&report_hosts))
                {
                  iterator_t details;
                  report_t report;
                  int holes, infos, logs, warnings, false_positives;
                  double highest_cvss;

                  PRINT (out,
                         "<host>"
                         "<ip>%s</ip>"
                         "<start>%s</start>"
                         "<end>%s</end>",
                         ip,
                         host_iterator_start_time (&report_hosts),
                         host_iterator_end_time (&report_hosts));

                  PRINT (out,
                         "<detail>"
                         "<name>report/@id</name>"
                         "<value>%s</value>"
                         "<source>"
                         "<type></type>"
                         "<name>openvasmd</name>"
                         "<description>UUID of current report</description>"
                         "</source>"
                         "</detail>",
                         host_iterator_report_uuid (&report_hosts));

                  PRINT (out,
                         "<detail>"
                         "<name>report_count</name>"
                         "<value>%i</value>"
                         "<source>"
                         "<type></type>"
                         "<name>openvasmd</name>"
                         "<description>Number of reports</description>"
                         "</source>"
                         "</detail>",
                         host_report_count (ip));

                  report = host_iterator_report (&report_hosts);

                  report_counts_id (report, NULL, &holes, &infos, &logs,
                                    &warnings, &false_positives,
                                    apply_overrides, ip, autofp);

                  PRINT (out,
                         "<detail>"
                         "<name>report/result_count/high</name>"
                         "<value>%i</value>"
                         "<source>"
                         "<type></type>"
                         "<name>openvasmd</name>"
                         "<description>Number of highs</description>"
                         "</source>"
                         "</detail>",
                         holes);

                  PRINT (out,
                         "<detail>"
                         "<name>report/result_count/medium</name>"
                         "<value>%i</value>"
                         "<source>"
                         "<type></type>"
                         "<name>openvasmd</name>"
                         "<description>Number of mediums</description>"
                         "</source>"
                         "</detail>",
                         warnings);

                  PRINT (out,
                         "<detail>"
                         "<name>report/result_count/low</name>"
                         "<value>%i</value>"
                         "<source>"
                         "<type></type>"
                         "<name>openvasmd</name>"
                         "<description>Number of lows</description>"
                         "</source>"
                         "</detail>",
                         infos);

                  /* Print all the host details. */

                  highest_cvss = -1;
                  init_report_host_details_iterator
                   (&details, report_host);
                  while (next (&details))
                    {
                      const char *value;
                      value = report_host_details_iterator_value (&details);

                      PRINT (out,
                             "<detail>"
                             "<name>%s</name>"
                             "<value>%s</value>"
                             "<source>"
                             "<type>%s</type>"
                             "<name>%s</name>"
                             "<description>%s</description>"
                             "</source>"
                             "</detail>",
                             report_host_details_iterator_name (&details),
                             value,
                             report_host_details_iterator_source_type (&details),
                             report_host_details_iterator_source_name (&details),
                             report_host_details_iterator_source_desc (&details));

                      if (manage_scap_loaded ()
                          && get->details
                          && (strcmp (report_host_details_iterator_name
                                       (&details),
                                      "App")
                              == 0))
                        {
                          iterator_t prognosis;
                          double cvss;
                          int first;

                          /* Print details of all CVEs on the App. */

                          first = 1;
                          cvss = -1;
                          init_prognosis_iterator (&prognosis, value);
                          while (next (&prognosis))
                            {
                              if (first)
                                {
                                  cvss = prognosis_iterator_cvss_double
                                          (&prognosis);
                                  first = 0;
                                }

                              PRINT (out,
                                     "<detail>"
                                     "<name>%s/CVE</name>"
                                     "<value>%s</value>"
                                     "</detail>"
                                     "<detail>"
                                     "<name>%s/%s/CVSS</name>"
                                     "<value>%s</value>"
                                     "</detail>",
                                     value,
                                     prognosis_iterator_cve (&prognosis),
                                     value,
                                     prognosis_iterator_cve (&prognosis),
                                     prognosis_iterator_cvss (&prognosis));
                            }

                          /* Print App prognosis, according to highest CVSS. */

                          if (cvss >= 0)
                            PRINT (out,
                                   "<detail>"
                                   "<name>%s/threat</name>"
                                   "<value>%s</value>"
                                   "</detail>",
                                   value,
                                   cvss_threat (cvss));
                          cleanup_iterator (&prognosis);
                        }

                      if (manage_scap_loaded ()
                          && (strcmp (report_host_details_iterator_name
                                       (&details),
                                      "App")
                              == 0))
                        {
                          int highest;
                          /* Check if this App's CVSS is the highest CVSS for
                           * this host. */
                          highest = cpe_highest_cvss (value);
                          if (highest > highest_cvss)
                            highest_cvss = highest;
                        }
                    }
                  cleanup_iterator (&details);

                  /* Print prognosis of host, according to highest CVSS. */

                  if (highest_cvss >= 0)
                    PRINT (out,
                           "<detail>"
                           "<name>prognosis</name>"
                           "<value>%s</value>"
                           "</detail>",
                           cvss_threat (highest_cvss));

                  PRINT (out,
                         "<detail>"
                         "<name>report/pos</name>"
                         "<value>%i</value>"
                         "<source>"
                         "<type></type>"
                         "<name>openvasmd</name>"
                         "<description>Position of report from end</description>"
                         "</source>"
                         "</detail>",
                         pos);
                }

              PRINT (out,
                     "</host>");
            }
          cleanup_iterator (&report_hosts);

          if (host)
            break;
        }
      if (host == NULL)
        cleanup_iterator (&hosts);

      PRINT (out, "</report>");

      if (fclose (out))
        {
          g_warning ("%s: fclose failed: %s\n",
                     __FUNCTION__,
                     strerror (errno));
          g_free (sort_field);
          g_free (levels);
          g_free (search_phrase);
          g_free (min_cvss_base);
          g_free (delta_states);
          return -1;
        }

      return 0;
    }

  if (type && (strcmp (type, "prognostic") == 0))
    {
      array_t *buffer;
      buffer_host_t *buffer_host;
      int index, skip;
      iterator_t hosts;

      buffer = make_array ();

      if (host == NULL)
        {
          host_levels = host_levels ? host_levels : "hmlgd";

          init_asset_iterator (&hosts, host_first_result, host_max_results,
                               host_levels, host_search_phrase, 0);
        }

      result_count = holes = warnings = infos = logs = 0;
      filtered_result_count = f_holes = f_warnings = f_infos = f_logs = 0;
      skip = 0;

      /* Output the results, buffering the associated hosts. */

      PRINT (out,
             "<results start=\"%i\" max=\"%i\">",
             /* Add 1 for 1 indexing. */
             first_result + 1,
             max_results);

      while (host || next (&hosts))
        {
          iterator_t report_hosts;
          report_host_t report_host;
          const char *ip;

          ip = host ? host : asset_iterator_ip (&hosts);

          if (host_nthlast_report_host (ip, &report_host, pos))
            {
              if (host == NULL)
                cleanup_iterator (&hosts);
              free_buffer (buffer);
              g_free (sort_field);
              g_free (levels);
              g_free (search_phrase);
              g_free (min_cvss_base);
              g_free (delta_states);
              return -1;
            }

          if (report_host)
            {
              int filtered;
              filtered = 0;
              prognostic_report_result_count (report_host, search_phrase,
                                              min_cvss_base,
                                              &filtered, &f_holes,
                                              &f_infos, &f_logs,
                                              &f_warnings);
              filtered = (strchr (levels, 'h') ? f_holes : 0)
                          + (strchr (levels, 'l') ? f_infos : 0)
                          + (strchr (levels, 'g') ? f_logs : 0)
                          + (strchr (levels, 'm') ? f_warnings : 0);
              if (filtered)
                filtered_result_count += filtered;
              else if (result_hosts_only)
                /* Skip this host. */
                report_host = 0;
            }

          if (report_host)
            {
              init_host_iterator (&report_hosts, 0, NULL, report_host);
              if (next (&report_hosts))
                {
                  iterator_t prognosis;
                  int buffered;

                  buffered = 0;

                  init_host_prognosis_iterator (&prognosis, report_host,
                                                0, -1,
                                                levels, search_phrase,
                                                min_cvss_base);
                  while (next (&prognosis))
                    {
                      const char *threat;

                      threat = cvss_threat (prognosis_iterator_cvss_double
                                             (&prognosis));

                      if (skip < first_result)
                        {
                          /* Skip result. */
                          skip++;
                          continue;
                        }

                       if (max_results == 0)
                         continue;

                       buffered = 1;

                       PRINT (out,
                              "<result>"
                              "<subnet/>"
                              "<host>%s</host>"
                              "<port>0</port>"
                              "<nvt oid=\"0\">"
                              "<name/>"
                              "</nvt>"
                              "<threat>%s</threat>"
                              "<description>"
                              "The host carries the product: %s\n"
                              "It is vulnerable according to: %s.\n"
                              "\n"
                              "%s"
                              "</description>"
                              "<cve id='%s'>"
                              "<cvss_base>%s</cvss_base>"
                              "<cpe id='%s'/>"
                              "</cve>"
                              "</result>",
                              ip,
                              threat,
                              prognosis_iterator_cpe (&prognosis),
                              prognosis_iterator_cve (&prognosis),
                              prognosis_iterator_description
                               (&prognosis),
                              prognosis_iterator_cve (&prognosis),
                              prognosis_iterator_cvss (&prognosis),
                              prognosis_iterator_cpe (&prognosis));

                       max_results--;
                     }
                   if (buffered || (result_hosts_only == 0))
                     {
                       /* Buffer IP and report_host. */
                       buffer_host_t *buffer_host;
                       buffer_host = (buffer_host_t*) g_malloc (sizeof (buffer_host_t));
                       buffer_host->report_host = report_host;
                       buffer_host->ip = g_strdup (ip);
                       array_add (buffer, buffer_host);
                     }
                  cleanup_iterator (&prognosis);
                }
              cleanup_iterator (&report_hosts);
            }

          if (host)
            break;
        }
      if (host == NULL)
        cleanup_iterator (&hosts);

      PRINT (out,
             "</results>");

      /* Output buffered hosts. */

      if (host)
        {
          PRINT (out,
                 "<host_count>"
                 "<full>1</full>"
                 "<filtered>1</filtered>"
                 "</host_count>"
                 "<hosts start=\"1\" max=\"1\"/>");
        }
      else
        {
          PRINT (out,
                 "<host_count>"
                 "<full>%i</full>"
                 "<filtered>%i</filtered>"
                 "</host_count>",
                 host_count (),
                 buffer->len);
          PRINT (out,
                 "<hosts start=\"%i\" max=\"%i\"/>",
                 /* Add 1 for 1 indexing. */
                 host_first_result + 1,
                 host_max_results);
        }

      array_terminate (buffer);
      index = 0;
      while ((buffer_host = g_ptr_array_index (buffer, index++)))
        {
          iterator_t report_hosts;
          init_host_iterator (&report_hosts, 0, NULL, buffer_host->report_host);
          if (next (&report_hosts))
            {
              iterator_t details;
              report_t report;
              int h_holes, h_infos, h_logs, h_warnings, h_false_positives;

              PRINT (out,
                     "<host>"
                     "<ip>%s</ip>"
                     "<start>%s</start>"
                     "<end>%s</end>",
                     buffer_host->ip,
                     host_iterator_start_time (&report_hosts),
                     host_iterator_end_time (&report_hosts));

              PRINT (out,
                     "<detail>"
                     "<name>report/@id</name>"
                     "<value>%s</value>"
                     "<source>"
                     "<type></type>"
                     "<name>openvasmd</name>"
                     "<description>UUID of current report</description>"
                     "</source>"
                     "</detail>",
                     host_iterator_report_uuid (&report_hosts));

              PRINT (out,
                     "<detail>"
                     "<name>report_count</name>"
                     "<value>%i</value>"
                     "<source>"
                     "<type></type>"
                     "<name>openvasmd</name>"
                     "<description>Number of reports</description>"
                     "</source>"
                     "</detail>",
                     host_report_count (buffer_host->ip));

              report = host_iterator_report (&report_hosts);

              report_counts_id (report, NULL, &h_holes, &h_infos, &h_logs,
                                &h_warnings, &h_false_positives, 0,
                                buffer_host->ip, 0);

              PRINT (out,
                     "<detail>"
                     "<name>report/result_count/high</name>"
                     "<value>%i</value>"
                     "<source>"
                     "<type></type>"
                     "<name>openvasmd</name>"
                     "<description>Number of highs</description>"
                     "</source>"
                     "</detail>",
                     h_holes);

              PRINT (out,
                     "<detail>"
                     "<name>report/result_count/medium</name>"
                     "<value>%i</value>"
                     "<source>"
                     "<type></type>"
                     "<name>openvasmd</name>"
                     "<description>Number of mediums</description>"
                     "</source>"
                     "</detail>",
                     h_warnings);

              PRINT (out,
                     "<detail>"
                     "<name>report/result_count/low</name>"
                     "<value>%i</value>"
                     "<source>"
                     "<type></type>"
                     "<name>openvasmd</name>"
                     "<description>Number of lows</description>"
                     "</source>"
                     "</detail>",
                     h_infos);

              init_report_host_details_iterator
               (&details, buffer_host->report_host);
              while (next (&details))
                PRINT (out,
                       "<detail>"
                       "<name>%s</name>"
                       "<value>%s</value>"
                       "<source>"
                       "<type>%s</type>"
                       "<name>%s</name>"
                       "<description>%s</description>"
                       "</source>"
                       "</detail>",
                       report_host_details_iterator_name (&details),
                       report_host_details_iterator_value (&details),
                       report_host_details_iterator_source_type (&details),
                       report_host_details_iterator_source_name (&details),
                       report_host_details_iterator_source_desc (&details));
              cleanup_iterator (&details);

              PRINT (out,
                     "<detail>"
                     "<name>report/pos</name>"
                     "<value>%i</value>"
                     "<source>"
                     "<type></type>"
                     "<name>openvasmd</name>"
                     "<description>Position of report from end</description>"
                     "</source>"
                     "</detail>",
                     pos);

              PRINT (out,
                     "</host>");
            }
        }

      free_buffer (buffer);

      PRINT (out,
             "<result_count>"
             "%i"
             "<full>%i</full>"
             "<filtered>%i</filtered>"
             "<debug><full>0</full><filtered>0</filtered></debug>"
             "<hole><full>%i</full><filtered>%i</filtered></hole>"
             "<info><full>%i</full><filtered>%i</filtered></info>"
             "<log><full>%i</full><filtered>%i</filtered></log>"
             "<warning><full>%i</full><filtered>%i</filtered></warning>"
             "<false_positive>"
             "<full>0</full>"
             "<filtered>0</filtered>"
             "</false_positive>"
             "</result_count>",
             result_count,
             result_count,
             (strchr (levels, 'h') ? f_holes : 0)
              + (strchr (levels, 'l') ? f_infos : 0)
              + (strchr (levels, 'g') ? f_logs : 0)
              + (strchr (levels, 'm') ? f_warnings : 0),
             holes,
             (strchr (levels, 'h') ? f_holes : 0),
             infos,
             (strchr (levels, 'l') ? f_infos : 0),
             logs,
             (strchr (levels, 'g') ? f_logs : 0),
             warnings,
             (strchr (levels, 'm') ? f_warnings : 0));

      PRINT (out, "</report>");

      g_free (sort_field);
      g_free (levels);
      g_free (search_phrase);
      g_free (min_cvss_base);
      g_free (delta_states);

      if (fclose (out))
        {
          g_warning ("%s: fclose failed: %s\n",
                     __FUNCTION__,
                     strerror (errno));
          return -1;
        }

      return 0;
    }

  start_time = scan_start_time (report);
  PRINT (out,
         "<scan_start>%s</scan_start>",
         start_time);
  free (start_time);

  /* Port summary. */

  if (delta == 0)
    {
      gchar *last_port, *last_host;
      GArray *ports = g_array_new (TRUE, FALSE, sizeof (gchar*));

      init_result_iterator
       (&results, report, 0,
        first_result,
        max_results,
        /* Sort by the requested field in the requested order, in case there is
         * a first_result and/or max_results (these are applied after the
         * sorting). */
        sort_order,
        sort_field,
        levels,
        autofp,
        search_phrase,
        search_phrase_exact,
        min_cvss_base,
        apply_overrides);

      /* Buffer the results, removing duplicates. */

      last_port = NULL;
      last_host = NULL;
      while (next (&results))
        {
          const char *port = result_iterator_port (&results);
          const char *host = result_iterator_host (&results);

          if (last_port == NULL || strcmp (port, last_port)
              || strcmp (host, last_host))
            {
              const char *type;
              gchar *item;
              int port_len, type_len;

              g_free (last_port);
              last_port = g_strdup (port);
              g_free (last_host);
              last_host = g_strdup (host);

              type = result_iterator_type (&results);
              port_len = strlen (port);
              type_len = strlen (type);
              item = g_malloc (port_len
                                + type_len
                                + strlen (host)
                                + 3);
              g_array_append_val (ports, item);
              strcpy (item, port);
              strcpy (item + port_len + 1, type);
              strcpy (item + port_len + type_len + 2, host);
            }

        }
      g_free (last_port);
      g_free (last_host);

      /* Handle sorting by threat and ROWID. */

      if (sort_field == NULL || strcmp (sort_field, "port"))
        {
          int index, length;

          /** @todo Sort by ROWID if was requested. */

          /* Sort by port then threat. */

          g_array_sort (ports, compare_port_threat);

          /* Remove duplicates. */

          last_port = NULL;
          last_host = NULL;
          for (index = 0, length = ports->len; index < length; index++)
            {
              char *port = g_array_index (ports, char*, index);
              char *host = port + strlen (port) + 1;
              host += strlen (host) + 1;
              if (last_port
                  && (strcmp (port, last_port) == 0)
                  && (strcmp (host, last_host) == 0))
                {
                  g_array_remove_index (ports, index);
                  length = ports->len;
                  index--;
                }
              else
                {
                  last_port = port;
                  last_host = host;
                }
            }

          /* Sort by threat. */

          if (sort_order)
            g_array_sort (ports, compare_message_types_asc);
          else
            g_array_sort (ports, compare_message_types_desc);
        }

      /* Write to file from the buffer. */

      PRINT (out,
               "<ports"
               " start=\"%i\""
               " max=\"%i\">",
               /* Add 1 for 1 indexing. */
               first_result + 1,
               max_results);
      {
        gchar *item;
        int index = 0;

        while ((item = g_array_index (ports, gchar*, index++)))
          {
            int port_len = strlen (item);
            int type_len = strlen (item + port_len + 1);
            PRINT (out,
                     "<port>"
                     "<host>%s</host>"
                     "%s"
                     "<threat>%s</threat>"
                     "</port>",
                     item + port_len + type_len + 2,
                     item,
                     manage_result_type_threat (item + port_len + 1));
            g_free (item);
          }
        g_array_free (ports, TRUE);
      }
      PRINT (out, "</ports>");
      cleanup_iterator (&results);
    }

  /* Prepare result counts. */

  report_counts_id_filt (report, &debugs, &holes, &infos, &logs,
                         &warnings, &false_positives,
                         apply_overrides, NULL, min_cvss_base, search_phrase,
                         search_phrase_exact, autofp, &f_debugs, &f_holes,
                         &f_infos, &f_logs, &f_warnings, &f_false_positives);

  /* Results. */

  if (delta)
    {
      init_result_iterator (&results, report, 0,
                            0,
                            -1,
                            sort_order,
                            sort_field,
                            levels,
                            autofp,
                            search_phrase,
                            search_phrase_exact,
                            min_cvss_base,
                            apply_overrides);

      init_result_iterator (&delta_results, delta, 0,
                            0,
                            -1,
                            sort_order,
                            sort_field,
                            levels,
                            autofp,
                            search_phrase,
                            search_phrase_exact,
                            min_cvss_base,
                            apply_overrides);
    }
  else
    init_result_iterator (&results, report, 0,
                          first_result,
                          max_results,
                          sort_order,
                          sort_field,
                          levels,
                          autofp,
                          search_phrase,
                          search_phrase_exact,
                          min_cvss_base,
                          apply_overrides);

  PRINT (out,
           "<results"
           " start=\"%i\""
           " max=\"%i\">",
           /* Add 1 for 1 indexing. */
           first_result + 1,
           max_results);
  if (result_hosts_only)
    result_hosts = make_array ();
  else
    /* Quiet erroneous compiler warning. */
    result_hosts = NULL;
  if (delta)
    {
      gboolean done, delta_done;
      int changed, gone, new, same;
      /* A tree of host, tree pairs, where the inner tree is a sorted tree
       * of port, threat pairs. */
      GTree *ports;

      orig_f_debugs = f_debugs;
      orig_f_holes = f_holes;
      orig_f_infos = f_infos;
      orig_f_logs = f_logs;
      orig_f_warnings = f_warnings;
      orig_f_false_positives = f_false_positives;
      orig_filtered_result_count = filtered_result_count;

      changed = (strchr (delta_states, 'c') != NULL);
      gone = (strchr (delta_states, 'g') != NULL);
      new = (strchr (delta_states, 'n') != NULL);
      same = (strchr (delta_states, 's') != NULL);

      ports = g_tree_new_full ((GCompareDataFunc) strcmp, NULL, g_free,
                               (GDestroyNotify) free_host_ports);

      /* Compare the results in the two iterators, which are sorted. */

      tracef ("   delta: %s: start", __FUNCTION__);
      done = !next (&results);
      delta_done = !next (&delta_results);
      while (1)
        {
          GString *buffer;
          compare_results_t state;
          int used, would_use;

          if (max_results == 0)
            break;

          if (done)
            {
              if (delta_done)
                break;
              if (new)
                /* Extra results in 'delta_results'. */
                do
                  {
                    const char *type;

                    tracef ("   delta: %s: extra from report 2: %s",
                            __FUNCTION__,
                            result_iterator_nvt_oid (&results));

                    if (first_result)
                      {
                        tracef ("   delta: skip");
                        first_result--;
                        continue;
                      }

                    /* Increase the result count. */
                    type = result_iterator_type (&delta_results);
                    orig_filtered_result_count++;
                    filtered_result_count++;
                    if (strcmp (type, "Security Hole") == 0)
                      {
                        orig_f_holes++;
                        f_holes++;
                      }
                    else if (strcmp (type, "Security Warning") == 0)
                      {
                        orig_f_warnings++;
                        f_warnings++;
                      }
                    else if (strcmp (type, "Security Note") == 0)
                      {
                        orig_f_infos++;
                        f_infos++;
                      }
                    else if (strcmp (type, "Log Message") == 0)
                      {
                        orig_f_logs++;
                        f_logs++;
                      }
                    else if (strcmp (type, "False Positive") == 0)
                      {
                        orig_f_false_positives++;
                        f_false_positives++;
                      }

                    tracef ("   delta: %s: extra from report 2: %s",
                            __FUNCTION__,
                            result_iterator_nvt_oid (&delta_results));
                    buffer = g_string_new ("");
                    buffer_results_xml (buffer,
                                        &delta_results,
                                        task,
                                        notes,
                                        notes_details,
                                        overrides,
                                        overrides_details,
                                        "new",
                                        NULL,
                                        0);
                    PRINT_XML (out, buffer->str);
                    g_string_free (buffer, TRUE);
                    if (result_hosts_only)
                      array_add_new_string (result_hosts,
                                            result_iterator_host (&delta_results));
                    add_port (ports, &delta_results);
                    max_results--;
                    if (max_results == 0)
                      break;
                  }
                while (next (&delta_results));
              delta_done = TRUE;
              break;
            }

          if (delta_done)
            {
              /* Extra results in 'results'. */
              if (gone)
                do
                  {
                    tracef ("   delta: %s: extra from report 1: %s",
                            __FUNCTION__,
                            result_iterator_nvt_oid (&results));
                    if (first_result)
                      {
                        tracef ("   delta: skip");
                        first_result--;
                        continue;
                      }
                    buffer = g_string_new ("");
                    buffer_results_xml (buffer,
                                        &results,
                                        task,
                                        notes,
                                        notes_details,
                                        overrides,
                                        overrides_details,
                                        "gone",
                                        NULL,
                                        0);
                    PRINT_XML (out, buffer->str);
                    g_string_free (buffer, TRUE);
                    if (result_hosts_only)
                      array_add_new_string (result_hosts,
                                            result_iterator_host (&results));
                    add_port (ports, &results);
                    max_results--;
                    if (max_results == 0)
                      break;
                  }
                while (next (&results));
              else
                do
                  {
                    const char *type;

                    /* Decrease the result count. */
                    type = result_iterator_type (&results);
                    orig_filtered_result_count--;
                    filtered_result_count--;
                    if (strcmp (type, "Security Hole") == 0)
                      {
                        orig_f_holes--;
                        f_holes--;
                      }
                    else if (strcmp (type, "Security Warning") == 0)
                      {
                        orig_f_warnings--;
                        f_warnings--;
                      }
                    else if (strcmp (type, "Security Note") == 0)
                      {
                        orig_f_infos--;
                        f_infos--;
                      }
                    else if (strcmp (type, "Log Message") == 0)
                      {
                        orig_f_logs--;
                        f_logs--;
                      }
                    else if (strcmp (type, "False Positive") == 0)
                      {
                        orig_f_false_positives--;
                        f_false_positives--;
                      }
                  }
                while (next (&results));
              done = TRUE;
              break;
            }

          /* Compare the two results. */

          buffer = g_string_new ("");
          state = compare_and_buffer_results (buffer,
                                              &results,
                                              &delta_results,
                                              task,
                                              notes,
                                              notes_details,
                                              overrides,
                                              overrides_details,
                                              sort_order,
                                              sort_field,
                                              changed,
                                              gone,
                                              new,
                                              same,
                                              &max_results,
                                              &first_result,
                                              &used,
                                              &would_use);
          if (state == COMPARE_RESULTS_ERROR)
            {
              g_warning ("%s: compare_and_buffer_results failed\n",
                         __FUNCTION__);
              g_free (sort_field);
              g_free (levels);
              g_free (search_phrase);
              g_free (min_cvss_base);
              g_free (delta_states);
              return -1;
            }
          PRINT_XML (out, buffer->str);
          g_string_free (buffer, TRUE);

          if ((used == 0)
              && ((state == COMPARE_RESULTS_GONE)
                  || (state == COMPARE_RESULTS_SAME)
                  || (state == COMPARE_RESULTS_CHANGED)))
            {
              const char *type;

              /* Decrease the result count. */
              type = result_iterator_type (&results);
              filtered_result_count--;
              if (strcmp (type, "Security Hole") == 0)
                {
                  f_holes--;
                }
              else if (strcmp (type, "Security Warning") == 0)
                {
                  f_warnings--;
                }
              else if (strcmp (type, "Security Note") == 0)
                {
                  f_infos--;
                }
              else if (strcmp (type, "Log Message") == 0)
                {
                  f_logs--;
                }
              else if (strcmp (type, "False Positive") == 0)
                {
                  f_false_positives--;
                }
            }

          if ((would_use == 0)
              && ((state == COMPARE_RESULTS_GONE)
                  || (state == COMPARE_RESULTS_SAME)
                  || (state == COMPARE_RESULTS_CHANGED)))
            {
              const char *type;

              /* Decrease the result count. */
              type = result_iterator_type (&results);
              orig_filtered_result_count--;
              if (strcmp (type, "Security Hole") == 0)
                {
                  orig_f_holes--;
                }
              else if (strcmp (type, "Security Warning") == 0)
                {
                  orig_f_warnings--;
                }
              else if (strcmp (type, "Security Note") == 0)
                {
                  orig_f_infos--;
                }
              else if (strcmp (type, "Log Message") == 0)
                {
                  orig_f_logs--;
                }
              else if (strcmp (type, "False Positive") == 0)
                {
                  orig_f_false_positives--;
                }
            }

          /* Move on to the next. */

          if (state == COMPARE_RESULTS_GONE)
            {
              /* "Used" just the 'results' result. */
              if (used)
                {
                  if (result_hosts_only)
                    array_add_new_string (result_hosts,
                                          result_iterator_host (&results));
                  add_port (ports, &results);
                }
              done = !next (&results);
            }
          else if ((state == COMPARE_RESULTS_SAME)
                   || (state == COMPARE_RESULTS_CHANGED))
            {
              /* "Used" both results. */
              if (used)
                {
                  if (result_hosts_only)
                    array_add_new_string (result_hosts,
                                          result_iterator_host (&results));
                  add_port (ports, &results);
                }
              done = !next (&results);
              delta_done = !next (&delta_results);
            }
          else if (state == COMPARE_RESULTS_NEW)
            {
              if (would_use)
                {
                  const char *type;

                  /* Would have "used" just the 'delta_results' result, on
                   * an earlier page. */

                  /* Increase the result count. */
                  type = result_iterator_type (&delta_results);
                  orig_filtered_result_count++;
                  if (strcmp (type, "Security Hole") == 0)
                    {
                      orig_f_holes++;
                    }
                  else if (strcmp (type, "Security Warning") == 0)
                    {
                      orig_f_warnings++;
                    }
                  else if (strcmp (type, "Security Note") == 0)
                    {
                      orig_f_infos++;
                    }
                  else if (strcmp (type, "Log Message") == 0)
                    {
                      orig_f_logs++;
                    }
                  else if (strcmp (type, "False Positive") == 0)
                    {
                      orig_f_false_positives++;
                    }
                }

              if (used)
                {
                  const char *type;

                  /* "Used" just the 'delta_results' result. */

                  /* Increase the result count. */
                  type = result_iterator_type (&delta_results);
                  filtered_result_count++;
                  if (strcmp (type, "Security Hole") == 0)
                    {
                      f_holes++;
                    }
                  else if (strcmp (type, "Security Warning") == 0)
                    {
                      f_warnings++;
                    }
                  else if (strcmp (type, "Security Note") == 0)
                    {
                      f_infos++;
                    }
                  else if (strcmp (type, "Log Message") == 0)
                    {
                      f_logs++;
                    }
                  else if (strcmp (type, "False Positive") == 0)
                    {
                      f_false_positives++;
                    }

                  if (result_hosts_only)
                    array_add_new_string (result_hosts,
                                          result_iterator_host
                                           (&delta_results));

                  add_port (ports, &delta_results);
                }
              delta_done = !next (&delta_results);
            }
          else
            assert (0);
        }

      /* Compare remaining results, for the filtered report counts. */

      tracef ("   delta: %s: counting rest", __FUNCTION__);
      while (1)
        {
          compare_results_t state;
          int used, would_use;

          if (done)
            {
              if (delta_done)
                break;
              if (new)
                /* Extra results in 'delta_results'. */
                do
                  {
                    const char *type;

                    tracef ("   delta: %s: extra from report 2: %s",
                            __FUNCTION__,
                            result_iterator_nvt_oid (&delta_results));

                    /* Increase the result count. */
                    type = result_iterator_type (&delta_results);
                    orig_filtered_result_count++;
                    if (strcmp (type, "Security Hole") == 0)
                      {
                        orig_f_holes++;
                      }
                    else if (strcmp (type, "Security Warning") == 0)
                      {
                        orig_f_warnings++;
                      }
                    else if (strcmp (type, "Security Note") == 0)
                      {
                        orig_f_infos++;
                      }
                    else if (strcmp (type, "Log Message") == 0)
                      {
                        orig_f_logs++;
                      }
                    else if (strcmp (type, "False Positive") == 0)
                      {
                        orig_f_false_positives++;
                      }
                  }
                while (next (&delta_results));
              break;
            }

          if (delta_done)
            {
              /* Extra results in 'results'. */
              if (gone)
                do
                  {
                    tracef ("   delta: %s: extra from report 1: %s",
                            __FUNCTION__,
                            result_iterator_nvt_oid (&results));

                    /* It's in the count already. */
                  }
                while (next (&results));
              else
                do
                  {
                    const char *type;

                    /* Decrease the result count. */
                    type = result_iterator_type (&results);
                    orig_filtered_result_count--;
                    if (strcmp (type, "Security Hole") == 0)
                      {
                        orig_f_holes--;
                      }
                    else if (strcmp (type, "Security Warning") == 0)
                      {
                        orig_f_warnings--;
                      }
                    else if (strcmp (type, "Security Note") == 0)
                      {
                        orig_f_infos--;
                      }
                    else if (strcmp (type, "Log Message") == 0)
                      {
                        orig_f_logs--;
                      }
                    else if (strcmp (type, "False Positive") == 0)
                      {
                        orig_f_false_positives--;
                      }
                  }
                while (next (&results));
              break;
            }

          /* Compare the two results. */

          state = compare_and_buffer_results (NULL,
                                              &results,
                                              &delta_results,
                                              task,
                                              notes,
                                              notes_details,
                                              overrides,
                                              overrides_details,
                                              sort_order,
                                              sort_field,
                                              changed,
                                              gone,
                                              new,
                                              same,
                                              &max_results,
                                              &first_result,
                                              &used,
                                              &would_use);
          if (state == COMPARE_RESULTS_ERROR)
            {
              g_warning ("%s: compare_and_buffer_results failed\n",
                         __FUNCTION__);
              g_free (sort_field);
              g_free (levels);
              g_free (search_phrase);
              g_free (min_cvss_base);
              g_free (delta_states);
              return -1;
            }

          if (state == COMPARE_RESULTS_NEW)
            {
              if (used)
                {
                  const char *type;

                  /* "Used" just the 'delta_results' result. */

                  /* Increase the result count. */
                  type = result_iterator_type (&delta_results);
                  orig_filtered_result_count++;
                  if (strcmp (type, "Security Hole") == 0)
                    {
                      orig_f_holes++;
                    }
                  else if (strcmp (type, "Security Warning") == 0)
                    {
                      orig_f_warnings++;
                    }
                  else if (strcmp (type, "Security Note") == 0)
                    {
                      orig_f_infos++;
                    }
                  else if (strcmp (type, "Log Message") == 0)
                    {
                      orig_f_logs++;
                    }
                  else if (strcmp (type, "False Positive") == 0)
                    {
                      orig_f_false_positives++;
                    }
                }
            }
          else if (used)
            {
              /* It's in the count already. */
            }
          else
            {
              const char *type;

              /* Decrease the result count. */
              type = result_iterator_type (&results);
              orig_filtered_result_count--;
              if (strcmp (type, "Security Hole") == 0)
                {
                  orig_f_holes--;
                }
              else if (strcmp (type, "Security Warning") == 0)
                {
                  orig_f_warnings--;
                }
              else if (strcmp (type, "Security Note") == 0)
                {
                  orig_f_infos--;
                }
              else if (strcmp (type, "Log Message") == 0)
                {
                  orig_f_logs--;
                }
              else if (strcmp (type, "False Positive") == 0)
                {
                  orig_f_false_positives--;
                }
            }

          /* Move on to the next. */

          if (state == COMPARE_RESULTS_GONE)
            {
              /* "Used" just the 'results' result. */
              done = !next (&results);
            }
          else if ((state == COMPARE_RESULTS_SAME)
                   || (state == COMPARE_RESULTS_CHANGED))
            {
              /* "Used" both results. */
              done = !next (&results);
              delta_done = !next (&delta_results);
            }
          else if (state == COMPARE_RESULTS_NEW)
            {
              /* "Used" just the 'delta_results' result. */
              delta_done = !next (&delta_results);
            }
          else
            assert (0);
        }
      PRINT (out, "</results>");

      /* Write ports to file. */

      PRINT (out,
               "<ports"
               " start=\"%i\""
               " max=\"%i\">",
               /* Add 1 for 1 indexing. */
               first_result + 1,
               max_results);
      if (sort_field == NULL || strcmp (sort_field, "port"))
        {
          if (sort_order)
            g_tree_foreach (ports, print_host_ports_by_type_asc, out);
          else
            g_tree_foreach (ports, print_host_ports_by_type_desc, out);
        }
      else if (sort_order)
        g_tree_foreach (ports, print_host_ports, out);
      else
        g_tree_foreach (ports, print_host_ports_desc, out);
      g_tree_destroy (ports);
      PRINT (out, "</ports>");
    }
  else
    {
      while (next (&results))
        {
          GString *buffer = g_string_new ("");
          buffer_results_xml (buffer,
                              &results,
                              task,
                              notes,
                              notes_details,
                              overrides,
                              overrides_details,
                              NULL,
                              NULL,
                              0);
          PRINT_XML (out, buffer->str);
          g_string_free (buffer, TRUE);
          if (result_hosts_only)
            array_add_new_string (result_hosts,
                                  result_iterator_host (&results));
        }
      PRINT (out, "</results>");
    }
  cleanup_iterator (&results);

  /* Print result counts. */

  if (delta)
    /** @todo The f_debugs, etc. vars are setup to give the page count. */
    PRINT (out,
             "<result_count>"
             "<filtered>%i</filtered>"
             "<debug><filtered>%i</filtered></debug>"
             "<hole><filtered>%i</filtered></hole>"
             "<info><filtered>%i</filtered></info>"
             "<log><filtered>%i</filtered></log>"
             "<warning><filtered>%i</filtered></warning>"
             "<false_positive>"
             "<filtered>%i</filtered>"
             "</false_positive>"
             "</result_count>",
             orig_filtered_result_count,
             (strchr (levels, 'd') ? orig_f_debugs : 0),
             (strchr (levels, 'h') ? orig_f_holes : 0),
             (strchr (levels, 'l') ? orig_f_infos : 0),
             (strchr (levels, 'g') ? orig_f_logs : 0),
             (strchr (levels, 'm') ? orig_f_warnings : 0),
             (strchr (levels, 'f') ? orig_f_false_positives : 0));
  else
    PRINT (out,
             "<result_count>"
             "%i"
             "<full>%i</full>"
             "<filtered>%i</filtered>"
             "<debug><full>%i</full><filtered>%i</filtered></debug>"
             "<hole><full>%i</full><filtered>%i</filtered></hole>"
             "<info><full>%i</full><filtered>%i</filtered></info>"
             "<log><full>%i</full><filtered>%i</filtered></log>"
             "<warning><full>%i</full><filtered>%i</filtered></warning>"
             "<false_positive>"
             "<full>%i</full>"
             "<filtered>%i</filtered>"
             "</false_positive>"
             "</result_count>",
             result_count,
             result_count,
             filtered_result_count,
             debugs,
             (strchr (levels, 'd') ? f_debugs : 0),
             holes,
             (strchr (levels, 'h') ? f_holes : 0),
             infos,
             (strchr (levels, 'l') ? f_infos : 0),
             logs,
             (strchr (levels, 'g') ? f_logs : 0),
             warnings,
             (strchr (levels, 'm') ? f_warnings : 0),
             false_positives,
             (strchr (levels, 'f') ? f_false_positives : 0));

  if (result_hosts_only)
    {
      gchar *host;
      int index = 0;
      array_terminate (result_hosts);
      while ((host = g_ptr_array_index (result_hosts, index++)))
        {
          gboolean present;
          iterator_t hosts;
          init_host_iterator (&hosts, report, host, 0);
          present = next (&hosts);
          if (delta && (present == FALSE))
            {
              cleanup_iterator (&hosts);
              init_host_iterator (&hosts, delta, host, 0);
              present = next (&hosts);
            }
          if (present)
            {
              iterator_t details;
              guint index;
              array_t *cves;

              cves = make_array ();

              PRINT (out,
                     "<host>"
                     "<ip>%s</ip>"
                     "<start>%s</start>"
                     "<end>%s</end>",
                     host,
                     host_iterator_start_time (&hosts),
                     host_iterator_end_time (&hosts)
                       ? host_iterator_end_time (&hosts)
                       : "");

              init_report_host_details_iterator
               (&details, host_iterator_report_host (&hosts));
              while (next (&details))
                {
                  buffer_cve (cves, &details);

                  PRINT (out,
                         "<detail>"
                         "<name>%s</name>"
                         "<value>%s</value>"
                         "<source>"
                         "<type>%s</type>"
                         "<name>%s</name>"
                         "<description>%s</description>"
                         "</source>"
                         "</detail>",
                         report_host_details_iterator_name (&details),
                         report_host_details_iterator_value (&details),
                         report_host_details_iterator_source_type (&details),
                         report_host_details_iterator_source_name (&details),
                         report_host_details_iterator_source_desc (&details));
                }
              cleanup_iterator (&details);

              if (show_closed_cves && cves->len > 0)
                {
                  GString *detail_cves;

                  /* Combine all buffered CVEs into one host detail. */

                  g_ptr_array_sort (cves, compare_strings);

                  detail_cves = g_string_new ((gchar*) g_ptr_array_index (cves,
                                                                          0));
                  for (index = 1; index < cves->len; index++)
                    g_string_append_printf
                     (detail_cves,
                      ", %s",
                      (gchar*) g_ptr_array_index (cves, index));
                  PRINT (out,
                         "<detail>"
                         "<name>Closed CVEs</name>"
                         "<value>%s</value>"
                         "<source>"
                         "<type>openvasmd</type>"
                         "<name></name>"
                         "<description></description>"
                         "</source>"
                         "</detail>",
                         detail_cves->str);
                  g_string_free (detail_cves, TRUE);
                }
              array_free (cves);

              PRINT (out,
                     "</host>");

              PRINT (out,
                       "<host_start>"
                       "<host>%s</host>%s"
                       "</host_start>",
                       host,
                       host_iterator_start_time (&hosts));
              PRINT (out,
                       "<host_end>"
                       "<host>%s</host>%s"
                       "</host_end>",
                       host,
                       host_iterator_end_time (&hosts)
                         ? host_iterator_end_time (&hosts)
                         : "");
            }
          cleanup_iterator (&hosts);
        }
      array_free (result_hosts);
    }
  else
    {
      iterator_t hosts;
      init_host_iterator (&hosts, report, NULL, 0);
      while (next (&hosts))
        {
          iterator_t details;
          guint index;
          array_t *cves;

          cves = make_array ();

          PRINT (out,
                 "<host>"
                 "<ip>%s</ip>"
                 "<start>%s</start>"
                 "<end>%s</end>",
                 host_iterator_host (&hosts),
                 host_iterator_start_time (&hosts),
                 host_iterator_end_time (&hosts)
                   ? host_iterator_end_time (&hosts)
                   : "");

          init_report_host_details_iterator
           (&details, host_iterator_report_host (&hosts));
          while (next (&details))
            {
              buffer_cve (cves, &details);

              PRINT (out,
                     "<detail>"
                     "<name>%s</name>"
                     "<value>%s</value>"
                     "<source>"
                     "<type>%s</type>"
                     "<name>%s</name>"
                     "<description>%s</description>"
                     "</source>"
                     "</detail>",
                     report_host_details_iterator_name (&details),
                     report_host_details_iterator_value (&details),
                     report_host_details_iterator_source_type (&details),
                     report_host_details_iterator_source_name (&details),
                     report_host_details_iterator_source_desc (&details));
            }
          cleanup_iterator (&details);

          if (show_closed_cves && cves->len > 0)
            {
              GString *detail_cves;

              /* Combine all buffered CVEs into one host detail. */

              g_ptr_array_sort (cves, compare_strings);

              detail_cves = g_string_new ((gchar*) g_ptr_array_index (cves,
                                                                      0));
              for (index = 1; index < cves->len; index++)
                g_string_append_printf
                 (detail_cves,
                  ", %s",
                  (gchar*) g_ptr_array_index (cves, index));
              PRINT (out,
                     "<detail>"
                     "<name>Closed CVEs</name>"
                     "<value>%s</value>"
                     "<source>"
                     "<type>openvasmd</type>"
                     "<name></name>"
                     "<description></description>"
                     "</source>"
                     "</detail>",
                     detail_cves->str);
              g_string_free (detail_cves, TRUE);
            }
          array_free (cves);

          PRINT (out,
                 "</host>");

          PRINT (out,
                 "<host_start><host>%s</host>%s</host_start>",
                 host_iterator_host (&hosts),
                 host_iterator_start_time (&hosts));
        }
      cleanup_iterator (&hosts);

      init_host_iterator (&hosts, report, NULL, 0);
      while (next (&hosts))
        PRINT (out,
                 "<host_end><host>%s</host>%s</host_end>",
                 host_iterator_host (&hosts),
                 host_iterator_end_time (&hosts)
                  ? host_iterator_end_time (&hosts)
                  : "");
      cleanup_iterator (&hosts);
    }
  end_time = scan_end_time (report);
  PRINT (out,
           "<scan_end>%s</scan_end>",
           end_time);
  free (end_time);

  PRINT (out, "</report>");

  g_free (sort_field);
  g_free (levels);
  g_free (search_phrase);
  g_free (min_cvss_base);
  g_free (delta_states);

  if (fclose (out))
    {
      g_warning ("%s: fclose failed: %s\n",
                 __FUNCTION__,
                 strerror (errno));
      return -1;
    }

  return 0;
}

/**
 * @brief Generate a report.
 *
 * @param[in]  report             Report.
 * @param[in]  report_format      Report format.
 * @param[in]  filt_id            ID of filter or NULL, overrides other args.
 * @param[in]  sort_order         Whether to sort ascending or descending.
 * @param[in]  sort_field         Field to sort on, or NULL for "type".
 * @param[in]  result_hosts_only  Whether to show only hosts with results.
 * @param[in]  min_cvss_base      Minimum CVSS base of included results.  All
 *                                results if NULL.
 * @param[in]  levels         String describing threat levels (message types)
 *                            to include in count (for example, "hmlgd" for
 *                            High, Medium, Low, loG and Debug).  All levels if
 *                            NULL.
 * @param[in]  apply_overrides    Whether to apply overrides.
 * @param[in]  search_phrase      Phrase that results must include.  All results
 *                                if NULL or "".
 * @param[in]  autofp             Whether to apply auto FP filter.
 * @param[in]  show_closed_cves   Whether to include the Closed CVEs host detail.
 * @param[in]  notes              Whether to include notes.
 * @param[in]  notes_details      If notes, Whether to include details.
 * @param[in]  overrides          Whether to include overrides.
 * @param[in]  overrides_details  If overrides, Whether to include details.
 * @param[in]  first_result       The result to start from.  The results are 0
 *                                indexed.
 * @param[in]  max_results        The maximum number of results returned.
 * @param[in]  type               Type of report: NULL or "scan".
 * @param[out] output_length      NULL or location for length of return.
 * @param[out] extension          NULL or location for report format extension.
 * @param[out] content_type       NULL or location for report format content
 *                                type.
 *
 * @return Contents of report on success, NULL on error.
 */
gchar *
manage_report (report_t report, report_format_t report_format,
               const char *filt_id, int sort_order,
               const char* sort_field, int result_hosts_only,
               const char *min_cvss_base, const char *levels,
               int apply_overrides, const char *search_phrase, int autofp,
               int show_closed_cves, int notes, int notes_details,
               int overrides, int overrides_details, int first_result,
               int max_results, const char *type, gsize *output_length,
               gchar **extension, gchar **content_type)
{
  task_t task;
  gchar *xml_file;
  char xml_dir[] = "/tmp/openvasmd_XXXXXX";
  int ret;
  get_data_t get;

  memset (&get, 0, sizeof (get));

  if (type && strcmp (type, "scan"))
    return NULL;

  /* Print the report as XML to a file. */

  if (((report_format_predefined (report_format) == 0)
       && (report_format_trust (report_format) != TRUST_YES))
      || (report_task (report, &task)))
    {
      return NULL;
    }

  if (mkdtemp (xml_dir) == NULL)
    {
      g_warning ("%s: mkdtemp failed\n", __FUNCTION__);
      return NULL;
    }

  xml_file = g_strdup_printf ("%s/report.xml", xml_dir);
  get.filt_id = filt_id ? g_strdup (filt_id) : NULL;
  ret = print_report_xml (report, 0, task, xml_file, &get,
                          sort_order, sort_field,
                          result_hosts_only, min_cvss_base, report_format,
                          levels, NULL, apply_overrides, search_phrase, autofp,
                          show_closed_cves, notes, notes_details, overrides,
                          overrides_details, first_result, max_results, type,
                          NULL, 0, NULL, NULL, 0, 0);
  g_free (get.filt_id);
  if (ret)
    {
      g_free (xml_file);
      return NULL;
    }

  /* Pass the file to the report format generate script, sending the output
   * to a file. */

  {
    iterator_t formats;
    const char *uuid_format;
    gchar *script, *script_dir;
    get_data_t report_format_get;

    /* Setup file names. */

    memset (&report_format_get, '\0', sizeof (report_format_get));
    report_format_get.id = report_format_uuid (report_format);

    init_report_format_iterator (&formats, &report_format_get);
    if (next (&formats) == FALSE)
      {
        g_free (xml_file);
        cleanup_iterator (&formats);
        return NULL;
      }

    /* Set convenience return parameters. */
    assert (report_format_iterator_extension (&formats));
    assert (report_format_iterator_content_type (&formats));
    if (extension)
      *extension = g_strdup (report_format_iterator_extension (&formats));
    if (content_type)
      *content_type = g_strdup (report_format_iterator_content_type (&formats));

    uuid_format = report_format_iterator_uuid (&formats);
    if (report_format_global (report_format))
      script_dir = g_build_filename (OPENVAS_DATA_DIR,
                                     "openvasmd",
                                     "global_report_formats",
                                     uuid_format,
                                     NULL);
    else
      {
        assert (current_credentials.uuid);
        script_dir = g_build_filename (OPENVAS_STATE_DIR,
                                       "openvasmd",
                                       "report_formats",
                                       current_credentials.uuid,
                                       uuid_format,
                                       NULL);
      }

    cleanup_iterator (&formats);

    script = g_build_filename (script_dir, "generate", NULL);

    if (!g_file_test (script, G_FILE_TEST_EXISTS))
      {
        g_free (script);
        g_free (script_dir);
        if (extension) g_free (*extension);
        if (content_type) g_free (*content_type);
        g_free (xml_file);
        return NULL;
      }

    {
      gchar *output_file, *command;
      char *previous_dir;
      int ret;

      /* Change into the script directory. */

      /** @todo NULL arg is glibc extension. */
      previous_dir = getcwd (NULL, 0);
      if (previous_dir == NULL)
        {
          g_warning ("%s: Failed to getcwd: %s\n",
                     __FUNCTION__,
                     strerror (errno));
          g_free (previous_dir);
          g_free (script);
          g_free (script_dir);
          g_free (xml_file);
          if (extension) g_free (*extension);
          if (content_type) g_free (*content_type);
          return NULL;
        }

      if (chdir (script_dir))
        {
          g_warning ("%s: Failed to chdir: %s\n",
                     __FUNCTION__,
                     strerror (errno));
          g_free (previous_dir);
          g_free (script);
          g_free (script_dir);
          g_free (xml_file);
          if (extension) g_free (*extension);
          if (content_type) g_free (*content_type);
          return NULL;
        }
      g_free (script_dir);

      output_file = g_strdup_printf ("%s/report.out", xml_dir);

      /* Call the script. */

      command = g_strdup_printf ("/bin/sh %s %s > %s"
                                 " 2> /dev/null",
                                 script,
                                 xml_file,
                                 output_file);
      g_free (script);

      g_debug ("   command: %s\n", command);

      if (getuid () == 0)
        {
          pid_t pid;
          struct passwd *nobody;

          /* Run the command with lower privileges in a fork. */

          nobody = getpwnam ("nobody");
          if ((nobody == NULL)
              || chown (xml_dir, nobody->pw_uid, nobody->pw_gid)
              || chown (xml_file, nobody->pw_uid, nobody->pw_gid))
            {
              g_warning ("%s: Failed to set dir permissions: %s\n",
                         __FUNCTION__,
                         strerror (errno));
              g_free (previous_dir);
              g_free (output_file);
              g_free (xml_file);
              if (extension) g_free (*extension);
              if (content_type) g_free (*content_type);
              return NULL;
            }
          g_free (xml_file);

          pid = fork ();
          switch (pid)
            {
              case 0:
                {
                  /* Child.  Drop privileges, run command, exit. */

                  cleanup_manage_process (FALSE);

                  if (setgid (nobody->pw_gid))
                    {
                      g_warning ("%s (child): setgid: %s\n",
                                 __FUNCTION__,
                                 strerror (errno));
                      exit (EXIT_FAILURE);
                    }
                  if (setuid (nobody->pw_uid))
                    {
                      g_warning ("%s (child): setuid: %s\n",
                                 __FUNCTION__,
                                 strerror (errno));
                      exit (EXIT_FAILURE);
                    }

                  /* RATS: ignore, command is defined above. */
                  if (ret = system (command),
                      /** @todo ret is always -1. */
                      0 && ((ret) == -1
                            || WEXITSTATUS (ret)))
                    {
                      g_warning ("%s (child):"
                                 " system failed with ret %i, %i, %s\n",
                                 __FUNCTION__,
                                 ret,
                                 WEXITSTATUS (ret),
                                 command);
                      exit (EXIT_FAILURE);
                    }

                  exit (EXIT_SUCCESS);
                  break;
                }

              case -1:
                /* Parent when error. */

                g_warning ("%s: Failed to fork: %s\n",
                           __FUNCTION__,
                           strerror (errno));
                if (chdir (previous_dir))
                  g_warning ("%s: and chdir failed\n",
                             __FUNCTION__);
                g_free (previous_dir);
                g_free (output_file);
                g_free (command);
                if (extension) g_free (*extension);
                if (content_type) g_free (*content_type);
                return NULL;
                break;

              default:
                {
                  int status;

                  /* Parent on success.  Wait for child, and check result. */

                  g_free (command);

                  while (waitpid (pid, &status, 0) < 0)
                    {
                      if (errno == ECHILD)
                        {
                          g_warning ("%s: Failed to get child exit status",
                                     __FUNCTION__);
                          if (chdir (previous_dir))
                            g_warning ("%s: and chdir failed\n",
                                       __FUNCTION__);
                          g_free (previous_dir);
                          g_free (output_file);
                          if (extension) g_free (*extension);
                          if (content_type) g_free (*content_type);
                          return NULL;
                        }
                      if (errno == EINTR)
                        continue;
                      g_warning ("%s: wait: %s",
                                 __FUNCTION__,
                                 strerror (errno));
                      if (chdir (previous_dir))
                        g_warning ("%s: and chdir failed\n",
                                   __FUNCTION__);
                      g_free (previous_dir);
                      g_free (output_file);
                      if (extension) g_free (*extension);
                      if (content_type) g_free (*content_type);
                      return NULL;
                    }
                  if (WIFEXITED (status))
                    switch (WEXITSTATUS (status))
                      {
                        case EXIT_SUCCESS:
                          break;
                        case EXIT_FAILURE:
                        default:
                          g_warning ("%s: child failed, %s\n",
                                     __FUNCTION__,
                                     command);
                          if (chdir (previous_dir))
                            g_warning ("%s: and chdir failed\n",
                                       __FUNCTION__);
                          g_free (previous_dir);
                          g_free (output_file);
                          if (extension) g_free (*extension);
                          if (content_type) g_free (*content_type);
                          return NULL;
                      }
                  else
                    {
                      g_warning ("%s: child failed, %s\n",
                                 __FUNCTION__,
                                 command);
                      if (chdir (previous_dir))
                        g_warning ("%s: and chdir failed\n",
                                   __FUNCTION__);
                      g_free (previous_dir);
                      g_free (output_file);
                      if (extension) g_free (*extension);
                      if (content_type) g_free (*content_type);
                      return NULL;
                    }

                  /* Child succeeded, continue to process result. */

                  break;
                }
            }
        }
      else
        {
          /* Just run the command as the current user. */

          /* RATS: ignore, command is defined above. */
          if (ret = system (command),
              /** @todo ret is always -1. */
              0 && ((ret) == -1
                    || WEXITSTATUS (ret)))
            {
              g_warning ("%s: system failed with ret %i, %i, %s\n",
                         __FUNCTION__,
                         ret,
                         WEXITSTATUS (ret),
                         command);
              if (chdir (previous_dir))
                g_warning ("%s: and chdir failed\n",
                           __FUNCTION__);
              g_free (previous_dir);
              g_free (output_file);
              g_free (command);
              if (extension) g_free (*extension);
              if (content_type) g_free (*content_type);
              return NULL;
            }

          g_free (command);
        }

      {
        GError *get_error;
        gchar *output;
        gsize output_len;

        /* Change back to the previous directory. */

        if (chdir (previous_dir))
          {
            g_warning ("%s: Failed to chdir back: %s\n",
                       __FUNCTION__,
                       strerror (errno));
            g_free (previous_dir);
            g_free (output_file);
            if (extension) g_free (*extension);
            if (content_type) g_free (*content_type);
            return NULL;
          }
        g_free (previous_dir);

        /* Read the script output from file. */

        get_error = NULL;
        g_file_get_contents (output_file,
                             &output,
                             &output_len,
                             &get_error);
        g_free (output_file);
        if (get_error)
          {
            g_warning ("%s: Failed to get output: %s\n",
                       __FUNCTION__,
                       get_error->message);
            g_error_free (get_error);
            if (extension) g_free (*extension);
            if (content_type) g_free (*content_type);
            return NULL;
          }

        /* Remove the directory. */

        openvas_file_remove_recurse (xml_dir);

        /* Return the output. */

        if (output_length) *output_length = output_len;

        return output;
      }
    }
  }
}

/**
 * @brief Size of base64 chunk in manage_send_report.
 */
#define MANAGE_SEND_REPORT_CHUNK64_SIZE 262144

/**
 * @brief Size of file chunk in manage_send_report.
 */
#define MANAGE_SEND_REPORT_CHUNK_SIZE (MANAGE_SEND_REPORT_CHUNK64_SIZE * 3 / 4)

/**
 * @brief Generate a report.
 *
 * @param[in]  report             Report.
 * @param[in]  delta_report       Report to compare with.
 * @param[in]  report_format      Report format.
 * @param[in]  get                GET command data.
 * @param[in]  sort_order         Whether to sort ascending or descending.
 * @param[in]  sort_field         Field to sort on, or NULL for "type".
 * @param[in]  result_hosts_only  Whether to show only hosts with results.
 * @param[in]  min_cvss_base      Minimum CVSS base of included results.  All
 *                                results if NULL.
 * @param[in]  levels         String describing threat levels (message types)
 *                            to include in count (for example, "hmlgd" for
 *                            High, Medium, Low, loG and Debug).  All levels if
 *                            NULL.
 * @param[in]  delta_states   String describing delta states to include in count
 *                            (for example, "sngc" Same, New, Gone and Changed).
 *                            All levels if NULL.
 * @param[in]  apply_overrides    Whether to apply overrides.
 * @param[in]  search_phrase      Phrase that results must include.  All results
 *                                if NULL or "".
 * @param[in]  autofp             Whether to apply auto FP filter.
 * @param[in]  show_closed_cves   Whether to include the Closed CVEs host detail.
 * @param[in]  notes              Whether to include notes.
 * @param[in]  notes_details      If notes, Whether to include details.
 * @param[in]  overrides          Whether to include overrides.
 * @param[in]  overrides_details  If overrides, Whether to include details.
 * @param[in]  first_result       The result to start from.  The results are 0
 *                                indexed.
 * @param[in]  max_results        The maximum number of results returned.
 * @param[in]  base64             Whether to base64 encode the report.
 * @param[in]  send               Function to write to client.
 * @param[in]  send_data_1        Second argument to \p send.
 * @param[in]  send_data_2        Third argument to \p send.
 * @param[in]  alert_id       ID of alert to escalate report with,
 *                                instead of getting report.  NULL to get
 *                                report.
 * @param[in]  type               Type of report: NULL, "scan" or "assets".
 * @param[in]  host               Host or NULL, when type "assets".
 * @param[in]  pos                Position of report from end, when host.  1 for
 *                                last.
 * @param[in]  host_search_phrase  Phrase that results must include.  All results
 *                                 if NULL or "".  For hosts.
 * @param[in]  host_levels         String describing threat levels (message types)
 *                                 to include in count (for example, "hmlgd" for
 *                                 High, Medium, Low, loG and Debug).  All levels if
 *                                 NULL.
 * @param[in]  host_first_result   The host result to start from.  The results
 *                                 are 0 indexed.
 * @param[in]  host_max_results    The host maximum number of results returned.
 * @param[in]  prefix              Text to send to client before the report.
 *
 * @return 0 success, -1 error, 1 failed to find alert, 2 failed to find filter
 *         (before anything sent to client).
 */
int
manage_send_report (report_t report, report_t delta_report,
                    report_format_t report_format, const get_data_t *get,
                    int sort_order, const char* sort_field,
                    int result_hosts_only, const char *min_cvss_base,
                    const char *levels, const char *delta_states,
                    int apply_overrides, const char *search_phrase,
                    int autofp, int show_closed_cves, int notes,
                    int notes_details, int overrides, int overrides_details,
                    int first_result, int max_results, int base64,
                    gboolean (*send) (const char *,
                                      int (*) (const char *, void*),
                                      void*),
                    int (*send_data_1) (const char *, void*), void *send_data_2,
                    const char *alert_id, const char *type,
                    const char *host, int pos, const char *host_search_phrase,
                    const char *host_levels, int host_first_result,
                    int host_max_results, const gchar* prefix)
{
  task_t task;
  gchar *xml_file;
  char xml_dir[] = "/tmp/openvasmd_XXXXXX";
  int ret;

  if (type && (strcmp (type, "assets") == 0))
    task = 0;
  else if (type && (strcmp (type, "prognostic") == 0))
    task = 0;
  else if (type && (strcmp (type, "scan")))
    return -1;
  else if (report_task (report, &task))
    return -1;

  /* Escalate instead, if requested. */

  if (alert_id)
    {
      alert_t alert = 0;
      alert_condition_t condition;
      alert_method_t method;

      if (find_alert (alert_id, &alert))
        return -1;

      if (alert == 0)
        return 1;

      condition = alert_condition (alert);
      method = alert_method (alert);

      ret = escalate_2 (alert, task, report, EVENT_TASK_RUN_STATUS_CHANGED,
                        (void*) TASK_STATUS_DONE, method, condition,
                        /* Report filtering. */
                        sort_order, sort_field, result_hosts_only,
                        min_cvss_base, levels, apply_overrides,
                        search_phrase, autofp, show_closed_cves, notes,
                        notes_details, overrides, overrides_details,
                        first_result, max_results);
      return ret;
    }

  /* Print the report as XML to a file. */

  if ((report_format_predefined (report_format) == 0)
      && (report_format_trust (report_format) != TRUST_YES))
    return -1;

  if (mkdtemp (xml_dir) == NULL)
    {
      g_warning ("%s: mkdtemp failed\n", __FUNCTION__);
      return -1;
    }

  xml_file = g_strdup_printf ("%s/report.xml", xml_dir);
  ret = print_report_xml (report, delta_report, task, xml_file, get, sort_order,
                          sort_field, result_hosts_only, min_cvss_base,
                          report_format, levels, delta_states, apply_overrides,
                          search_phrase, autofp, show_closed_cves, notes,
                          notes_details, overrides, overrides_details,
                          first_result, max_results, type,
                          host, pos, host_search_phrase, host_levels,
                          host_first_result, host_max_results);
  if (ret)
    {
      g_free (xml_file);
      if (ret == 2)
        return 2;
      return -1;
    }

  /* Pass the file to the report format generate script, sending the output
   * to a file. */

  {
    iterator_t formats;
    const char *uuid_format;
    gchar *script, *script_dir;
    get_data_t report_format_get;

    /* Setup file names. */

    memset (&report_format_get, '\0', sizeof (report_format_get));
    report_format_get.id = report_format_uuid (report_format);

    init_report_format_iterator (&formats, &report_format_get);
    if (next (&formats) == FALSE)
      {
        g_free (xml_file);
        cleanup_iterator (&formats);
        return -1;
      }

    uuid_format = report_format_iterator_uuid (&formats);
    if (report_format_global (report_format))
      script_dir = g_build_filename (OPENVAS_DATA_DIR,
                                     "openvasmd",
                                     "global_report_formats",
                                     uuid_format,
                                     NULL);
    else
      {
        assert (current_credentials.uuid);
        script_dir = g_build_filename (OPENVAS_STATE_DIR,
                                       "openvasmd",
                                       "report_formats",
                                       current_credentials.uuid,
                                       uuid_format,
                                       NULL);
      }

    cleanup_iterator (&formats);

    script = g_build_filename (script_dir, "generate", NULL);

    if (!g_file_test (script, G_FILE_TEST_EXISTS))
      {
        g_free (script);
        g_free (script_dir);
        g_free (xml_file);
        return -1;
      }

    {
      gchar *output_file, *command;
      char *previous_dir;
      int ret;

      /* Change into the script directory. */

      /** @todo NULL arg is glibc extension. */
      previous_dir = getcwd (NULL, 0);
      if (previous_dir == NULL)
        {
          g_warning ("%s: Failed to getcwd: %s\n",
                     __FUNCTION__,
                     strerror (errno));
          g_free (previous_dir);
          g_free (script);
          g_free (script_dir);
          g_free (xml_file);
          return -1;
        }

      if (chdir (script_dir))
        {
          g_warning ("%s: Failed to chdir: %s\n",
                     __FUNCTION__,
                     strerror (errno));
          g_free (previous_dir);
          g_free (script);
          g_free (script_dir);
          g_free (xml_file);
          return -1;
        }
      g_free (script_dir);

      output_file = g_strdup_printf ("%s/report.out", xml_dir);

      /* Call the script. */

      command = g_strdup_printf ("/bin/sh %s %s > %s"
                                 " 2> /dev/null",
                                 script,
                                 xml_file,
                                 output_file);
      g_free (script);

      g_debug ("   command: %s\n", command);

      if (getuid () == 0)
        {
          pid_t pid;
          struct passwd *nobody;

          /* Run the command with lower privileges in a fork. */

          nobody = getpwnam ("nobody");
          if ((nobody == NULL)
              || chown (xml_dir, nobody->pw_uid, nobody->pw_gid)
              || chown (xml_file, nobody->pw_uid, nobody->pw_gid))
            {
              g_warning ("%s: Failed to set dir permissions: %s\n",
                         __FUNCTION__,
                         strerror (errno));
              g_free (previous_dir);
              g_free (xml_file);
              g_free (output_file);
              return -1;
            }

          g_free (xml_file);

          pid = fork ();
          switch (pid)
            {
              case 0:
                {
                  /* Child.  Drop privileges, run command, exit. */

                  cleanup_manage_process (FALSE);

                  if (setgid (nobody->pw_gid))
                    {
                      g_warning ("%s (child): setgid: %s\n",
                                 __FUNCTION__,
                                 strerror (errno));
                      exit (EXIT_FAILURE);
                    }
                  if (setuid (nobody->pw_uid))
                    {
                      g_warning ("%s (child): setuid: %s\n",
                                 __FUNCTION__,
                                 strerror (errno));
                      exit (EXIT_FAILURE);
                    }

                  /* RATS: ignore, command is defined above. */
                  if (ret = system (command),
                      /** @todo ret is always -1. */
                      0 && ((ret) == -1
                            || WEXITSTATUS (ret)))
                    {
                      g_warning ("%s (child):"
                                 " system failed with ret %i, %i, %s\n",
                                 __FUNCTION__,
                                 ret,
                                 WEXITSTATUS (ret),
                                 command);
                      exit (EXIT_FAILURE);
                    }

                  exit (EXIT_SUCCESS);
                  break;
                }

              case -1:
                /* Parent when error. */

                g_warning ("%s: Failed to fork: %s\n",
                           __FUNCTION__,
                           strerror (errno));
                if (chdir (previous_dir))
                  g_warning ("%s: and chdir failed\n",
                             __FUNCTION__);
                g_free (previous_dir);
                g_free (output_file);
                g_free (command);
                return -1;
                break;

              default:
                {
                  int status;

                  /* Parent on success.  Wait for child, and check result. */

                  g_free (command);

                  while (waitpid (pid, &status, 0) < 0)
                    {
                      if (errno == ECHILD)
                        {
                          g_warning ("%s: Failed to get child exit status",
                                     __FUNCTION__);
                          if (chdir (previous_dir))
                            g_warning ("%s: and chdir failed\n",
                                       __FUNCTION__);
                          g_free (previous_dir);
                          g_free (output_file);
                          return -1;
                        }
                      if (errno == EINTR)
                        continue;
                      g_warning ("%s: wait: %s",
                                 __FUNCTION__,
                                 strerror (errno));
                      if (chdir (previous_dir))
                        g_warning ("%s: and chdir failed\n",
                                   __FUNCTION__);
                      g_free (previous_dir);
                      g_free (output_file);
                      return -1;
                    }
                  if (WIFEXITED (status))
                    switch (WEXITSTATUS (status))
                      {
                        case EXIT_SUCCESS:
                          break;
                        case EXIT_FAILURE:
                        default:
                          g_warning ("%s: child failed, %s\n",
                                     __FUNCTION__,
                                     command);
                          if (chdir (previous_dir))
                            g_warning ("%s: and chdir failed\n",
                                       __FUNCTION__);
                          g_free (previous_dir);
                          g_free (output_file);
                          return -1;
                      }
                  else
                    {
                      g_warning ("%s: child failed, %s\n",
                                 __FUNCTION__,
                                 command);
                      if (chdir (previous_dir))
                        g_warning ("%s: and chdir failed\n",
                                   __FUNCTION__);
                      g_free (previous_dir);
                      g_free (output_file);
                      return -1;
                    }

                  /* Child succeeded, continue to process result. */

                  break;
                }
            }
        }
      else
        {
          /* Just run the command as the current user. */

          g_free (xml_file);

          /* RATS: ignore, command is defined above. */
          if (ret = system (command),
              /** @todo ret is always -1. */
              0 && ((ret) == -1
                    || WEXITSTATUS (ret)))
            {
              g_warning ("%s: system failed with ret %i, %i, %s\n",
                         __FUNCTION__,
                         ret,
                         WEXITSTATUS (ret),
                         command);
              if (chdir (previous_dir))
                g_warning ("%s: and chdir failed\n",
                           __FUNCTION__);
              g_free (previous_dir);
              g_free (command);
              g_free (output_file);
              return -1;
            }

          g_free (command);
        }

      {
        char chunk[MANAGE_SEND_REPORT_CHUNK_SIZE + 1];
        FILE *stream;

        /* Change back to the previous directory. */

        if (chdir (previous_dir))
          {
            g_warning ("%s: Failed to chdir back: %s\n",
                       __FUNCTION__,
                       strerror (errno));
            g_free (previous_dir);
            g_free (output_file);
            return -1;
          }
        g_free (previous_dir);

        /* Read the script output from file in chunks, sending to client. */

        stream = fopen (output_file, "r");
        g_free (output_file);
        if (stream == NULL)
          {
            g_warning ("%s: %s\n",
                       __FUNCTION__,
                       strerror (errno));
            return -1;
          }

        if (prefix && send (prefix, send_data_1, send_data_2))
          {
            fclose (stream);
            g_warning ("%s: send prefix error\n", __FUNCTION__);
            return -1;
          }

        while (1)
          {
            int left;
            char *dest;

            /* Read a chunk. */

            left = MANAGE_SEND_REPORT_CHUNK_SIZE;
            dest = chunk;
            while (1)
              {
                int ret = fread (dest, 1, left, stream);
                if (ferror (stream))
                  {
                    fclose (stream);
                    g_warning ("%s: error after fread\n", __FUNCTION__);
                    return -1;
                  }
                left -= ret;
                if (left == 0)
                  break;
                if (feof (stream))
                  break;
                dest += ret;
              }

            /* Send the chunk. */

            if (left < MANAGE_SEND_REPORT_CHUNK_SIZE)
              {
                if (base64)
                  {
                    gchar *chunk64;
                    chunk64 = g_base64_encode ((guchar*) chunk,
                                               MANAGE_SEND_REPORT_CHUNK_SIZE
                                                - left);
                    if (send (chunk64, send_data_1, send_data_2))
                      {
                        g_free (chunk64);
                        fclose (stream);
                        g_warning ("%s: send error\n", __FUNCTION__);
                        return -1;
                      }
                    g_free (chunk64);
                  }
                else
                  {
                    chunk[MANAGE_SEND_REPORT_CHUNK_SIZE - left] = '\0';
                    if (send (chunk, send_data_1, send_data_2))
                      {
                        fclose (stream);
                        g_warning ("%s: send error\n", __FUNCTION__);
                        return -1;
                      }
                  }
              }

            /* Check if there's more. */

            if (feof (stream))
              break;
          }

        fclose (stream);

        /* Remove the directory. */

        openvas_file_remove_recurse (xml_dir);

        /* Return the output. */

        return 0;
      }
    }
  }
}


/* More task stuff. */

/** @todo Should be on tasks page above. */

/**
 * @brief Return the number of reports associated with a task.
 *
 * @param[in]  task  Task.
 *
 * @return Number of reports.
 */
unsigned int
task_report_count (task_t task)
{
  return (unsigned int) sql_int (0, 0,
                                 "SELECT count(*) FROM reports WHERE task = %llu;",
                                 task);
}

/**
 * @brief Return the number of finished reports associated with a task.
 *
 * @param[in]  task  Task.
 *
 * @return Number of reports.
 */
unsigned int
task_finished_report_count (task_t task)
{
  return (unsigned int) sql_int (0, 0,
                                 "SELECT count(*) FROM reports"
                                 " WHERE task = %llu"
                                 " AND scan_run_status = %u;",
                                 task,
                                 TASK_STATUS_DONE);
}

/**
 * @brief Return the trend of a task, given counts.
 *
 * @param[in]  holes_a   Number of holes on earlier report.
 * @param[in]  warns_a   Number of warnings on earlier report.
 * @param[in]  infos_a   Number of infos on earlier report.
 * @param[in]  holes_b   Number of holes on later report.
 * @param[in]  warns_b   Number of warnings on later report.
 * @param[in]  infos_b   Number of infos on later report.
 *
 * @return "up", "down", "more", "less", "same" or if too few reports "".
 */
static const char *
task_trend_calc (int holes_a, int warns_a, int infos_a, int holes_b,
                 int warns_b, int infos_b)
{
  int threat_a, threat_b;

  /* Calculate trend. */

  if (holes_a > 0)
    threat_a = 4;
  else if (warns_a > 0)
    threat_a = 3;
  else if (infos_a > 0)
    threat_a = 2;
  else
    threat_a = 1;

  if (holes_b > 0)
    threat_b = 4;
  else if (warns_b > 0)
    threat_b = 3;
  else if (infos_b > 0)
    threat_b = 2;
  else
    threat_b = 1;

  /* Check if the threat level changed. */

  if (threat_a > threat_b)
    return "up";

  if (threat_a < threat_b)
    return "down";

  /* Check if the threat count changed in the highest level. */

  if (holes_a)
    {
      if (holes_a > holes_b)
        return "more";
      if (holes_a < holes_b)
        return "less";
      return "same";
    }

  if (warns_a)
    {
      if (warns_a > warns_b)
        return "more";
      if (warns_a < warns_b)
        return "less";
      return "same";
    }

  if (infos_a)
    {
      if (infos_a > infos_b)
        return "more";
      if (infos_a < infos_b)
        return "less";
      return "same";
    }

  return "same";
}

/**
 * @brief Return the trend of a task, given counts.
 *
 * @param[in]  task      Task.
 * @param[in]  holes_a   Number of holes on earlier report.
 * @param[in]  warns_a   Number of warnings on earlier report.
 * @param[in]  infos_a   Number of infos on earlier report.
 * @param[in]  holes_b   Number of holes on later report.
 * @param[in]  warns_b   Number of warnings on later report.
 * @param[in]  infos_b   Number of infos on later report.
 *
 * @return "up", "down", "more", "less", "same" or if too few reports "".
 */
const char *
task_trend_counts (task_t task, int holes_a, int warns_a, int infos_a,
                   int holes_b, int warns_b, int infos_b)
{
  /* Ensure there are enough reports. */

  if (task_finished_report_count (task) <= 1)
    return "";

  /* Skip running tasks. */

  if (task_run_status (task) == TASK_STATUS_RUNNING)
    return "";

  return task_trend_calc (holes_a, warns_a, infos_a, holes_b, warns_b, infos_b);
}

/**
 * @brief Return the trend of a task.
 *
 * @param[in]  task      Task.
 * @param[in]  override  Whether to override the threat.
 *
 * @return "up", "down", "more", "less", "same" or if too few reports "".
 */
const char *
task_trend (task_t task, int override)
{
  report_t last_report, second_last_report;
  int holes_a, warns_a, infos_a, logs_a, false_positives_a;
  int holes_b, warns_b, infos_b, logs_b, false_positives_b;

  /* Ensure there are enough reports. */

  if (task_finished_report_count (task) <= 1)
    return "";

  /* Skip running and container tasks. */

  if (task_run_status (task) == TASK_STATUS_RUNNING)
    return "";

  if (task_target (task) == 0)
    return NULL;

  /* Get details of last report. */

  task_last_report (task, &last_report);
  if (last_report == 0)
    return "";

  /* Count the logs and false positives too, as report_counts_id is faster
   * with all five. */
  if (report_counts_id (last_report, NULL, &holes_a, &infos_a, &logs_a, &warns_a,
                        &false_positives_a, override, NULL, 0))
    /** @todo Either fail better or abort at SQL level. */
    abort ();

  /* Get details of second last report. */

  task_second_last_report (task, &second_last_report);
  if (second_last_report == 0)
    return "";

  /* Count the logs and false positives too, as report_counts_id is faster
   * with all five. */
  if (report_counts_id (second_last_report, NULL, &holes_b, &infos_b, &logs_b,
                        &warns_b, &false_positives_b, override, NULL, 0))
    /** @todo Either fail better or abort at SQL level. */
    abort ();

  return task_trend_calc (holes_a, warns_a, infos_a, holes_b, warns_b,
                          infos_b);
}

/**
 * @brief Set the attack state of a scan (given by a report).
 *
 * @param[in]  report  Report.
 * @param[in]  host    Host to which the state refers.
 * @param[in]  state   New state.
 */
void
set_scan_attack_state (report_t report, const char* host, const char* state)
{
  sql ("UPDATE report_hosts SET attack_state = '%s'"
       " WHERE host = '%s' AND report = %llu;",
       state,
       host,
       report);
}

/**
 * @brief Dummy function.
 */
void
free_tasks ()
{
  /* Empty. */
}

/**
 * @brief Make a task.
 *
 * The char* parameters name and comment are used directly and freed
 * when the task is freed.
 *
 * @param[in]  name     The name of the task.
 * @param[in]  time     The period of the task, in seconds.
 * @param[in]  comment  A comment associated the task.
 *
 * @return A pointer to the new task.
 */
task_t
make_task (char* name, unsigned int time, char* comment)
{
  task_t task;
  char* uuid = openvas_uuid_make ();
  gchar *quoted_name, *quoted_comment;
  if (uuid == NULL) abort ();
  quoted_name = name ? sql_quote ((gchar*) name) : NULL;
  quoted_comment = comment ? sql_quote ((gchar*) comment) : NULL;
  sql ("INSERT into tasks"
       " (owner, uuid, name, hidden, time, comment, schedule,"
       "  schedule_next_time, slave, config_location, target_location,"
       "  schedule_location, slave_location, creation_time, modification_time)"
       " VALUES ((SELECT ROWID FROM users WHERE users.uuid = '%s'),"
       "         '%s', '%s', 0, %u, '%s', 0, 0, 0, 0, 0, 0, 0, now (),"
       "         now ());",
       current_credentials.uuid,
       uuid,
       quoted_name ? quoted_name : "",
       time,
       quoted_comment ? quoted_comment : "");
  task = sqlite3_last_insert_rowid (task_db);
  set_task_run_status (task, TASK_STATUS_NEW);
  sql ("INSERT INTO task_preferences (task, name, value)"
       " VALUES (%llu, 'in_assets', 'yes')",
       task);
  free (uuid);
  free (name);
  free (comment);
  g_free (quoted_name);
  g_free (quoted_comment);
  return task;
}

/**
 * @brief Complete the creation of a task.
 *
 * @param[in]  uuid     The UUID of the task.
 */
void
make_task_complete (const char *uuid)
{
  task_t task;

  if (find_task (uuid, &task))
    return;

  if (task == 0)
    return;

  event (task, EVENT_TASK_RUN_STATUS_CHANGED, (void*) TASK_STATUS_NEW);
}

#ifdef S_SPLINT_S
typedef /*@only@*/ struct dirent * only_dirent_pointer;
#endif

/**
 * @brief Dummy function.
 *
 * @return 0.
 */
int
load_tasks ()
{
  return 0;
}

/**
 * @brief Dummy function.
 *
 * @return 0.
 */
int
save_tasks ()
{
  return 0;
}

/**
 * @brief Set a task parameter.
 *
 * The "value" parameter is used directly and freed either immediately or
 * when the task is freed.
 *
 * @param[in]  task       A pointer to a task.
 * @param[in]  parameter  The name of the parameter (in any case): RCFILE,
 *                        NAME or COMMENT.
 * @param[in]  value      The value of the parameter, in base64 if parameter
 *                        is "RCFILE".
 *
 * @return 0 on success, -2 if parameter name error, -3 value error (NULL).
 */
int
set_task_parameter (task_t task, const char* parameter, /*@only@*/ char* value)
{
  /** @todo Free value consistently. */

  tracef ("   set_task_parameter %u %s\n",
          task_id (task),
          parameter ? parameter : "(null)");
  if (value == NULL) return -3;
  if (parameter == NULL)
    {
      free (value);
      return -2;
    }
  if (strcasecmp ("RCFILE", parameter) == 0)
    {
      gsize rc_len;
      guchar *rc;
      gchar *quoted_rc;

      rc = g_base64_decode (value, &rc_len);

      sql ("BEGIN IMMEDIATE;");

      /* Remove all files from the task. */

      sql ("DELETE FROM task_files WHERE task = %llu;", task);

      /* Update task description (rcfile). */

      quoted_rc = sql_quote ((gchar*) rc);
      sql ("UPDATE tasks SET description = '%s', modification_time = now ()"
           " WHERE ROWID = %llu;",
           quoted_rc,
           task);
      g_free (quoted_rc);

      /* Update task config. */

      {
        config_t config;
        target_t target;
        char *config_name, *config_uuid;
        char *quoted_config_name, *quoted_selector;

        config_uuid = task_config_uuid (task);
        if (config_uuid == NULL)
          {
            g_free (rc);
            sql ("ROLLBACK");
            return -1;
          }

        target = task_target (task);
        if (target == 0)
          {
            free (config_uuid);
            g_free (rc);
            sql ("ROLLBACK");
            return -1;
          }

        if (find_config (config_uuid, &config))
          {
            free (config_uuid);
            g_free (rc);
            sql ("ROLLBACK");
            return -1;
          }
        else if (config == 0)
          {
            free (config_uuid);
            g_free (rc);
            sql ("ROLLBACK");
            return -1;
          }
        else
          {
            char *hosts, *selector;

            free (config_uuid);

            config_name = task_config_name (task);
            if (config_name == NULL)
              {
                g_free (rc);
                sql ("ROLLBACK");
                return -1;
              }

            selector = config_nvt_selector (config);
            if (selector == NULL)
              {
                free (config_name);
                g_free (rc);
                sql ("ROLLBACK");
                return -1;
              }
            quoted_selector = sql_quote (selector);
            free (selector);

            /* Flush config preferences. */

            sql ("DELETE FROM config_preferences WHERE config = %llu;",
                 config);

            /* Flush selector NVTs. */

            sql ("DELETE FROM nvt_selectors WHERE name = '%s';",
                 quoted_selector);

            /* Replace targets. */

            hosts = rc_preference ((gchar*) rc, "targets");
            if (hosts == NULL)
              {
                free (config_name);
                free (quoted_selector);
                g_free (rc);
                sql ("ROLLBACK");
                return -1;
              }
            set_target_hosts (target, hosts);
            free (hosts);

            /* Fill config from RC. */

            quoted_config_name = sql_quote (config_name);
            free (config_name);
            /* This modifies rc. */
            if (insert_rc_into_config (config, quoted_config_name,
                                       quoted_selector, (gchar*) rc))
              {
                free (quoted_selector);
                g_free (rc);
                sql ("ROLLBACK");
                return -1;
              }
            free (quoted_selector);
            g_free (rc);
          }

        sql ("COMMIT");
      }
    }
  else if (strcasecmp ("NAME", parameter) == 0)
    {
      gchar* quote = sql_nquote (value, strlen (value));
      sql ("UPDATE tasks SET name = '%s', modification_time = now ()"
           " WHERE ROWID = %llu;",
           value,
           task);
      g_free (quote);
    }
  else if (strcasecmp ("COMMENT", parameter) == 0)
    {
      gchar* quote = sql_nquote (value, strlen (value));
      sql ("UPDATE tasks SET comment = '%s', modification_time = now ()"
           " WHERE ROWID = %llu;",
           quote,
           task);
      g_free (quote);
    }
  else
    {
      free (value);
      return -2;
    }
  return 0;
}

/**
 * @brief Create a task from an existing task.
 *
 * @param[in]  name        Name of new task.  NULL to copy from existing.
 * @param[in]  comment     Comment on new task.  NULL to copy from existing.
 * @param[in]  task_id     UUID of existing task.
 * @param[out] new_task    New task.
 *
 * @return 0 success, 2 failed to find existing task, -1 error.
 */
int
copy_task (const char* name, const char* comment, const char *task_id,
           task_t* new_task)
{
  task_t task;
  gchar *quoted_name, *quoted_uuid, *uniquify;
  user_t owner;

  assert (current_credentials.uuid);

  if (task_id == NULL)
    return -1;

  sql ("BEGIN IMMEDIATE;");

  if (find_user (current_credentials.username, &owner)
      || owner == 0)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (name && strlen (name))
    quoted_name = sql_quote (name);
  else
    quoted_name = NULL;

  quoted_uuid = sql_quote (task_id);
  if (sql_int (0, 0,
               "SELECT COUNT(*) FROM tasks"
               " WHERE uuid = '%s'"
               " AND ((owner IS NULL) OR (owner = %llu))",
               quoted_uuid,
               owner)
      == 0)
    {
      sql ("ROLLBACK;");
      g_free (quoted_name);
      return 2;
    }

  /* Copy the existing task. */

  uniquify = g_strdup_printf ("uniquify ('task', name, %llu, ' Clone')",
                              owner);
  if (comment && strlen (comment))
    {
      gchar *quoted_comment;
      quoted_comment = sql_nquote (comment, strlen (comment));
      sql ("INSERT INTO tasks"
           " (uuid, owner, name, hidden, time, comment, config, target,"
           "  schedule, schedule_next_time, slave, config_location,"
           "  target_location, schedule_location, slave_location,"
           "  creation_time, modification_time)"
           " SELECT make_uuid (), %llu, %s%s%s, 0, time, '%s', config, target,"
           " schedule, schedule_next_time, slave, config_location,"
           " target_location, schedule_location, slave_location,"
           " now (), now ()"
           " FROM tasks WHERE uuid = '%s';",
           owner,
           quoted_name ? "'" : "",
           quoted_name ? quoted_name : uniquify,
           quoted_name ? "'" : "",
           quoted_comment ? quoted_comment : "",
           quoted_uuid);
      g_free (quoted_comment);
    }
  else
    sql ("INSERT into tasks"
         " (uuid, owner, name, hidden, time, comment, config, target,"
         "  schedule, schedule_next_time, slave, config_location,"
         "  target_location, schedule_location, slave_location,"
         "  creation_time, modification_time)"
         " SELECT make_uuid (), %llu, %s%s%s, 0, time, comment, config,"
         " target, schedule, schedule_next_time, slave, config_location,"
         " target_location, schedule_location, slave_location,"
         " now (), now ()"
         " FROM tasks WHERE uuid = '%s';",
         owner,
         quoted_name ? "'" : "",
         quoted_name
          ? quoted_name
          : "uniquify ('task', name, owner, ' Clone')",
         quoted_name ? "'" : "",
         quoted_uuid);

  task = sqlite3_last_insert_rowid (task_db);

  if (new_task)
    *new_task = task;

  set_task_run_status (task, TASK_STATUS_NEW);
  sql ("INSERT INTO task_preferences (task, name, value)"
       " VALUES (%llu, 'in_assets', 'yes')",
       task);

  sql ("INSERT INTO task_alerts (task, alert, alert_location)"
       " SELECT %llu, alert, alert_location FROM task_alerts"
       " WHERE task = (SELECT ROWID FROM tasks WHERE uuid = '%s');",
       task,
       quoted_uuid);

  sql ("INSERT INTO task_users (task, user, actions)"
       " SELECT %llu, user, actions"
       " FROM task_users"
       " WHERE task = (SELECT ROWID FROM tasks WHERE uuid = '%s');",
       task,
       quoted_uuid);

  sql ("COMMIT;");
  g_free (quoted_uuid);
  g_free (quoted_name);
  g_free (uniquify);
  return 0;
}

/**
 * @brief Request deletion of a task.
 *
 * Stop the task beforehand with \ref stop_task, if it is running.
 *
 * Used only for CREATE_TASK in omp.c.  Always ultimate.
 *
 * @param[in]  task_pointer  A pointer to the task.
 *
 * @return 0 if deleted, 1 if delete requested, 2 if task is hidden,
 *         -1 if error.
 */
int
request_delete_task (task_t* task_pointer)
{
  task_t task = *task_pointer;
  int hidden;

  tracef ("   request delete task %u\n", task_id (task));

  hidden = sql_int (0, 0,
                    "SELECT hidden from tasks WHERE ROWID = %llu;",
                    *task_pointer);

  if (hidden == 1)
    return 2;

  /* Technically the task could be in the trashcan, if someone gets the UUID
   * with GET_TASKS before the CREATE_TASK finishes, and removes the task.
   * Pretend it was deleted.  There'll be half a task in the trashcan. */
  if (hidden == 2)
    return 0;

  if (current_credentials.uuid == NULL) return -1;

  switch (stop_task (task))
    {
      case 0:    /* Stopped. */
        return delete_task_lock (task, 1);
      case 1:    /* Stop requested. */
        set_task_run_status (task, TASK_STATUS_DELETE_ULTIMATE_REQUESTED);
        return 1;
      default:   /* Programming error. */
        assert (0);
      case -1:   /* Error. */
        return -1;
        break;
    }

  return 0;
}

static gboolean
find_trash_task (const char*, task_t*);

/**
 * @brief Request deletion of a task.
 *
 * Stop the task beforehand with \ref stop_task, if it is running.
 *
 * @param[in]  task_id   UUID of task.
 * @param[in]  ultimate  Whether to remove entirely, or to trashcan.
 *
 * @return 0 if deleted, 1 if delete requested, 2 if task is hidden, 3 failed
 *         to find task, -1 if error.
 */
int
request_delete_task_uuid (const char *task_id, int ultimate)
{
  task_t task = 0;

  /* Tasks have special handling for the trashcan.  Other resources have trash
   * tables, like targets_trash.  Tasks are marked as trash in the tasks table
   * by giving the "hidden" field a value of 2.  This means that the results can
   * stay in the results table and will still refer to the correct task.  This
   * should all work because there is already handling of the hidden flag
   * everywhere else. */

  tracef ("   request delete task %s\n", task_id);

  sql ("BEGIN IMMEDIATE;");

  if (find_task (task_id, &task))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (task == 0)
    {
      if (find_trash_task (task_id, &task))
        {
          sql ("ROLLBACK;");
          return -1;
        }
      if (task == 0)
        {
          sql ("ROLLBACK;");
          return 3;
        }
      if (ultimate == 0)
        {
          /* It's already in the trashcan. */
          sql ("COMMIT;");
          return 0;
        }

      if (delete_reports (task))
        {
          sql ("ROLLBACK;");
          return -1;
        }

      sql ("DELETE FROM results WHERE task = %llu;", task);
      sql ("DELETE FROM tasks WHERE ROWID = %llu;", task);
      sql ("DELETE FROM task_alerts WHERE task = %llu;", task);
      sql ("DELETE FROM task_files WHERE task = %llu;", task);
      sql ("DELETE FROM task_preferences WHERE task = %llu;", task);
      sql ("COMMIT;");
      return 0;
    }

  if (sql_int (0, 0,
               "SELECT hidden from tasks WHERE ROWID = %llu;",
               task)
      == 1)
    {
      sql ("ROLLBACK;");
      return 2;
    }

  if (current_credentials.uuid == NULL)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  switch (stop_task (task))
    {
      case 0:    /* Stopped. */
        {
          int ret;
          ret = delete_task (task, ultimate);
          if (ret)
            sql ("ROLLBACK;");
          else
            sql ("COMMIT;");
          return ret;
        }
      case 1:    /* Stop requested. */
        if (ultimate)
          set_task_run_status (task,
                               TASK_STATUS_DELETE_ULTIMATE_REQUESTED);
        else
          set_task_run_status (task,
                               TASK_STATUS_DELETE_REQUESTED);
        sql ("COMMIT;");
        return 1;
      default:   /* Programming error. */
        assert (0);
      case -1:   /* Error. */
        sql ("ROLLBACK;");
        return -1;
        break;
    }

  /*@notreached@*/
  sql ("COMMIT;");
  return 0;
}

/**
 * @brief Complete deletion of a task.
 *
 * The caller must do the locking, and must do the hidden check.
 *
 * The caller must handle the case where the task is already in the trashcan.
 *
 * @param[in]  task      The task.
 * @param[in]  ultimate  Whether to remove entirely, or to trashcan.
 *
 * @return 0 on success, 1 if task is hidden, -1 on error.
 */
int
delete_task (task_t task, int ultimate)
{
  tracef ("   delete task %llu\n", task);

  /** @todo Many other places just assert this. */
  if (current_credentials.uuid == NULL)
    return -1;

  if (ultimate)
    {
      if (delete_reports (task))
        return -1;

      sql ("DELETE FROM results WHERE task = %llu;", task);
      sql ("DELETE FROM tasks WHERE ROWID = %llu;", task);
      sql ("DELETE FROM task_alerts WHERE task = %llu;", task);
      sql ("DELETE FROM task_files WHERE task = %llu;", task);
      sql ("DELETE FROM task_preferences WHERE task = %llu;", task);
    }
  else
    sql ("UPDATE tasks SET hidden = 2 WHERE ROWID = %llu;", task);

  return 0;
}

/**
 * @brief Complete deletion of a task.
 *
 * This sets up a transaction around the delete.
 *
 * @param[in]  task      The task.
 * @param[in]  ultimate  Whether to remove entirely, or to trashcan.
 *
 * @return 0 on success, 1 if task is hidden, -1 on error.
 */
int
delete_task_lock (task_t task, int ultimate)
{
  int ret;

  tracef ("   delete task %llu\n", task);

  sql ("BEGIN EXCLUSIVE;");

  if (sql_int (0, 0, "SELECT hidden FROM tasks WHERE ROWID = %llu;", task))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /** @todo Many other places just assert this. */
  if (current_credentials.uuid == NULL)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  ret = delete_task (task, ultimate);
  if (ret)
    sql ("ROLLBACK;");
  else
    sql ("COMMIT;");
  return ret;
}

/**
 * @brief Delete all trash tasks.
 *
 * The caller must do the transaction.
 *
 * @return 0 on success, -1 on error.
 */
static int
delete_trash_tasks ()
{
  iterator_t tasks;

  init_user_task_iterator (&tasks, 0, 1);
  while (next (&tasks))
    {
      task_t task;

      task = get_iterator_resource (&tasks);

      if (delete_reports (task))
        {
          cleanup_iterator (&tasks);
          return -1;
        }

      sql ("DELETE FROM results WHERE task = %llu;", task);
      sql ("DELETE FROM tasks WHERE ROWID = %llu;", task);
      sql ("DELETE FROM task_alerts WHERE task = %llu;", task);
      sql ("DELETE FROM task_files WHERE task = %llu;", task);
      sql ("DELETE FROM task_preferences WHERE task = %llu;", task);
    }
  cleanup_iterator (&tasks);

  return 0;
}

/**
 * @brief Append text to the comment associated with a task.
 *
 * @param[in]  task    A pointer to the task.
 * @param[in]  text    The text to append.
 * @param[in]  length  Length of the text.
 */
void
append_to_task_comment (task_t task, const char* text, /*@unused@*/ int length)
{
  append_to_task_string (task, "comment", text);
}

/**
 * @brief Append text to the name associated with a task.
 *
 * @param[in]  task    A pointer to the task.
 * @param[in]  text    The text to append.
 * @param[in]  length  Length of the text.
 */
void
append_to_task_name (task_t task, const char* text, /*@unused@*/ int length)
{
  append_to_task_string (task, "name", text);
}

/**
 * @brief Add a line to a task description.
 *
 * @param[in]  task         A pointer to the task.
 * @param[in]  line         The line.
 * @param[in]  line_length  The length of the line.
 */
void
add_task_description_line (task_t task, const char* line,
                           /*@unused@*/ size_t line_length)
{
  append_to_task_string (task, "description", line);
}

/**
 * @brief Set the ports for a particular host in a scan.
 *
 * @param[in]  report   Report associated with scan.
 * @param[in]  host     Host.
 * @param[in]  current  New value for port currently being scanned.
 * @param[in]  max      New value for last port to be scanned.
 */
void
set_scan_ports (report_t report, const char* host, unsigned int current,
                unsigned int max)
{
  sql ("UPDATE report_hosts SET current_port = %i, max_port = %i"
       " WHERE host = '%s' AND report = %llu;",
       current, max, host, report);
}

/**
 * @brief Add an open port as a result to a task.
 *
 * @param[in]  task  The task.
 * @param[in]  host  The host the port is on.
 * @param[in]  port  The port string.
 */
void
append_task_open_port (task_t task, const char *host, const char *port)
{
  result_t result;
  result = make_result (task, host, host, port, "0", "Log Message",
                        "Open port.");
  if (current_report) report_add_result (current_report, result);
}

/**
 * @brief Find a task given an identifier.
 *
 * @param[in]   uuid  A task identifier.
 * @param[out]  task  Task return, 0 if succesfully failed to find task.
 *
 * @return FALSE on success (including if failed to find task), TRUE on error.
 */
gboolean
find_task (const char* uuid, task_t* task)
{
  if (user_owns_uuid ("task", uuid) == 0)
    {
      *task = 0;
      return FALSE;
    }
  switch (sql_int64 (task, 0, 0,
                     "SELECT ROWID FROM tasks WHERE uuid = '%s'"
                     " AND hidden != 2;",
                     uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *task = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        return TRUE;
        break;
    }

  return FALSE;
}

/**
 * @brief Find a task for an action, given an identifier.
 *
 * @param[in]   uuid     A task identifier.
 * @param[out]  task     Task return, 0 if succesfully failed to find task.
 * @param[in]   actions  Actions.
 *
 * @return FALSE on success (including if failed to find task), TRUE on error.
 */
gboolean
find_task_for_actions (const char* uuid, task_t* task, const char *actions)
{
  if (user_has_access_uuid ("task", uuid, actions) == 0)
    {
      *task = 0;
      return FALSE;
    }
  switch (sql_int64 (task, 0, 0,
                     "SELECT ROWID FROM tasks WHERE uuid = '%s'"
                     " AND hidden != 2;",
                     uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *task = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        return TRUE;
        break;
    }

  return FALSE;
}

/**
 * @brief Find a task in the trashcan, given an identifier.
 *
 * @param[in]   uuid  A task identifier.
 * @param[out]  task  Task return, 0 if succesfully failed to find task.
 *
 * @return FALSE on success (including if failed to find task), TRUE on error.
 */
static gboolean
find_trash_task (const char* uuid, task_t* task)
{
  if (user_owns_uuid ("task", uuid) == 0)
    {
      *task = 0;
      return FALSE;
    }
  switch (sql_int64 (task, 0, 0,
                     "SELECT ROWID FROM tasks WHERE uuid = '%s'"
                     " AND hidden = 2;",
                     uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *task = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        return TRUE;
        break;
    }

  return FALSE;
}

/**
 * @brief Find a report given an identifier.
 *
 * @param[in]   uuid    A report identifier.
 * @param[out]  report  Report return, 0 if succesfully failed to find report.
 *
 * @return FALSE on success (including if failed to find report), TRUE on error.
 */
gboolean
find_report (const char* uuid, report_t* report)
{
  if (user_owns_uuid ("report", uuid) == 0)
    {
      *report = 0;
      return FALSE;
    }
  switch (sql_int64 (report, 0, 0,
                     "SELECT ROWID FROM reports WHERE uuid = '%s';",
                     uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *report = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        return TRUE;
        break;
    }

  return FALSE;
}

/**
 * @brief Find a report given an identifier.
 *
 * @param[in]   uuid     A report identifier.
 * @param[out]  report   Report return, 0 if succesfully failed to find report.
 * @param[in]   actions  Actions.
 *
 * @return FALSE on success (including if failed to find report), TRUE on error.
 */
gboolean
find_report_for_actions (const char* uuid, report_t* report,
                         const char *actions)
{
  if (user_has_access_uuid ("report", uuid, actions) == 0)
    {
      *report = 0;
      return FALSE;
    }
  switch (sql_int64 (report, 0, 0,
                     "SELECT ROWID FROM reports WHERE uuid = '%s';",
                     uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *report = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        return TRUE;
        break;
    }

  return FALSE;
}

/**
 * @brief Reset all running information for a task.
 *
 * @param[in]  task  Task.
 */
void
reset_task (task_t task)
{
  sql ("UPDATE tasks SET"
       " start_time = 0,"
       " end_time = 0"
       " WHERE ROWID = %llu;",
       task);
}

/**
 * @brief Add a file to a task, or update the file on the task.
 *
 * @param[in]  task     Task.
 * @param[in]  name     Name of file.
 * @param[in]  content  Content for file in base64 encoding.
 */
void
manage_task_update_file (task_t task, const char *name,
                         const void *content)
{
  gchar* quoted_name = sql_quote (name);
  gchar* quoted_content = sql_quote (content);

  /** @todo Probably better to save ASCII instead of base64. */

  if (sql_int (0, 0,
               "SELECT count(*) FROM task_files"
               " WHERE task = %llu AND name = '%s';",
               task,
               quoted_name))
    {
      /* Update the existing file. */

      sql ("UPDATE task_files SET content = '%s'"
           " WHERE task = %llu AND name = '%s';",
           quoted_content,
           task,
           quoted_name);
    }
  else
    {
      /* Insert the file. */

      sql ("INSERT INTO task_files (task, name, content)"
           " VALUES (%llu, '%s', '%s');",
           task,
           quoted_name,
           quoted_content);
    }

  sql ("UPDATE tasks SET modification_time = now () WHERE ROWID = %llu;",
       task);

  g_free (quoted_name);
  g_free (quoted_content);
}

/**
 * @brief Remove a file on a task.
 *
 * @param[in]  task     Task.
 * @param[in]  name     Name of file.
 *
 * @return 0 success, -1 error.
 */
int
manage_task_remove_file (task_t task, const char *name)
{
  if (sql_int (0, 0,
               "SELECT count(*) FROM task_files"
               " WHERE task = %llu AND name = '%s';",
               task))
    {
      gchar* quoted_name = sql_quote (name);
      sql ("DELETE FROM task_files WHERE task = %llu AND name = '%s';",
           task,
           quoted_name);
      sql ("UPDATE tasks SET modification_time = now () WHERE ROWID = %llu;",
           task);
      g_free (quoted_name);
      return 0;
    }
  return -1;
}


/**
 * @brief Initialise a task file iterator.
 *
 * @param[in]  iterator  Iterator.
 * @param[in]  task      Task.
 * @param[in]  file      File name, NULL for all files.
 */
void
init_task_file_iterator (iterator_t* iterator, task_t task, const char* file)
{
  gchar* sql;
  if (file)
    {
      gchar *quoted_file = sql_nquote (file, strlen (file));
      sql = g_strdup_printf ("SELECT name, content, length(content)"
                             " FROM task_files"
                             " WHERE task = %llu"
                             " AND name = '%s';",
                             task, quoted_file);
      g_free (quoted_file);
    }
  else
    sql = g_strdup_printf ("SELECT name, content, length(content)"
                           " FROM task_files"
                           " WHERE task = %llu;",
                           task);
  init_iterator (iterator, sql);
  g_free (sql);
}

/**
 * @brief Get the name of the file from a task file iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name of the file or NULL if iteration is complete.
 */
DEF_ACCESS (task_file_iterator_name, 0);

/**
 * @brief Get the content of the file from a task file iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Content of the file or NULL if iteration is complete.
 */
DEF_ACCESS (task_file_iterator_content, 1);

/**
 * @brief Get the length from a task file iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Length.
 */
int
task_file_iterator_length (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (int) sqlite3_column_int (iterator->stmt, 2);
  return ret;
}


/* Targets. */

/**
 * @brief Find a target given a UUID.
 *
 * @param[in]   uuid    UUID of target.
 * @param[out]  target  Target return, 0 if succesfully failed to find target.
 *
 * @return FALSE on success (including if failed to find target), TRUE on error.
 */
gboolean
find_target (const char* uuid, target_t* target)
{
  return find_resource ("target", uuid, target);
}

/**
 * @brief Find a target for a set of actions, given a UUID.
 *
 * @param[in]   uuid     UUID of target.
 * @param[out]  target   Target return, 0 if succesfully failed to find target.
 * @param[in]   actions  Actions.
 *
 * @return FALSE on success (including if failed to find target), TRUE on error.
 */
gboolean
find_target_for_actions (const char* uuid, target_t* target,
                         const char *actions)
{
  gchar *quoted_uuid = sql_quote (uuid);
  if (user_has_access_uuid ("target", quoted_uuid, actions) == 0)
    {
      g_free (quoted_uuid);
      *target = 0;
      return FALSE;
    }
  switch (sql_int64 (target, 0, 0,
                     "SELECT ROWID FROM targets WHERE uuid = '%s';",
                     quoted_uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *target = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        g_free (quoted_uuid);
        return TRUE;
        break;
    }

  g_free (quoted_uuid);
  return FALSE;
}

/**
 * @brief Search backwards in a string for a character.
 *
 * Start at the character before \p point.
 *
 * @param[in]  start  Start of string.
 * @param[in]  point  Current position.
 * @param[in]  ch     Character.
 *
 * @return Address of matching character, else NULL.
 */
static char *
strbchr (char *start, char *point, char ch)
{
  while (1)
    {
      if (point == start)
        return NULL;
      point--;
      if (*point == ch)
        return point;
    }
}

/**
 * @brief Return whether a string contains a hyphen.
 *
 * @param[in]  string  String.
 *
 * @return 1 yes, 0 no.
 */
static int
contains_alpha (const char *string)
{
  assert (string);
  while (*string) if (isalpha (*string)) return 1; else string++;
  return 0;
}

/**
 * @brief Validate a host.
 *
 * @param[in]  string  Host
 *
 * @return 0 if validate, else 1;
 */
static int
validate_host (const char *string)
{
  gchar **split, **point, **last;
  int numeric;
  const char *host;

  host = string;

  /* @todo GInetAddress might do this better, once we get to GLib 2.22. */

  /* Broadly check that the host has the right chars, and is free of space. */

  while (*host && isspace (*host))
    host++;
  while (*host && (isalnum (*host) || strchr ("-_.:\\", *host)))
    host++;
  while (*host && isspace (*host))
    host++;
  if (*host)
    return 1;

  /* Check number of octets for IPv4 in numeric form. */

  split = g_strsplit (string, ".", 0);
  point = last = split;
  while (*point) last = point++;
  if (*last)
    {
      const char *octet;
      octet = *last;
      while (*octet && isdigit (*octet)) octet++;
      if (*octet == '\0' && g_strv_length (split) > 4)
        return 1;
    }

  point = split;
  numeric = -1;
  while (*point)
    {
      gchar *octet;

      /* Check an octet. */

      octet = *point;
      if (strlen (octet) == 0)
        goto free_fail;
      while (*octet && isdigit (*octet)) octet++;
      if (*octet)
        {
          /* Name octet. */

          if (numeric == 1)
            goto free_fail;
          numeric = 0;

          /** @todo More checks?  leading -_? */
        }
      else
        {
          int number;

          /* Numeric octet. */

          if (numeric == 0)
            goto free_fail;
          numeric = 1;

          number = atoi (*point);
          if ((number < 0) || (number > 255))
            goto free_fail;
        }
      point++;
    }

  g_strfreev (split);

  /* Check if it's an IPv6 host. */

  if (strchr (string, ':'))
    {
      int colons;
      const char *truncate;

      host = string;

      truncate = strstr (host, "::");
      if (truncate && truncate[2] == ':')
        /* :::. */
        return 1;
      if (truncate && strstr (truncate + 2 , "::"))
        /* Multiple ::'s. */
        return 1;

      colons = 0;
      while (*host && (isxdigit (*host) || *host == ':'))
        {
          if (*host == ':')
            colons++;
          host++;
        }
      if (((truncate == NULL) && (colons != 7))
          || (truncate && (colons > 7)))
        /* Wrong number of groups. */
        return 1;
      while (*host && isspace (*host))
        host++;
      if (*host)
        return 1;
    }

  return 0;

 free_fail:
  g_strfreev (split);
  return 1;
}

/**
 * @brief Return number of hosts described by a hosts string.
 *
 * @param[in]  given_hosts  String describing hosts.
 *
 * @return Number of hosts, or -1 on error.
 */
int
manage_max_hosts (const char *given_hosts)
{
  long count = 0;
  gchar **split, **point, *hosts, *hosts_start;

  /* Treat newlines like commas. */
  hosts = hosts_start = g_strdup (given_hosts);
  while (*hosts)
    {
      if (*hosts == '\n') *hosts = ',';
      hosts++;
    }

  split = g_strsplit (hosts_start, ",", 0);
  g_free (hosts_start);
  point = split;

  while (*point)
    {
      gchar *slash, *hyphen;
      slash = strchr (*point, '/');
      hyphen = strchr (*point, '-');
      if (slash)
        {
          gchar *first;

          if (hyphen)
            /* Range and netmask. */
            return -1;

          first = *point;
          while (*first && isspace (*first)) first++;
          /** @todo Check if any char is alpha (e.g. 0abc/24). */
          if (*first && (isalpha (*first) || (first == slash)))
            /* Hostname with netmask, or empty hostname. */
            return -1;

          slash++;
          if (*slash)
            {
              long int mask;
              struct in_addr addr;

              if (strchr (*point, ':'))
                /* IPv6.  Scanner current only supports single addresses. */
                return -1;
              else
                {
                  gchar **host_split, **host_point;

                  /* IPv4. */

                  /* Check the octets are in range. */

                  host_split = g_strsplit (*point, ".", 0);
                  host_point = host_split;
                  while (*host_point)
                    {
                      if ((strlen (*host_point) == 0)
                          || (**host_point == '/'))
                        {
                          g_strfreev (host_split);
                          return -1;
                        }
                      if ((atoi (*host_point) < 0)
                          || (atoi (*host_point) > 255))
                        {
                          g_strfreev (host_split);
                          return -1;
                        }
                      host_point++;
                    }
                  g_strfreev (host_split);

                  /* Convert text after slash to a bit netmask. */

                  if (strchr (slash, '.')
                      && (atoi (slash) > 32)
                      && inet_aton (slash, &addr))
                    {
                      in_addr_t haddr;

                      /* 192.168.200.0/255.255.255.252 */

                      haddr = ntohl (addr.s_addr);
                      mask = 32;
                      while ((haddr & 1) == 0)
                        {
                          mask--;
                          haddr = haddr >> 1;
                        }
                      if (mask < 8 || mask > 32) return -1;
                    }
                  else
                    {
                      /* 192.168.200.0/30 */

                      errno = 0;
                      mask = strtol (slash, NULL, 10);
                      if (errno == ERANGE || mask < 8 || mask > 32) return -1;
                    }

                  /* Calculate number of hosts. */

                  count += 1L << (32 - mask);
                  /* Leave out the network and broadcast addresses. */
                  if (mask < 31) count--;
                }
            }
          else
            /* Just a trailing /. */
            count++;
        }
      else if (hyphen)
        {
          hyphen++;

          if (strchr (*point, ':'))
            /* IPv6.  Scanner current only supports single addresses. */
            return -1;

          if (*hyphen && (contains_alpha (*point)))
            {
              /* A hostname. */
              if (validate_host (*point))
                return -1;
              count++;
            }
          else if (*hyphen)
            {
              int dot_count, total_dot_count;
              const gchar* dot;

              /* An address specifying a range. */

              if (strchr (hyphen, '-'))
                /* Multiple ranges. */
                return -1;

              if ((hyphen - 1) == *point)
                /* Leading hyphen. */
                return -1;

              dot_count = 0;
              dot = hyphen;
              while ((dot = strchr (dot, '.')))
                dot++, dot_count++;

              dot_count = 0;
              dot = hyphen;
              while ((dot = strchr (dot, '.')))
                dot++, dot_count++;

              total_dot_count = 0;
              dot = *point;
              while ((dot = strchr (dot, '.')))
                dot++, total_dot_count++;

              if (total_dot_count == 6)
                {
                  int one, two, subcount;
                  char *pos_one, *pos_two;

                  /* 192.168.1.102-192.168.1.104 */

                  pos_one = *point;
                  pos_two = hyphen;
                  subcount = 0;

                  /* First. */

                  if (*pos_one == '.')
                    return -1;
                  one = atoi (pos_one);
                  if ((one < 0) || (one > 255))
                    return -1;
                  if (*pos_two == '.')
                    return -1;
                  two = atoi (pos_two);
                  if ((two < 0) || (two > 255))
                    return -1;

                  if (one > two)
                    return -1;
                  if (one < two)
                    subcount += (two - one + 1) * 256 * 256 * 255;

                  /* Second. */

                  pos_one = strchr (pos_one, '.');
                  pos_one++;

                  pos_two = strchr (pos_two, '.');
                  pos_two++;

                  if (*pos_one == '.')
                    return -1;
                  one = atoi (pos_one);
                  if ((one < 0) || (one > 255))
                    return -1;
                  if (*pos_two == '.')
                    return -1;
                  two = atoi (pos_two);
                  if ((two < 0) || (two > 255))
                    return -1;

                  if (one > two)
                    return -1;
                  if (one < two)
                    subcount += (two - one + 1) * 256 * 255;

                  /* Third. */

                  pos_one = strchr (pos_one, '.');
                  pos_one++;

                  pos_two = strchr (pos_two, '.');
                  pos_two++;

                  if (*pos_one == '.')
                    return -1;
                  one = atoi (pos_one);
                  if ((one < 0) || (one > 255))
                    return -1;
                  if (*pos_two == '.')
                    return -1;
                  two = atoi (pos_two);
                  if ((two < 0) || (two > 255))
                    return -1;

                  if (one > two)
                    return -1;
                  if (one < two)
                    subcount += (two - one + 1) * 255;

                  /* Fourth. */

                  pos_one = strchr (pos_one, '.');
                  pos_one++;
                  if (*pos_one == '-')
                    /* Empty octet. */
                    return -1;

                  pos_two = strchr (pos_two, '.');
                  pos_two++;
                  if (*pos_two == '\0')
                    /* Trailing dot. */
                    return -1;

                  one = atoi (pos_one);
                  if ((one < 0) || (one > 255))
                    return -1;
                  two = atoi (pos_two);
                  if ((two < 0) || (two > 255))
                    return -1;

                  if (one > two)
                    return -1;
                  if (one < two)
                    subcount += (two - one + 1);

                  count += subcount;
                }
              else if (total_dot_count == 3)
                {
                  int start, end, number;
                  gchar *two;

                  /* 192.168.1.102-104 */

                  if (**point == '.')
                    return -1;
                  number = atoi (*point);
                  if ((number < 0) || (number > 255))
                    return -1;

                  two = strchr (*point, '.') + 1;
                  if (*two == '.')
                    return -1;
                  number = atoi (two);
                  if ((number < 0) || (number > 255))
                    return -1;

                  if (*(strchr (two, '.') + 1) == '.')
                    return -1;
                  number = atoi (strchr (two, '.') + 1);
                  if ((number < 0) || (number > 255))
                    return -1;

                  end = atoi (hyphen);
                  if ((end <= 0) || (end > 255))
                    return -1;

                  dot = strbchr (*point, hyphen, '.');
                  dot = dot ? (dot + 1) : *point;
                  if (*dot == '-')
                    return -1;
                  start = atoi (dot);
                  if ((start < 0) || (start > 255))
                    return -1;

                  if (end < start)
                    {
                      int tem = end;
                      end = start;
                      start = tem;
                    }

                  if (end - start > 255)
                    return -1;

                  if (start == end)
                    count++;
                  else
                    count += (end - start + 1);
                }
              else
                {
                  /* 192.168-169.1.102-104 or 192.102-104 */
                  return -1;
                }
            }
          else
            /* A trailing -. */
            return -1;
        }
      else
        {
          char *host;
          /* Count over empty elements. */
          host = *point;
          while (*host && isspace (*host)) host++;
          if (*host)
            {
              if (validate_host (host))
                return -1;
              count++;
            }
        }
      point += 1;
    }
  return count;
}

/**
 * @brief Trim leading and trailing space from a hosts string.
 *
 * @param[in]  string  String.  May be modified.
 *
 * @return Either string or some address within string.
 */
static gchar *
trim_hosts (gchar *string)
{
  gchar *host, *end;

  /* Trim leading and trailing space. */
  host = string;
  while ((*host == ' ') || (*host == '\t'))
    host++;
  end = host;
  while (*end)
    {
      if ((*end == ' ') || (*end == '\t'))
        {
          *end = '\0';
          break;
        }
      end++;
    }
  return host;
}

/**
 * @brief Clean a hosts string.
 *
 * @param[in]  given_hosts  String describing hosts.
 * @param[out] max          Max number of hosts, adjusted for duplicates.
 *
 * @return Freshly allocated new hosts string, or NULL on error.
 */
gchar*
clean_hosts (const char *given_hosts, int *max)
{
  array_t *clean_array;
  GString *clean;
  gchar **split, **point, *hosts, *hosts_start, *host;
  guint index;

  /* Treat newlines like commas. */
  hosts = hosts_start = g_strdup (given_hosts);
  while (*hosts)
    {
      if (*hosts == '\n') *hosts = ',';
      hosts++;
    }

  split = g_strsplit (hosts_start, ",", 0);
  g_free (hosts_start);
  point = split;

  if ((point == NULL) || (*point == NULL))
    {
      g_strfreev (split);
      return g_strdup ("");
    }

  clean_array = make_array ();
  while (*point)
    {
      host = trim_hosts (*point);

      if (*host)
        {
          /* Prevent simple duplicates. */
          if (array_find_string (clean_array, host) == NULL)
            array_add (clean_array, host);
          else if (max)
            (*max)--;
        }

      point += 1;
    }

  clean = g_string_new ("");

  host = (gchar*) g_ptr_array_index (clean_array, 0);
  if (host)
    g_string_append_printf (clean, "%s", host);

  for (index = 1; index < clean_array->len; index++)
    {
      host = (gchar*) g_ptr_array_index (clean_array, index);
      if (host)
        g_string_append_printf (clean, ", %s", host);
    }

  return g_string_free (clean, FALSE);
}

/**
 * @brief Start a new IMMEDIATE transaction.
 */
void
manage_transaction_start ()
{
  if (!in_transaction)
    {
      sql ("BEGIN IMMEDIATE;");
      in_transaction = TRUE;
    }
  gettimeofday (&last_msg, NULL);
}

/**
 * @brief Commit the current transaction, if any.
 *
 * The algorithm is extremely naive (time elapsed since the last message
 * was received) but delivers good enough performances when facing
 * bursts of messages.
 *
 * @param[in] force_commit  Force committing the pending transaction.
 */
void manage_transaction_stop (gboolean force_commit)
{
  struct timeval now;

  if (!in_transaction)
    return;

  gettimeofday (&now, NULL);
  if (force_commit || TIMEVAL_SUBTRACT_MS (now, last_msg) >= 500)
    {
      sql ("COMMIT;");
      in_transaction = FALSE;
    }
}

/**
 * @brief Validate a single port.
 *
 * @param[in]   port      A port.
 *
 * @return 0 success, 1 failed.
 */
static int
validate_port (const char *port)
{
  const char *first;

  while (*port && isblank (*port)) port++;
  if (*port == '\0')
    return 1;

  first = port;
  while (*first && isdigit (*first)) first++;
  if (first == port)
    return 1;

  while (*first && isblank (*first)) first++;
  if (*first == '\0')
    {
      long int number;
      number = strtol (port, NULL, 10);
      if (number <= 0)
        return 1;
      if (number > 65535)
        return 1;
      return 0;
    }
  return 1;
}

/**
 * @brief Validate a single port.
 * @brief May come in values such as 100/foo and 100/foo (IANA: bar).
 * @brief Will also validate values such as: general/tcp.
 *
 * @param[in]   port      A port.
 *
 * @return 0 success, 1 failed.
 */
static int
validate_results_port (const char *port)
{
  int num;
  char *buff;

  if (!port)
    return 1;

  if (strncmp ("general/", port, 8) == 0)
    return 0;

  num = atoi (port);
  if (num > 0 && num < 65535)
    return 0;

  buff = g_newa (char, strlen (port));
  sscanf (port, "%s (%i/%s)", buff, &num, buff);
  if (num > 0 && num < 65535)
    return 0;

  return 1;
}

/**
 * @brief Validate an OMP port range string.
 *
 * OTP accepts "-100,103,200-1024,60000-" or "T:-100,103,U:6000-.
 *
 * OMP accepts "103,U:200-1024,3000-4000,T:3-4,U:7".
 *
 * @param[in]   port_range  A port range.
 *
 * @return 0 success, 1 failed.
 */
static int
validate_port_range (const char* port_range)
{
  gchar **split, **point, *range, *range_start;

  if (strcmp (port_range, "default") == 0)
    return 0;

  while (*port_range && isblank (*port_range)) port_range++;
  if (strcmp (port_range, "") == 0)
    return 1;

  /* Treat newlines like commas. */
  range = range_start = g_strdup (port_range);
  while (*range)
    {
      if (*range == '\n') *range = ',';
      range++;
    }

  split = g_strsplit (range_start, ",", 0);
  g_free (range_start);
  point = split;

  while (*point)
    {
      gchar *hyphen, *element;

      /* Strip off any outer whitespace. */

      element = g_strstrip (*point);

      /* Strip off any leading type specifier. */

      if ((strlen (element) >= 2)
          && ((element[0] == 'T') || (element[0] == 'U'))
          && (element[1] == ':'))
        element = element + 2;

      /* Look for a hyphen. */

      hyphen = strchr (element, '-');
      if (hyphen)
        {
          long int number1, number2;
          const char *first;
          char *end;

          hyphen++;

          /* Check the first number. */

          first = element;
          while (*first && isblank (*first)) first++;
          if (*first == '-')
            goto fail;

          errno = 0;
          number1 = strtol (first, &end, 10);
          while (*end && isblank (*end)) end++;
          if (errno || (*end != '-'))
            goto fail;
          if (number1 == 0)
            goto fail;
          if (number1 > 65535)
            goto fail;

          /* Check the second number. */

          while (*hyphen && isblank (*hyphen)) hyphen++;
          if (*hyphen == '\0')
            goto fail;

          errno = 0;
          number2 = strtol (hyphen, &end, 10);
          while (*end && isblank (*end)) end++;
          if (errno || *end)
            goto fail;
          if (number2 == 0)
            goto fail;
          if (number2 > 65535)
            goto fail;

          if (number1 > number2)
            goto fail;
        }
      else
        {
          long int number;
          const char *only;
          char *end;

          /* Check the single number. */

          only = element;
          while (*only && isblank (*only)) only++;
          /* Empty ranges are OK. */
          if (*only)
            {
              errno = 0;
              number = strtol (only, &end, 10);
              while (*end && isblank (*end)) end++;
              if (errno || *end)
                goto fail;
              if (number == 0)
                goto fail;
              if (number > 65535)
                goto fail;
            }
        }
      point += 1;
    }

  g_strfreev (split);
  return 0;

 fail:
  g_strfreev (split);
  return 1;
}

/**
 * @brief Create a target.
 *
 * The \param hosts and \param target_locator parameters are mutually
 * exclusive, if target_locator is not NULL, always try to import from source.
 *
 * @param[in]   name            Name of target.
 * @param[in]   hosts           Host list of target.
 * @param[in]   comment         Comment on target.
 * @param[in]   port_list_id    Port list of target (overrides \p port_range).
 * @param[in]   port_range      Port range of target.
 * @param[in]   ssh_lsc_credential  SSH LSC credential.
 * @param[in]   ssh_port        Port for SSH LSC login.
 * @param[in]   smb_lsc_credential  SMB LSC credential.
 * @param[in]   target_locator  Name of target_locator to import target(s)
 *                              from.
 * @param[in]   username        Username to authenticate with against source.
 * @param[in]   password        Password for user \p username.
 * @param[in]   make_name_unique  Whether to make name unique.
 * @param[out]  target          Created target.
 *
 * @return 0 success, 1 target exists already, 2 error in host specification,
 *         3 too many hosts, 4 error in port range, 5 error in SSH port,
 *         6 failed to find port list, -1 if import from target locator failed
 *         or response was empty.
 */
int
create_target (const char* name, const char* hosts, const char* comment,
               const char* port_list_id, const char* port_range,
               lsc_credential_t ssh_lsc_credential, const char* ssh_port,
               lsc_credential_t smb_lsc_credential, const char* target_locator,
               const char* username, const char* password,
               int make_name_unique, target_t* target)
{
  gchar *quoted_name, *quoted_hosts, *quoted_comment, *quoted_ssh_port;
  gchar *port_list_comment;
  port_list_t port_list;
  int ret;

  if (port_range == NULL)
    port_range = "default";

  if (validate_port_range (port_range))
    return 4;

  if (ssh_port && validate_port (ssh_port))
    return 5;

  sql ("BEGIN IMMEDIATE;");

  assert (current_credentials.uuid);

  if (make_name_unique)
    {
      int suffix;
      /* Ensure the name is unique. */
      quoted_name = sql_quote (name);
      suffix = 1;
      while (sql_int (0, 0,
                      "SELECT COUNT(*) FROM targets"
                       " WHERE name = '%s'"
                       " AND ((owner IS NULL) OR (owner ="
                       " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                       quoted_name,
                       current_credentials.uuid))
        {
          gchar *new_name;
          g_free (quoted_name);
          new_name = g_strdup_printf ("%s %i", name, suffix++);
          quoted_name = sql_quote (new_name);
          g_free (new_name);
        }
    }
  else
    {
      /* Check whether a target with the same name exists already. */
      quoted_name = sql_quote (name);
      if (sql_int (0, 0,
                   "SELECT COUNT(*) FROM targets"
                   " WHERE name = '%s'"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                   quoted_name,
                   current_credentials.uuid))
        {
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return 1;
        }
    }

  /* Import targets from target locator. */
  if (target_locator != NULL)
    {
      int max;
      gchar *clean;
      GSList* hosts_list = resource_request_resource (target_locator,
                                                      RESOURCE_TYPE_TARGET,
                                                      username ? username : "",
                                                      password ? password : "");

      if (hosts_list == NULL)
        {
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return -1;
        }

      gchar* import_hosts = openvas_string_flatten_string_list (hosts_list,
                                                                ", ");

      openvas_string_list_free (hosts_list);
      max = manage_max_hosts (import_hosts);
      if (max <= 0)
        {
          g_free (import_hosts);
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return 2;
        }
      clean = clean_hosts (import_hosts, &max);
      if (max > MANAGE_MAX_HOSTS)
        {
          g_free (import_hosts);
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return 3;
        }
      g_free (import_hosts);
      quoted_hosts = sql_quote (clean);
      g_free (clean);
    }
  else
    {
      int max;
      gchar *clean;

      /* User provided hosts. */

      max = manage_max_hosts (hosts);
      if (max <= 0)
        {
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return 2;
        }
      clean = clean_hosts (hosts, &max);
      if (max > MANAGE_MAX_HOSTS)
        {
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return 3;
        }
      quoted_hosts = sql_quote (clean);
      g_free (clean);
    }

  if (port_list_id)
    {
      if (find_port_list (port_list_id, &port_list)
          || (port_list == 0))
        {
          g_free (quoted_name);
          return 6;
        }
    }
  else
    {
      port_list_comment = g_strdup_printf ("Autogenerated for target %s.", name);
      ret = create_port_list_unique (name, port_list_comment, port_range,
                                     &port_list);
      g_free (port_list_comment);
      if (ret)
        {
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return ret;
        }
    }

  if (ssh_lsc_credential)
    quoted_ssh_port = sql_insert (ssh_port ? ssh_port : "22");
  else
    quoted_ssh_port = g_strdup ("NULL");

  if (comment)
    {
      quoted_comment = sql_nquote (comment, strlen (comment));
      sql ("INSERT INTO targets"
           " (uuid, name, owner, hosts, comment, lsc_credential,"
           "  ssh_port, smb_lsc_credential, port_range, creation_time,"
           "  modification_time)"
           " VALUES (make_uuid (), '%s',"
           " (SELECT ROWID FROM users WHERE users.uuid = '%s'),"
           " '%s', '%s', %llu, %s, %llu, %llu, now (), now ());",
           quoted_name, current_credentials.uuid, quoted_hosts, quoted_comment,
           ssh_lsc_credential, quoted_ssh_port, smb_lsc_credential,
           port_list);
      g_free (quoted_comment);
    }
  else
    sql ("INSERT INTO targets"
         " (uuid, name, owner, hosts, comment, lsc_credential,"
         "  ssh_port, smb_lsc_credential, port_range, creation_time,"
         "  modification_time)"
         " VALUES (make_uuid (), '%s',"
         " (SELECT ROWID FROM users WHERE users.uuid = '%s'),"
         " '%s', '', %llu, %s, %llu, %llu, now (), now ());",
         quoted_name, current_credentials.uuid, quoted_hosts,
         ssh_lsc_credential, quoted_ssh_port, smb_lsc_credential,
         port_list);

  if (target)
    *target = sqlite3_last_insert_rowid (task_db);

  g_free (quoted_name);
  g_free (quoted_hosts);
  g_free (quoted_ssh_port);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Create a target from an existing target.
 *
 * @param[in]  name        Name of new target.  NULL to copy from existing.
 * @param[in]  comment     Comment on new target.  NULL to copy from existing.
 * @param[in]  target_id   UUID of existing target.
 * @param[out] new_target  New target.
 *
 * @return 0 success, 1 target exists already, 2 failed to find existing
 *         target, -1 error.
 */
int
copy_target (const char* name, const char* comment, const char *target_id,
             target_t* new_target)
{
  gchar *quoted_name, *quoted_uuid, *uniquify;
  user_t owner;

  assert (current_credentials.uuid);

  if (target_id == NULL)
    return -1;

  sql ("BEGIN IMMEDIATE;");

  if (find_user (current_credentials.username, &owner)
      || owner == 0)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (name && strlen (name))
    {
      quoted_name = sql_quote (name);
      if (sql_int (0, 0,
                   "SELECT COUNT(*) FROM targets WHERE name = '%s'"
                   " AND ((owner IS NULL) OR (owner = %llu));",
                   quoted_name,
                   owner))
        {
          sql ("ROLLBACK;");
          g_free (quoted_name);
          return 1;
        }
    }
  else
    quoted_name = NULL;

  quoted_uuid = sql_quote (target_id);
  if (sql_int (0, 0,
               "SELECT COUNT(*) FROM targets"
               " WHERE uuid = '%s'"
               " AND ((owner IS NULL) OR (owner = %llu))",
               quoted_uuid,
               owner)
      == 0)
    {
      sql ("ROLLBACK;");
      g_free (quoted_name);
      return 2;
    }

  /* Copy the existing target. */

  uniquify = g_strdup_printf ("uniquify ('target', name, %llu, ' Clone')",
                              owner);
  if (comment && strlen (comment))
    {
      gchar *quoted_comment;
      quoted_comment = sql_nquote (comment, strlen (comment));
      sql ("INSERT INTO targets"
           " (uuid, owner, name, comment, hosts, lsc_credential, ssh_port,"
           "  smb_lsc_credential, port_range, creation_time,"
           "  modification_time)"
           " SELECT make_uuid (), %llu, %s%s%s, '%s', hosts, lsc_credential,"
           " ssh_port, smb_lsc_credential, port_range, now (), now ()"
           " FROM targets WHERE uuid = '%s';",
           owner,
           quoted_name ? "'" : "",
           quoted_name
            ? quoted_name
            : "uniquify ('target', name, owner, ' Clone')",
           quoted_name ? "'" : "",
           quoted_comment,
           quoted_uuid);
      g_free (quoted_comment);
    }
  else
    sql ("INSERT INTO targets"
         " (uuid, owner, name, comment, hosts, lsc_credential, ssh_port,"
         "  smb_lsc_credential, port_range, creation_time,"
         "  modification_time)"
         " SELECT make_uuid (), %llu, %s%s%s, comment, hosts, lsc_credential,"
         " ssh_port, smb_lsc_credential, port_range, now (), now ()"
         " FROM targets WHERE uuid = '%s';",
         owner,
         quoted_name ? "'" : "",
         quoted_name ? quoted_name : uniquify,
         quoted_name ? "'" : "",
         quoted_uuid);

  if (new_target)
    *new_target = sqlite3_last_insert_rowid (task_db);

  sql ("COMMIT;");
  g_free (quoted_uuid);
  g_free (quoted_name);
  g_free (uniquify);
  return 0;
}

/**
 * @brief Delete a target.
 *
 * @param[in]  target_id  UUID of target.
 * @param[in]  ultimate   Whether to remove entirely, or to trashcan.
 *
 * @return 0 success, 1 fail because a task refers to the target, 2 failed
 *         to find target, 3 predefined target, -1 error.
 */
int
delete_target (const char *target_id, int ultimate)
{
  target_t target = 0;

  if (strcmp (target_id, TARGET_UUID_LOCALHOST) == 0)
    return 3;

  sql ("BEGIN IMMEDIATE;");

  if (find_target (target_id, &target))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (target == 0)
    {
      if (find_trash ("target", target_id, &target))
        {
          sql ("ROLLBACK;");
          return -1;
        }
      if (target == 0)
        {
          sql ("ROLLBACK;");
          return 2;
        }
      if (ultimate == 0)
        {
          /* It's already in the trashcan. */
          sql ("COMMIT;");
          return 0;
        }

      /* Check if it's in use by a task in the trashcan. */
      if (sql_int (0, 0,
                   "SELECT count(*) FROM tasks"
                   " WHERE target = %llu"
                   " AND target_location = " G_STRINGIFY (LOCATION_TRASH) ";",
                   target))
        {
          sql ("ROLLBACK;");
          return 1;
        }

      sql ("DELETE FROM targets_trash WHERE ROWID = %llu;", target);
      sql ("COMMIT;");
      return 0;
    }

  if (ultimate == 0)
    {
      if (sql_int (0, 0,
                   "SELECT count(*) FROM tasks"
                   " WHERE target = %llu"
                   " AND target_location = " G_STRINGIFY (LOCATION_TABLE)
                   " AND (hidden = 0 OR hidden = 1);",
                   target))
        {
          sql ("ROLLBACK;");
          return 1;
        }

      sql ("INSERT INTO targets_trash"
           " (uuid, owner, name, hosts, comment, lsc_credential, ssh_port,"
           "  smb_lsc_credential, port_range, ssh_location, smb_location,"
           "  port_list_location, creation_time, modification_time)"
           " SELECT uuid, owner, name, hosts, comment, lsc_credential, ssh_port,"
           "        smb_lsc_credential, port_range, "
           "      " G_STRINGIFY (LOCATION_TABLE) ","
           "      " G_STRINGIFY (LOCATION_TABLE) ","
           "      " G_STRINGIFY (LOCATION_TABLE) ","
           "      creation_time, modification_time"
           " FROM targets WHERE ROWID = %llu;",
           target);

      /* Update the location of the target in any trashcan tasks. */
      sql ("UPDATE tasks"
           " SET target = %llu,"
           "     target_location = " G_STRINGIFY (LOCATION_TRASH)
           " WHERE target = %llu"
           " AND target_location = " G_STRINGIFY (LOCATION_TABLE) ";",
           sqlite3_last_insert_rowid (task_db),
           target);
    }
  else if (sql_int (0, 0,
           "SELECT count(*) FROM tasks"
           " WHERE target = %llu"
           " AND target_location = " G_STRINGIFY (LOCATION_TABLE),
           target))
    {
      sql ("ROLLBACK;");
      return 1;
    }

  sql ("DELETE FROM targets WHERE ROWID = %llu;", target);

  sql ("COMMIT;");
  return 0;
}

/**
 * @brief Modify a target.
 *
 * The \param hosts and \param target_locator parameters are mutually
 * exclusive, if target_locator is not NULL, always try to import from source.
 *
 * @param[in]   target_id       UUID of target.
 * @param[in]   name            Name of target.
 * @param[in]   hosts           Host list of target.
 * @param[in]   comment         Comment on target.
 * @param[in]   port_list_id    Port list of target (overrides \p port_range).
 * @param[in]   ssh_lsc_credential_id  SSH LSC credential.
 * @param[in]   ssh_port        Port for SSH LSC login.
 * @param[in]   smb_lsc_credential_id  SMB LSC credential.
 * @param[in]   target_locator  Name of target_locator to import target(s)
 *                              from.
 * @param[in]   username        Username to authenticate with against source.
 * @param[in]   password        Password for user \p username.
 *
 * @return 0 success, 1 target exists already, 2 error in host specification,
 *         3 too many hosts, 4 error in port range, 5 error in SSH port,
 *         6 failed to find port list, 7 failed to find SSH cred, 8 failed to
 *         find SMB cred, 9 failed to find target, -1 if import from target
 *         locator failed or response was empty FIX or internal error.
 */
int
modify_target (const char *target_id, const char *name, const char *hosts,
               const char *comment, const char *port_list_id,
               const char *ssh_lsc_credential_id, const char *ssh_port,
               const char *smb_lsc_credential_id,
               const char *target_locator, const char *username,
               const char *password)
{
  gchar *quoted_name, *quoted_hosts, *quoted_comment, *quoted_ssh_port;
  port_list_t port_list;
  target_t target;
  lsc_credential_t ssh_lsc_credential, smb_lsc_credential;

  assert (target_id);
  assert (port_list_id);
  assert (name);

  sql ("BEGIN IMMEDIATE;");

  assert (current_credentials.uuid);

  target = 0;
  port_list = 0;
  if (find_target (target_id, &target)
      || find_port_list (port_list_id, &port_list))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (target == 0)
    {
      sql ("ROLLBACK;");
      return 9;
    }

  if (port_list == 0)
    {
      sql ("ROLLBACK;");
      return 6;
    }

  ssh_lsc_credential = 0;
  if (ssh_lsc_credential_id && strcmp (ssh_lsc_credential_id, "0"))
    {
      if (find_lsc_credential (ssh_lsc_credential_id, &ssh_lsc_credential))
        {
          sql ("ROLLBACK;");
          return -1;
        }

      if (ssh_lsc_credential == 0)
        {
          sql ("ROLLBACK;");
          return 7;
        }

      if (ssh_port && validate_port (ssh_port))
        {
          sql ("ROLLBACK;");
          return 5;
        }
    }

  smb_lsc_credential = 0;
  if (smb_lsc_credential_id && strcmp (smb_lsc_credential_id, "0"))
    {
      if (find_lsc_credential (smb_lsc_credential_id, &smb_lsc_credential))
        {
          sql ("ROLLBACK;");
          return -1;
        }

      if (smb_lsc_credential == 0)
        {
          sql ("ROLLBACK;");
          return 7;
        }
    }

  /* Check whether a target with the same name exists already. */
  quoted_name = sql_quote (name);
  if (sql_int (0, 0,
               "SELECT COUNT(*) FROM targets"
               " WHERE name = '%s'"
               " AND ROWID != %llu"
               " AND ((owner IS NULL) OR (owner ="
               " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
               quoted_name,
               target,
               current_credentials.uuid))
    {
      g_free (quoted_name);
      sql ("ROLLBACK;");
      return 1;
    }

  /* Import targets from target locator. */
  if (target_locator != NULL)
    {
      int max;
      gchar *clean;
      GSList* hosts_list = resource_request_resource (target_locator,
                                                      RESOURCE_TYPE_TARGET,
                                                      username ? username : "",
                                                      password ? password : "");

      if (hosts_list == NULL)
        {
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return -1;
        }

      gchar* import_hosts = openvas_string_flatten_string_list (hosts_list,
                                                                ", ");

      openvas_string_list_free (hosts_list);
      max = manage_max_hosts (import_hosts);
      if (max <= 0)
        {
          g_free (import_hosts);
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return 2;
        }
      clean = clean_hosts (import_hosts, &max);
      if (max > MANAGE_MAX_HOSTS)
        {
          g_free (import_hosts);
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return 3;
        }
      g_free (import_hosts);
      quoted_hosts = sql_quote (clean);
      g_free (clean);
    }
  else
    {
      int max;
      gchar *clean;

      /* User provided hosts. */

      max = manage_max_hosts (hosts);
      if (max <= 0)
        {
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return 2;
        }
      clean = clean_hosts (hosts, &max);
      if (max > MANAGE_MAX_HOSTS)
        {
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return 3;
        }
      quoted_hosts = sql_quote (clean);
      g_free (clean);
    }

  if (ssh_lsc_credential)
    quoted_ssh_port = sql_insert (ssh_port ? ssh_port : "22");
  else
    quoted_ssh_port = g_strdup ("NULL");

  if (comment)
    {
      quoted_comment = sql_quote (comment);
      sql ("UPDATE targets SET"
           " name = '%s',"
           " hosts = '%s',"
           " comment = '%s',"
           " lsc_credential = %llu,"
           " ssh_port = %s,"
           " smb_lsc_credential = %llu,"
           " port_range = %llu,"
           " modification_time = now ()"
           " WHERE ROWID = %llu;",
           quoted_name, quoted_hosts, quoted_comment, ssh_lsc_credential,
           quoted_ssh_port, smb_lsc_credential, port_list, target);
      g_free (quoted_comment);
    }
  else
    sql ("UPDATE targets SET"
         " name = '%s',"
         " hosts = '%s',"
         " lsc_credential = %llu,"
         " ssh_port = %s,"
         " smb_lsc_credential = %llu,"
         " port_range = %llu,"
         " modification_time = now ()"
         " WHERE ROWID = %llu;",
         quoted_name, quoted_hosts, ssh_lsc_credential, quoted_ssh_port,
         smb_lsc_credential, port_list, target);

  g_free (quoted_name);
  g_free (quoted_hosts);
  g_free (quoted_ssh_port);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Filter columns for target iterator.
 */
#define TARGET_ITERATOR_FILTER_COLUMNS                                         \
 { GET_ITERATOR_FILTER_COLUMNS, "hosts", "ips", "port_list", "ssh_credential", \
   "smb_credential", NULL }

/**
 * @brief Target iterator columns.
 */
#define TARGET_ITERATOR_COLUMNS                             \
  GET_ITERATOR_COLUMNS ", hosts, lsc_credential,"           \
  " ssh_port, smb_lsc_credential, port_range, 0, 0,"        \
  " (SELECT uuid FROM port_lists"                           \
  "  WHERE port_lists.ROWID = port_range),"                 \
  " (SELECT name FROM port_lists"                           \
  "  WHERE port_lists.ROWID = port_range)"                  \
  " AS port_list,"                                          \
  " 0,"                                                     \
  " (SELECT name FROM lsc_credentials"                      \
  "  WHERE lsc_credentials.ROWID = lsc_credential)"         \
  " AS ssh_credential,"                                     \
  " (SELECT name FROM lsc_credentials"                      \
  "  WHERE lsc_credentials.ROWID = smb_lsc_credential)"     \
  " AS smb_credential,"                                     \
  " hosts,"                                                 \
  " max_hosts (hosts) AS ips"

/**
 * @brief Target iterator columns for trash case.
 */
#define TARGET_ITERATOR_TRASH_COLUMNS                         \
  GET_ITERATOR_COLUMNS ", hosts, lsc_credential,"             \
  " ssh_port, smb_lsc_credential, port_range, ssh_location,"  \
  " smb_location,"                                            \
  " (CASE"                                                    \
  "  WHEN port_list_location = " G_STRINGIFY (LOCATION_TRASH) \
  "  THEN (SELECT uuid FROM port_lists_trash"                 \
  "        WHERE port_lists_trash.ROWID = port_range)"        \
  "  ELSE (SELECT uuid FROM port_lists"                       \
  "        WHERE port_lists.ROWID = port_range)"              \
  "  END),"                                                   \
  " (CASE"                                                    \
  "  WHEN port_list_location = " G_STRINGIFY (LOCATION_TRASH) \
  "  THEN (SELECT name FROM port_lists_trash"                 \
  "        WHERE port_lists_trash.ROWID = port_range)"        \
  "  ELSE (SELECT name FROM port_lists"                       \
  "        WHERE port_lists.ROWID = port_range)"              \
  "  END),"                                                   \
  " port_list_location = " G_STRINGIFY (LOCATION_TRASH)

/**
 * @brief Count number of targets.
 *
 * @param[in]  get  GET params.
 *
 * @return Total number of targets in filtered set.
 */
int
target_count (const get_data_t *get)
{
  static const char *extra_columns[] = TARGET_ITERATOR_FILTER_COLUMNS;
  return count ("target", get, TARGET_ITERATOR_COLUMNS, extra_columns, 0, 0, 0,
                TRUE);
}

/**
 * @brief Initialise a target iterator, limited to the current user's targets.
 *
 * @param[in]  iterator    Iterator.
 * @param[in]  target      Target to limit iteration to.  0 for all.
 * @param[in]  trash       Whether to iterate over trashcan targets.
 * @param[in]  filter      Filter term.
 * @param[in]  first       First target.
 * @param[in]  max         Maximum number of targets returned.
 */
void
init_user_target_iterator (iterator_t* iterator, target_t target, int trash,
                           const char *filter, int first, int max)
{
  static const char *filter_columns[] = TARGET_ITERATOR_FILTER_COLUMNS;
  get_data_t get;
  memset (&get, '\0', sizeof (get));
  get.trash = trash;
  get.filter = (char*) filter;
  init_user_get_iterator (iterator, "target", &get, TARGET_ITERATOR_COLUMNS,
                          TARGET_ITERATOR_TRASH_COLUMNS, filter_columns,
                          target, 0, 0, 0);
}

/**
 * @brief Initialise a target iterator, including observed targets.
 *
 * @param[in]  iterator    Iterator.
 * @param[in]  get         GET data.
 *
 * @return 0 success, 1 failed to find target, 2 failed to find filter,
 *         -1 error.
 */
int
init_target_iterator (iterator_t* iterator, const get_data_t *get)
{
  static const char *filter_columns[] = TARGET_ITERATOR_FILTER_COLUMNS;

  return init_get_iterator (iterator,
                            "target",
                            get,
                            /* Columns. */
                            TARGET_ITERATOR_COLUMNS,
                            /* Columns for trashcan. */
                            TARGET_ITERATOR_TRASH_COLUMNS,
                            filter_columns,
                            NULL,
                            0,
                            NULL,
                            NULL,
                            TRUE);
}

/**
 * @brief Get the target from a target iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Target.
 */
target_t
target_iterator_target (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (target_t) sqlite3_column_int64 (iterator->stmt, 0);
}

/**
 * @brief Get the UUID of the target from a target iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return UUID of the target or NULL if iteration is complete.
 */
DEF_ACCESS (target_iterator_uuid, 1);

/**
 * @brief Get the name of the target from a target iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name of the target or NULL if iteration is complete.
 */
DEF_ACCESS (target_iterator_name, 2);

/**
 * @brief Get the comment from a target iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Comment.
 */
const char*
target_iterator_comment (iterator_t* iterator)
{
  const char *ret;
  if (iterator->done) return "";
  ret = (const char*) sqlite3_column_text (iterator->stmt, 3);
  return ret ? ret : "";
}

/**
 * @brief Get the hosts of the target from a target iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Hosts of the target or NULL if iteration is complete.
 */
DEF_ACCESS (target_iterator_hosts, GET_ITERATOR_COLUMN_COUNT);

/**
 * @brief Get the SSH LSC credential from a target iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return SSH LSC credential.
 */
int
target_iterator_ssh_credential (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (int) sqlite3_column_int (iterator->stmt,
                                  GET_ITERATOR_COLUMN_COUNT + 1);
  return ret;
}

/**
 * @brief Get the SSH LSC port of the target from a target iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return SSH LSC port of the target or NULL if iteration is complete.
 */
DEF_ACCESS (target_iterator_ssh_port, GET_ITERATOR_COLUMN_COUNT + 2);

/**
 * @brief Get the SMB LSC credential from a target iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return SMB LSC credential.
 */
int
target_iterator_smb_credential (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (int) sqlite3_column_int (iterator->stmt,
                                  GET_ITERATOR_COLUMN_COUNT + 3);
  return ret;
}

/**
 * @brief Get the location of the SSH LSC credential from a target iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return 0 in table, 1 in trash
 */
int
target_iterator_ssh_trash (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (int) sqlite3_column_int (iterator->stmt, GET_ITERATOR_COLUMN_COUNT + 5);
  return ret;
}

/**
 * @brief Get the location of the SMB LSC credential from a target iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return 0 in table, 1 in trash
 */
int
target_iterator_smb_trash (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (int) sqlite3_column_int (iterator->stmt,
                                  GET_ITERATOR_COLUMN_COUNT + 6);
  return ret;
}

/**
 * @brief Get the port list uuid of the target from a target iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return UUID of the target port list or NULL if iteration is complete.
 */
DEF_ACCESS (target_iterator_port_list_uuid, GET_ITERATOR_COLUMN_COUNT + 7);

/**
 * @brief Get the port list name of the target from a target iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name of the target port list or NULL if iteration is complete.
 */
DEF_ACCESS (target_iterator_port_list_name, GET_ITERATOR_COLUMN_COUNT + 8);

/**
 * @brief Get the location of the port list from a target iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return 0 in table, 1 in trash.
 */
int
target_iterator_port_list_trash (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (int) sqlite3_column_int (iterator->stmt,
                                  GET_ITERATOR_COLUMN_COUNT + 9);
  return ret;
}

/**
 * @brief Return the UUID of a target.
 *
 * @param[in]  target  Target.
 *
 * @return Newly allocated UUID if available, else NULL.
 */
char*
target_uuid (target_t target)
{
  return sql_string (0, 0,
                     "SELECT uuid FROM targets WHERE ROWID = %llu;",
                     target);
}

/**
 * @brief Return the UUID of a trashcan target.
 *
 * @param[in]  target  Target.
 *
 * @return Newly allocated UUID if available, else NULL.
 */
char*
trash_target_uuid (target_t target)
{
  return sql_string (0, 0,
                     "SELECT uuid FROM targets_trash WHERE ROWID = %llu;",
                     target);
}

/**
 * @brief Return the name of a target.
 *
 * @param[in]  target  Target.
 *
 * @return Newly allocated name if available, else NULL.
 */
char*
target_name (target_t target)
{
  return sql_string (0, 0,
                     "SELECT name FROM targets WHERE ROWID = %llu;",
                     target);
}

/**
 * @brief Return the name of a trashcan target.
 *
 * @param[in]  target  Target.
 *
 * @return Newly allocated name if available, else NULL.
 */
char*
trash_target_name (target_t target)
{
  return sql_string (0, 0,
                     "SELECT name FROM targets_trash WHERE ROWID = %llu;",
                     target);
}

/**
 * @brief Return the hosts associated with a target.
 *
 * @param[in]  target  Target.
 *
 * @return Newly allocated comma separated list of hosts if available,
 *         else NULL.
 */
char*
target_hosts (target_t target)
{
  return sql_string (0, 0,
                     "SELECT hosts FROM targets WHERE ROWID = %llu;",
                     target);
}

/**
 * @brief Return the hosts associated with a trashcan target.
 *
 * @param[in]  target  Target.
 *
 * @return Newly allocated comma separated list of hosts if available,
 *         else NULL.
 */
char*
trash_target_hosts (target_t target)
{
  return sql_string (0, 0,
                     "SELECT hosts FROM targets_trash WHERE ROWID = %llu;",
                     target);
}

/**
 * @brief Return the SSH LSC port of a target.
 *
 * @param[in]  target  Target.
 *
 * @return Newly allocated port if available, else NULL.
 */
char*
target_ssh_port (target_t target)
{
  return sql_string (0, 0,
                     "SELECT ssh_port FROM targets WHERE ROWID = %llu;",
                     target);
}

/**
 * @brief Return the SSH credential associated with a target, if any.
 *
 * @param[in]  target  Target (corresponds to rowid).
 *
 * @return SSH credential if any, else 0.
 */
lsc_credential_t
target_ssh_lsc_credential (target_t target)
{
  lsc_credential_t lsc_credential;

  switch (sql_int64 (&lsc_credential, 0, 0,
                     "SELECT lsc_credential FROM targets"
                     " WHERE ROWID = %llu;",
                     target))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        return 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        /** @todo Move return to arg; return -1. */
        return 0;
        break;
    }
  return lsc_credential;
}

/**
 * @brief Return the SMB credential associated with a target, if any.
 *
 * @param[in]  target  Target (corresponds to rowid).
 *
 * @return SMB credential if any, else 0.
 */
lsc_credential_t
target_smb_lsc_credential (target_t target)
{
  lsc_credential_t lsc_credential;

  switch (sql_int64 (&lsc_credential, 0, 0,
                     "SELECT smb_lsc_credential FROM targets"
                     " WHERE ROWID = %llu;",
                     target))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        return 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        /** @todo Move return to arg; return -1. */
        return 0;
        break;
    }
  return lsc_credential;
}

/**
 * @brief Return the port list associated with a target, if any.
 *
 * @param[in]  target  Target.
 *
 * @return Port list
 */
port_list_t
target_port_list (target_t target)
{
  port_list_t port_list;

  switch (sql_int64 (&port_list, 0, 0,
                     "SELECT port_range FROM targets"
                     " WHERE ROWID = %llu;",
                     target))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        return 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        /** @todo Move return to arg; return -1. */
        return 0;
        break;
    }
  return port_list;
}

/**
 * @brief Return the port range of a target, in OTP format.
 *
 * For "OpenVAS Default", return the explicit port ranges instead of "default".
 *
 * @param[in]  target  Target.
 *
 * @return Newly allocated port range if available, else NULL.
 */
char*
target_port_range (target_t target)
{
  GString *range;
  iterator_t ranges;
  range = g_string_new ("");
  init_port_range_iterator (&ranges, target_port_list (target), 0, 1,
                            "type, CAST (start AS INTEGER)");
  if (next (&ranges))
    {
      const char *start, *end;
      int type;

      start = port_range_iterator_start (&ranges);
      end = port_range_iterator_end (&ranges);
      type = port_range_iterator_type_int (&ranges);

      /* Scanner can only handle: T:1-3,5-6,9,U:1-2 */

      if (end && strcmp (end, "0") && strcmp (end, start))
        g_string_append_printf (range, "%s%s-%s",
                                (type == PORT_PROTOCOL_UDP ? "U:" : "T:"),
                                start, end);
      else
        g_string_append_printf (range, "%s%s",
                                (type == PORT_PROTOCOL_UDP ? "U:" : "T:"),
                                start);
      while (next (&ranges))
        {
          int tcp;

          start = port_range_iterator_start (&ranges);
          end = port_range_iterator_end (&ranges);
          tcp = (type == PORT_PROTOCOL_TCP);
          type = port_range_iterator_type_int (&ranges);

          if (end && strcmp (end, "0") && strcmp (end, start))
            g_string_append_printf (range, ",%s%s-%s",
                                    (tcp && type == PORT_PROTOCOL_UDP ? "U:" : ""),
                                    start, end);
          else
            g_string_append_printf (range, ",%s%s",
                                    (tcp && type == PORT_PROTOCOL_UDP ? "U:" : ""),
                                    start);
        }
    }
  cleanup_iterator (&ranges);
  return g_string_free (range, FALSE);
}

/**
 * @brief Set the hosts associated with a target.
 *
 * @param[in]  target  Target.
 * @param[in]  hosts   New value for hosts.
 */
static void
set_target_hosts (target_t target, const char *hosts)
{
  gchar* quoted_hosts;

  assert (hosts);

  quoted_hosts = sql_quote (hosts);
  sql ("UPDATE targets SET hosts = '%s', modification_time = now ()"
       " WHERE ROWID = %llu;",
       quoted_hosts, target);
  g_free (quoted_hosts);
}

/**
 * @brief Return whether a target is in use by a task.
 *
 * @param[in]  target  Target.
 *
 * @return 1 if in use, else 0.
 */
int
target_in_use (target_t target)
{
  return !!sql_int (0, 0,
                    "SELECT count(*) FROM tasks"
                    " WHERE target = %llu"
                    " AND target_location = " G_STRINGIFY (LOCATION_TABLE)
                    " AND (hidden = 0 OR hidden = 1);",
                    target);
}

/**
 * @brief Return whether a trashcan target is referenced by a task.
 *
 * @param[in]  target  Target.
 *
 * @return 1 if in use, else 0.
 */
int
trash_target_in_use (target_t target)
{
  return !!sql_int (0, 0,
                    "SELECT count(*) FROM tasks"
                    " WHERE target = %llu"
                    " AND target_location = " G_STRINGIFY (LOCATION_TRASH),
                    target);
}

/**
 * @brief Return whether a target is writable.
 *
 * @param[in]  target  Target.
 *
 * @return 1 if writable, else 0.
 */
int
target_writable (target_t target)
{
  return (sql_int (0, 0,
                  "SELECT count(*) FROM targets"
                  " WHERE ROWID = %llu"
                  " AND uuid = '" TARGET_UUID_LOCALHOST "'",
                  target)
          || target_in_use (target))
         == 0;
}

/**
 * @brief Return whether a trashcan target is writable.
 *
 * @param[in]  target  Target.
 *
 * @return 1 if writable, else 0.
 */
int
trash_target_writable (target_t target)
{
  return (sql_int (0, 0,
                   "SELECT count(*) FROM targets_trash"
                   " WHERE ROWID = %llu"
                   " AND uuid = '" TARGET_UUID_LOCALHOST "'",
                   target)
          || trash_target_in_use (target))
         == 0;
}

/**
 * @brief Initialise a target task iterator.
 *
 * Iterates over all tasks that use the target.
 *
 * @param[in]  iterator   Iterator.
 * @param[in]  target     Target.
 */
void
init_target_task_iterator (iterator_t* iterator, target_t target)
{
  assert (current_credentials.uuid);

  init_iterator (iterator,
                 "SELECT name, uuid FROM tasks"
                 " WHERE target = %llu"
                 " AND hidden = 0"
                 " AND ((owner IS NULL) OR (owner ="
                 " (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                 " ORDER BY name ASC;",
                 target,
                 current_credentials.uuid);
}

/**
 * @brief Get the name from a target_task iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The name of the host, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (target_task_iterator_name, 0);

/**
 * @brief Get the uuid from a target_task iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The uuid of the host, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (target_task_iterator_uuid, 1);


/* Configs. */

/**
 * @brief Find a config given a UUID.
 *
 * @param[in]   uuid    Config UUID.
 * @param[out]  config  Config return, 0 if succesfully failed to find config.
 *
 * @return FALSE on success (including if failed to find config), TRUE on error.
 */
gboolean
find_config (const char* uuid, config_t* config)
{
  gchar *quoted_uuid = sql_quote (uuid);
  if (user_owns_uuid ("config", quoted_uuid) == 0)
    {
      g_free (quoted_uuid);
      *config = 0;
      return FALSE;
    }
  switch (sql_int64 (config, 0, 0,
                     "SELECT ROWID FROM configs WHERE uuid = '%s';",
                     quoted_uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *config = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        g_free (quoted_uuid);
        return TRUE;
        break;
    }
  g_free (quoted_uuid);
  return FALSE;
}

/**
 * @brief Find a config for a set of actions, given a UUID.
 *
 * @param[in]   uuid     Config UUID.
 * @param[out]  config   Config return, 0 if succesfully failed to find config.
 * @param[in]   actions  Actions.
 *
 * @return FALSE on success (including if failed to find config), TRUE on error.
 */
gboolean
find_config_for_actions (const char* uuid, config_t* config,
                         const char *actions)
{
  gchar *quoted_uuid = sql_quote (uuid);
  if (user_has_access_uuid ("config", quoted_uuid, actions) == 0)
    {
      g_free (quoted_uuid);
      *config = 0;
      return FALSE;
    }
  switch (sql_int64 (config, 0, 0,
                     "SELECT ROWID FROM configs WHERE uuid = '%s';",
                     quoted_uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *config = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        g_free (quoted_uuid);
        return TRUE;
        break;
    }
  g_free (quoted_uuid);
  return FALSE;
}

/**
 * @brief Insert preferences into a config.
 *
 * @param[in]  config       Config.
 * @param[in]  preferences  Preferences.
 *
 * @return 0 success, -1 error, -4 input error.
 */
static int
config_insert_preferences (config_t config,
                           const array_t* preferences /* preference_t. */)
{
  int index = 0;
  const preference_t *preference;
  if (preferences == NULL) return -4;
  while ((preference = (preference_t*) g_ptr_array_index (preferences, index++)))
    /* Simply skip the preference if the value is NULL, for exports
     * where sensitive information is left out. */
    if (preference->value)
      {
        GString *value;
        int alt_index = 0;
        const gchar *alt;
        gchar *quoted_value;

        if (preference->name == NULL) return -4;
        if (preference->type)
          {
            gchar *quoted_type, *quoted_nvt_name, *quoted_preference_name;

            /* Presume NVT preference. */

            if (preference->nvt_name == NULL) return -4;

            value = g_string_new (preference->value);
            while ((alt = (gchar*) g_ptr_array_index (preference->alts, alt_index++)))
              g_string_append_printf (value, ";%s", alt);

            quoted_nvt_name = sql_quote (preference->nvt_name);
            quoted_preference_name = sql_quote (preference->name);
            quoted_type = sql_quote (preference->type);
            quoted_value = sql_quote (value->str);
            g_string_free (value, TRUE);
            /* LDAPsearch[entry]:Timeout value */
            sql ("INSERT into config_preferences (config, type, name, value)"
                 " VALUES (%llu, 'PLUGINS_PREFS', '%s[%s]:%s', '%s');",
                 config,
                 quoted_nvt_name,
                 quoted_type,
                 quoted_preference_name,
                 quoted_value);
            g_free (quoted_nvt_name);
            g_free (quoted_preference_name);
            g_free (quoted_type);
            g_free (quoted_value);
          }
        else
          {
            gchar *quoted_name;

            /* Presume scanner preference. */

            quoted_name = sql_quote (preference->name);
            quoted_value = sql_quote (preference->value);
            sql ("INSERT into config_preferences (config, type, name, value)"
                 " VALUES (%llu, 'SERVER_PREFS', '%s', '%s');",
                 config,
                 quoted_name,
                 quoted_value);
            g_free (quoted_name);
            g_free (quoted_value);
          }
      }
  return 0;
}

/**
 * @brief Create a config.
 *
 * If a config with the same name exists already then add a unique integer
 * suffix onto the name.
 *
 * @param[in]   proposed_name  Proposed name of config.
 * @param[in]   comment        Comment on config.
 * @param[in]   selectors      NVT selectors.
 * @param[in]   preferences    Preferences.
 * @param[out]  config         On success the config.
 * @param[out]  name           On success the name of the config.
 *
 * @return 0 success, 1 config exists already, -1 error, -2 name empty,
 *         -3 input error in selectors, -4 input error in preferences.
 */
int
create_config (const char* proposed_name, const char* comment,
               const array_t* selectors /* nvt_selector_t. */,
               const array_t* preferences /* preference_t. */,
               config_t *config, char **name)
{
  int ret;
  gchar *quoted_comment, *candidate_name, *quoted_candidate_name;
  char *selector_uuid;
  unsigned int num = 1;

  assert (current_credentials.uuid);

  if (proposed_name == NULL || strlen (proposed_name) == 0) return -2;

  selector_uuid = openvas_uuid_make ();
  if (selector_uuid == NULL)
    return -1;

  candidate_name = g_strdup (proposed_name);
  quoted_candidate_name = sql_quote (candidate_name);

  sql ("BEGIN IMMEDIATE;");

  while (1)
    {
      if (sql_int (0, 0,
                   "SELECT COUNT(*) FROM configs WHERE name = '%s'"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                   quoted_candidate_name,
                   current_credentials.uuid)
          == 0)
        break;
      g_free (candidate_name);
      g_free (quoted_candidate_name);
      candidate_name = g_strdup_printf ("%s %u", proposed_name, ++num);
      quoted_candidate_name = sql_quote (candidate_name);
    }

  if (comment)
    {
      quoted_comment = sql_nquote (comment, strlen (comment));
      sql ("INSERT INTO configs (uuid, name, owner, nvt_selector, comment,"
           " creation_time, modification_time)"
           " VALUES (make_uuid (), '%s',"
           " (SELECT ROWID FROM users WHERE users.uuid = '%s'),"
           " '%s', '%s', now (), now ());",
           quoted_candidate_name,
           current_credentials.uuid,
           selector_uuid,
           quoted_comment);
      g_free (quoted_comment);
    }
  else
    sql ("INSERT INTO configs (uuid, name, owner, nvt_selector, comment,"
         " creation_time, modification_time)"
         " VALUES (make_uuid (), '%s',"
         " (SELECT ROWID FROM users WHERE users.uuid = '%s'),"
         " '%s', '', now (), now ());",
         quoted_candidate_name,
         current_credentials.uuid,
         selector_uuid);
  g_free (quoted_candidate_name);

  /* Insert the selectors into the nvt_selectors table. */

  *config = sqlite3_last_insert_rowid (task_db);
  if ((ret = insert_nvt_selectors (selector_uuid, selectors)))
    {
      sql ("ROLLBACK;");
      free (selector_uuid);
      return ret;
    }
  free (selector_uuid);

  /* Insert the preferences into the config_preferences table. */

  if ((ret = config_insert_preferences (*config, preferences)))
    {
      sql ("ROLLBACK;");
      return ret;
    }

  /* Update family and NVT count caches. */

  update_config_caches (*config);

  sql ("COMMIT;");
  *name = candidate_name;
  return 0;
}

/**
 * @brief Return the UUID of a config.
 *
 * @param[in]   config  Config.
 * @param[out]  id      Pointer to a newly allocated string.
 *
 * @return 0.
 */
int
config_uuid (config_t config, char ** id)
{
  *id = sql_string (0, 0,
                    "SELECT uuid FROM configs WHERE ROWID = %llu;",
                    config);
  return 0;
}

/**
 * @brief Get the value of a config preference.
 *
 * @param[in]  config      Config.
 * @param[in]  type        Preference category, NULL for general preferences.
 * @param[in]  preference  Name of the preference.
 *
 * @return If there is such a preference, the value of the preference as a
 *         newly allocated string, else NULL.
 */
static char *
config_preference (config_t config, const char *type, const char *preference)
{
  /** @todo Quote type and preference. */
  if (type)
    return sql_string (0, 0,
                       "SELECT value FROM config_preferences"
                       " WHERE ROWID = %llu AND  type = '%s' AND name = '%s';",
                       config, type, preference);
  else
    return sql_string (0, 0,
                       "SELECT value FROM config_preferences"
                       " WHERE ROWID = %llu AND type is NULL AND name = '%s';",
                       config, preference);
}

/**
 * @brief Get the timeout value for an NVT in a config.
 *
 * @param[in]  config  Config.
 * @param[in]  oid     ID of NVT.
 *
 * @return Newly allocated timeout if set for the NVT, else NULL.
 */
char *
config_nvt_timeout (config_t config, const char *oid)
{
  return sql_string (0, 0,
                     "SELECT value FROM config_preferences"
                     " WHERE config = %llu"
                     " AND type = 'SERVER_PREFS'"
                     " AND name = 'timeout.%s';",
                     config,
                     oid);
}

/**
 * @brief Exclude or include an array of NVTs in a config.
 *
 * @param[in]  nvt_selector  NVT selector name.
 * @param[in]  array         Array of OIDs of NVTs.
 * @param[in]  array_size    Size of \p array.
 * @param[in]  exclude       If true exclude, else include.
 * @param[in]  families      Families table, to lookup NVT family, or NULL.
 */
static void
clude (const char *nvt_selector, GArray *array, int array_size, int exclude,
       GHashTable *families)
{
  gint index;
  const char* tail;
  int ret;
  sqlite3_stmt* stmt;
  gchar* formatted;

  if (families)
    formatted = g_strdup_printf ("INSERT INTO nvt_selectors"
                                 " (name, exclude, type, family_or_nvt, family)"
                                 " VALUES ('%s', %i, 2, $value, $family);",
                                 nvt_selector,
                                 exclude);
  else
    formatted = g_strdup_printf ("INSERT INTO nvt_selectors"
                                 " (name, exclude, type, family_or_nvt, family)"
                                 " VALUES ('%s', %i, 2, $value, NULL);",
                                 nvt_selector,
                                 exclude);

  tracef ("   sql: %s\n", formatted);

  /* Prepare statement. */

  while (1)
    {
      ret = sqlite3_prepare (task_db, (char*) formatted, -1, &stmt, &tail);
      if (ret == SQLITE_BUSY) continue;
      g_free (formatted);
      if (ret == SQLITE_OK)
        {
          if (stmt == NULL)
            {
              g_warning ("%s: sqlite3_prepare failed with NULL stmt: %s\n",
                         __FUNCTION__,
                         sqlite3_errmsg (task_db));
              abort ();
            }
          break;
        }
      g_warning ("%s: sqlite3_prepare failed: %s\n",
                 __FUNCTION__,
                 sqlite3_errmsg (task_db));
      /** @todo ROLLBACK if in transaction. */
      abort ();
    }

  for (index = 0; index < array_size; index++)
    {
      const char *id;
      id = g_array_index (array, char*, index);

      /* Bind the family name to the "$family" in the SQL statement. */

      if (families)
        {
          char *family = NULL;
          nvti_t *nvti = nvtis_lookup (nvti_cache, id);

          if (nvti)
            {
              family = nvti_family (nvti);

              if (family)
                g_hash_table_insert (families, family, (gpointer) 1);
              else
                {
                  g_warning ("%s: skipping NVT '%s' from import of config '%s'"
                             " because the NVT is missing a family in the"
                             " cache",
                             __FUNCTION__,
                             id,
                             nvt_selector);
                  continue;
                }
            }
          else
            {
              g_warning ("%s: skipping NVT '%s' from import of config '%s'"
                         " because the NVT is missing from the cache",
                         __FUNCTION__,
                         id,
                         nvt_selector);
              continue;
            }

          while (1)
            {
              assert (family);
              ret = sqlite3_bind_text (stmt, 2, family, -1,
                                       SQLITE_TRANSIENT);
              if (ret == SQLITE_BUSY) continue;
              if (ret == SQLITE_OK) break;
              g_warning ("%s: sqlite3_prepare failed: %s\n",
                         __FUNCTION__,
                         sqlite3_errmsg (task_db));
              abort ();
            }
        }

      /* Bind the ID to the "$value" in the SQL statement. */

      while (1)
        {
          ret = sqlite3_bind_text (stmt, 1, id, -1, SQLITE_TRANSIENT);
          if (ret == SQLITE_BUSY) continue;
          if (ret == SQLITE_OK) break;
          g_warning ("%s: sqlite3_prepare failed: %s\n",
                     __FUNCTION__,
                     sqlite3_errmsg (task_db));
          abort ();
        }

      /* Run the statement. */

      while (1)
        {
          ret = sqlite3_step (stmt);
          if (ret == SQLITE_BUSY) continue;
          if (ret == SQLITE_DONE) break;
          if (ret == SQLITE_ERROR || ret == SQLITE_MISUSE)
            {
              if (ret == SQLITE_ERROR) ret = sqlite3_reset (stmt);
              g_warning ("%s: sqlite3_step failed: %s\n",
                         __FUNCTION__,
                         sqlite3_errmsg (task_db));
              abort ();
            }
        }

      /* Reset the statement. */

      while (1)
        {
          ret = sqlite3_reset (stmt);
          if (ret == SQLITE_BUSY) continue;
          if (ret == SQLITE_DONE || ret == SQLITE_OK) break;
          if (ret == SQLITE_ERROR || ret == SQLITE_MISUSE)
            {
              g_warning ("%s: sqlite3_reset failed: %s\n",
                         __FUNCTION__,
                         sqlite3_errmsg (task_db));
              abort ();
            }
        }
    }

  sqlite3_finalize (stmt);
}

/**
 * @brief Copy the preferences and nvt selector from an RC file to a config.
 *
 * @param[in]  config             Config to copy into.
 * @param[in]  config_name        Name of config to copy into, SQL quoted.
 * @param[in]  nvt_selector_name  Name of NVT selector associated with config,
 *                                SQL quoted.
 * @param[in]  rc                 Text of RC file.
 *
 * @return 0 success, -1 error.
 */
static int
insert_rc_into_config (config_t config, const char *config_name,
                       const char *nvt_selector_name, char *rc)
{
  GArray *yes = g_array_sized_new (FALSE, FALSE, sizeof (rc), 20000);
  GArray *no = g_array_sized_new (FALSE, FALSE, sizeof (rc), 20000);
  int yes_size = 0, no_size = 0;
  char* seek;
  GHashTable *families;

  if (rc == NULL)
    {
      tracef ("   rc NULL\n");
      return -1;
    }

  if (config_name == NULL)
    {
      tracef ("   config_name NULL\n");
      return -1;
    }

  families = g_hash_table_new_full (g_str_hash,
                                    g_str_equal,
                                    NULL,
                                    NULL);

  while (1)
    {
      char* eq;
      seek = strchr (rc, '\n');
      eq = seek
           ? memchr (rc, '=', seek - rc)
           : strchr (rc, '=');
      if (eq)
        {
          char* rc_end = eq;
          rc_end--;
          while (*rc_end == ' ') rc_end--;
          rc_end++;
          while (*rc == ' ') rc++;
          if (rc < rc_end)
            {
              gchar *name, *value;
              name = sql_nquote (rc, rc_end - rc);
              value = sql_nquote (eq + 2, /* Daring. */
                                  (seek ? seek - (eq + 2) : strlen (eq + 2)));
              sql ("INSERT OR REPLACE INTO config_preferences"
                   " (config, type, name, value)"
                   " VALUES (%llu, NULL, '%s', '%s');",
                   config, name, value);
              g_free (name);
              g_free (value);
            }
        }
      else if (((seek ? seek - rc >= 7 + strlen ("PLUGIN_SET") : 0)
                && (strncmp (rc, "begin(", 6) == 0)
                && (strncmp (rc + 6, "PLUGIN_SET", strlen ("PLUGIN_SET")) == 0)
                && (rc[6 + strlen ("PLUGIN_SET")] == ')'))
               || ((seek ? seek - rc >= 7 + strlen ("SCANNER_SET") : 0)
                   && (strncmp (rc, "begin(", 6) == 0)
                   && (strncmp (rc + 6, "SCANNER_SET", strlen ("SCANNER_SET"))
                       == 0)
                   && (rc[6 + strlen ("SCANNER_SET")] == ')')))
        {
          /* Create an NVT selector from the plugin list. */

          rc = seek + 1;
          while ((seek = strchr (rc, '\n')))
            {
              char* eq2;

              if ((seek ? seek - rc > 5 : 1)
                  && strncmp (rc, "end(", 4) == 0)
                {
                  break;
                }

              eq2 = memchr (rc, '=', seek - rc);
              if (eq2)
                {
                  char* rc_end = eq2;
                  rc_end--;
                  while (*rc_end == ' ') rc_end--;
                  rc_end++;
                  while (*rc == ' ') rc++;
                  if (rc < rc_end)
                    {
                      int value_len = (seek ? seek - (eq2 + 2)
                                            : strlen (eq2 + 2));
                      *rc_end = '\0';

                      if ((value_len == 3)
                          && strncasecmp (eq2 + 2, "yes", 3) == 0)
                        {
                          yes_size++;
                          g_array_append_val (yes, rc);
                        }
                      else
                        {
                          no_size++;
                          g_array_append_val (no, rc);
                        }
                    }
                }

              rc = seek + 1;
            }
        }
      else if ((seek ? seek - rc > 7 : 0)
               && (strncmp (rc, "begin(", 6) == 0))
        {
          gchar *section_name;

          section_name = sql_nquote (rc + 6, seek - (rc + 6) - 1);

          /* Insert the section. */

          rc = seek + 1;
          while ((seek = strchr (rc, '\n')))
            {
              char* eq2;

              if ((seek ? seek - rc > 5 : 1)
                  && strncmp (rc, "end(", 4) == 0)
                {
                  break;
                }

              eq2 = memchr (rc, '=', seek - rc);
              if (eq2)
                {
                  char* rc_end = eq2;
                  rc_end--;
                  while (*rc_end == ' ') rc_end--;
                  rc_end++;
                  while (*rc == ' ') rc++;
                  if (rc < rc_end)
                    {
                      gchar *name, *value;
                      name = sql_nquote (rc, rc_end - rc);
                      value = sql_nquote (eq2 + 2, /* Daring. */
                                          seek - (eq2 + 2));
                      sql ("INSERT OR REPLACE INTO config_preferences"
                           " (config, type, name, value)"
                           " VALUES (%llu, '%s', '%s', '%s');",
                           config, section_name, name, value);
                      g_free (name);
                      g_free (value);
                    }
                }

              rc = seek + 1;
            }

          g_free (section_name);
        }
      if (seek == NULL) break;
      rc = seek + 1;
    }

  {
    char *auto_enable;
    auto_enable = config_preference (config, NULL, "auto_enable_new_plugins");
    if (auto_enable
        && strcmp (auto_enable, "no")
        && strcmp (auto_enable, "0"))
      {
        free (auto_enable);

        /* Include the all selector. */

        sql ("INSERT INTO nvt_selectors"
             " (name, exclude, type, family_or_nvt)"
             " VALUES ('%s', 0, 0, 0);",
             nvt_selector_name);

        /* Explicitly exclude any nos. */

        clude (nvt_selector_name, no, no_size, 1, NULL);

        /* Cache the counts and growth types. */

        sql ("UPDATE configs"
             " SET families_growing = 1, nvts_growing = 1,"
             " family_count = %i, nvt_count = %i,"
             " modification_time = now ()"
             " WHERE name = '%s';",
             nvt_selector_family_count (nvt_selector_name, 1),
             nvt_selector_nvt_count (nvt_selector_name, NULL, 1),
             config_name);
      }
    else
      {
        /* Explictly include the yeses and exclude the nos.  Keep the nos
         * because the config may change to auto enable new plugins. */
        /** @todo The other selector manipulation functions may lose the nos. */

        clude (nvt_selector_name, yes, yes_size, 0, families);
        clude (nvt_selector_name, no, no_size, 1, NULL);

        /* Cache the family and NVT count and selector types. */

        sql ("UPDATE configs SET"
             " family_count = %i,"
             " nvt_count = %i, families_growing = 0, nvts_growing = 0,"
             " modification_time = now ()"
             " WHERE name = '%s';",
             g_hash_table_size (families),
             yes_size,
             config_name);
        g_hash_table_destroy (families);
      }
  }

  return 0;
}

/**
 * @brief Create a config from an RC file.
 *
 * @param[in]   name     Name of config and NVT selector.
 * @param[in]   comment  Comment on config.
 * @param[in]   rc       RC file text.
 * @param[out]  config   Created config.
 *
 * @return 0 success, 1 config exists already, -1 error.
 */
int
create_config_rc (const char* name, const char* comment, char* rc,
                  config_t *config)
{
  gchar *quoted_name = sql_nquote (name, strlen (name));
  gchar *quoted_comment;
  char *selector_uuid;
  config_t new_config;

  assert (current_credentials.uuid);

  sql ("BEGIN IMMEDIATE;");

  if (sql_int (0, 0,
               "SELECT COUNT(*) FROM configs WHERE name = '%s'"
               " AND ((owner IS NULL) OR (owner ="
               " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
               quoted_name,
               current_credentials.uuid))
    {
      tracef ("   config \"%s\" already exists\n", name);
      sql ("ROLLBACK;");
      g_free (quoted_name);
      return 1;
    }

  selector_uuid = openvas_uuid_make ();
  if (selector_uuid == NULL)
    {
      tracef ("   failed to create UUID \n");
      sql ("ROLLBACK;");
      g_free (quoted_name);
      return -1;
    }

  if (sql_int (0, 0,
               "SELECT COUNT(*) FROM nvt_selectors WHERE name = '%s' LIMIT 1;",
               selector_uuid))
    {
      tracef ("   NVT selector \"%s\" already exists\n", selector_uuid);
      sql ("ROLLBACK;");
      free (selector_uuid);
      g_free (quoted_name);
      return -1;
    }

  if (comment)
    {
      quoted_comment = sql_nquote (comment, strlen (comment));
      sql ("INSERT INTO configs (uuid, name, owner, nvt_selector, comment,"
           " creation_time, modification_time)"
           " VALUES (make_uuid (), '%s',"
           " (SELECT ROWID FROM users WHERE users.uuid = '%s'),"
           " '%s', '%s', now (), now ());",
           quoted_name,
           current_credentials.uuid,
           selector_uuid,
           quoted_comment);
      g_free (quoted_comment);
    }
  else
    sql ("INSERT INTO configs (uuid, name, owner, nvt_selector, comment,"
         " creation_time, modification_time)"
         " VALUES (make_uuid (), '%s',"
         " (SELECT ROWID FROM users WHERE users.uuid = '%s'),"
         " '%s', '', now (), now ());",
         quoted_name, current_credentials.uuid, selector_uuid);

  /* Insert the RC into the config_preferences table. */

  new_config = sqlite3_last_insert_rowid (task_db);
  if (insert_rc_into_config (new_config, quoted_name, selector_uuid, rc))
    {
      sql ("ROLLBACK;");
      free (selector_uuid);
      g_free (quoted_name);
      return -1;
    }

  sql ("COMMIT;");
  free (selector_uuid);
  g_free (quoted_name);
  if (config)
    *config = new_config;
  return 0;
}

/**
 * @brief Create a config from an existing config.
 *
 * @param[in]  name        Name of new config and NVT selector.
 * @param[in]  comment     Comment on new config.
 * @param[in]  config      Existing config.
 * @param[out] new_config  New config.
 *
 * @return 0 success, 1 config exists already, 2 failed to find existing
 *         config, -1 error.
 */
int
copy_config (const char* name, const char* comment, config_t config,
             config_t* new_config)
{
  char *config_selector, *uuid;
  config_t id;
  gchar *quoted_name = sql_quote (name);
  gchar *quoted_comment, *quoted_config_selector;
  gchar *uniquify;
  user_t owner;

  assert (current_credentials.uuid);

  config_selector = config_nvt_selector (config);
  if (config_selector == NULL)
    {
      g_free (quoted_name);
      return -1;
    }
  quoted_config_selector = sql_quote (config_selector);
  free (config_selector);

  sql ("BEGIN IMMEDIATE;");

  if (find_user (current_credentials.username, &owner)
      || owner == 0)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (quoted_name && strlen (quoted_name))
    {
      if (sql_int (0, 0,
                   "SELECT COUNT(*) FROM configs WHERE name = '%s'"
                   " AND ((owner IS NULL) OR (owner = %llu));",
                   quoted_name,
                   owner))
        {
          tracef ("   config \"%s\" already exists\n", name);
          sql ("ROLLBACK;");
          g_free (quoted_name);
          g_free (quoted_config_selector);
          return 1;
        }
    }
  else
    quoted_name = NULL;

  if (sql_int (0, 0,
               "SELECT COUNT(*) FROM configs"
               " WHERE ROWID = %llu"
               " AND ((owner IS NULL) OR (owner = %llu))",
               config,
               owner)
      == 0)
    {
      sql ("ROLLBACK;");
      g_free (quoted_name);
      g_free (quoted_config_selector);
      return 2;
    }

  uuid = openvas_uuid_make ();
  if (uuid == NULL)
    {
      tracef ("   failed to create UUID \n");
      sql ("ROLLBACK;");
      g_free (quoted_name);
      g_free (quoted_config_selector);
      return -1;
    }

  if (sql_int (0, 0,
               "SELECT COUNT(*) FROM nvt_selectors WHERE name = '%s' LIMIT 1;",
               uuid))
    {
      tracef ("   NVT selector \"%s\" already exists\n", uuid);
      sql ("ROLLBACK;");
      free (uuid);
      g_free (quoted_name);
      g_free (quoted_config_selector);
      return -1;
    }

  /* Copy the existing config. */

  uniquify = g_strdup_printf ("uniquify ('config', name, %llu, ' Clone')",
                              owner);
  if (comment && strlen (comment) > 0)
    {
      quoted_comment = sql_nquote (comment, strlen (comment));
      sql ("INSERT INTO configs"
           " (uuid, name, owner, nvt_selector, comment, family_count,"
           "  nvt_count, families_growing, nvts_growing,"
           "  creation_time, modification_time)"
           " SELECT make_uuid (), '%s', %llu, '%s', '%s', family_count,"
           " nvt_count, families_growing, nvts_growing, now (), now ()"
           " FROM configs WHERE ROWID = %llu;",
           quoted_name,
           owner,
           uuid,
           quoted_comment,
           config);
      g_free (quoted_comment);
    }
  else
    sql ("INSERT INTO configs"
         " (uuid, name, owner, nvt_selector, comment, family_count, nvt_count,"
         "  families_growing, nvts_growing, creation_time, modification_time)"
         " SELECT make_uuid (), %s%s%s, %llu, '%s', %s, family_count,"
         " nvt_count, families_growing, nvts_growing, now (), now ()"
         " FROM configs WHERE ROWID = %llu",
         quoted_name ? "'" : "",
         quoted_name ? quoted_name : uniquify,
         quoted_name ? "'" : "",
         owner,
         uuid,
         quoted_name ? "''" : "comment",
         config);

  id = sqlite3_last_insert_rowid (task_db);

  sql ("INSERT INTO config_preferences (config, type, name, value)"
       " SELECT %llu, type, name, value FROM config_preferences"
       " WHERE config = %llu;",
       id,
       config);

  sql ("INSERT INTO nvt_selectors (name, exclude, type, family_or_nvt, family)"
       " SELECT '%s', exclude, type, family_or_nvt, family FROM nvt_selectors"
       " WHERE name = '%s';",
       uuid,
       quoted_config_selector);

  sql ("COMMIT;");
  free (uuid);
  g_free (quoted_name);
  g_free (quoted_config_selector);
  g_free (uniquify);
  if (new_config) *new_config = id;
  return 0;
}

/**
 * @brief Delete a config.
 *
 * @param[in]  config_id  UUID of config.
 * @param[in]  ultimate   Whether to remove entirely, or to trashcan.
 *
 * @return 0 success, 1 fail because a task refers to the config, 2 failed to
 *         find config, -1 error.
 */
int
delete_config (const char *config_id, int ultimate)
{
  config_t config = 0;

  if ((strcmp (config_id, CONFIG_UUID_FULL_AND_FAST) == 0)
      || (strcmp (config_id, CONFIG_UUID_FULL_AND_FAST_ULTIMATE) == 0)
      || (strcmp (config_id, CONFIG_UUID_FULL_AND_VERY_DEEP) == 0)
      || (strcmp (config_id, CONFIG_UUID_FULL_AND_VERY_DEEP_ULTIMATE) == 0)
      || (strcmp (config_id, CONFIG_UUID_EMPTY) == 0))
    return 1;

  sql ("BEGIN IMMEDIATE;");

  if (find_config (config_id, &config))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (config == 0)
    {
      if (find_trash ("config", config_id, &config))
        {
          sql ("ROLLBACK;");
          return -1;
        }
      if (config == 0)
        {
          sql ("ROLLBACK;");
          return 2;
        }
      if (ultimate == 0)
        {
          /* It's already in the trashcan. */
          sql ("COMMIT;");
          return 0;
        }

      /* Check if it's in use by a task in the trashcan. */
      if (sql_int (0, 0,
                   "SELECT count(*) FROM tasks"
                   " WHERE config = %llu"
                   " AND config_location = " G_STRINGIFY (LOCATION_TRASH) ";",
                   config))
        {
          sql ("ROLLBACK;");
          return 1;
        }

      sql ("DELETE FROM nvt_selectors WHERE name ="
           " (SELECT nvt_selector FROM configs_trash WHERE ROWID = %llu);",
           config);
      sql ("DELETE FROM config_preferences_trash WHERE config = %llu;",
           config);
      sql ("DELETE FROM configs_trash WHERE ROWID = %llu;",
           config);
      sql ("COMMIT;");
      return 0;
    }

  if (ultimate)
    {
      if (sql_int (0, 0,
                   "SELECT count(*) FROM tasks"
                   " WHERE config = %llu"
                   " AND config_location = " G_STRINGIFY (LOCATION_TABLE),
                   config))
        {
          sql ("ROLLBACK;");
          return 1;
        }

      sql ("DELETE FROM nvt_selectors WHERE name ="
           " (SELECT nvt_selector FROM configs_trash WHERE ROWID = %llu);",
           config);
    }
  else
    {
      config_t trash_config;

      if (sql_int (0, 0,
                   "SELECT count(*) FROM tasks"
                   " WHERE config = %llu"
                   " AND config_location = " G_STRINGIFY (LOCATION_TABLE)
                   " AND (hidden = 0 OR hidden = 1);",
                   config))
        {
          sql ("ROLLBACK;");
          return 1;
        }

      sql ("INSERT INTO configs_trash"
           " (uuid, owner, name, nvt_selector, comment, family_count, nvt_count,"
           "  families_growing, nvts_growing, creation_time, modification_time)"
           " SELECT uuid, owner, name, nvt_selector, comment, family_count,"
           "        nvt_count, families_growing, nvts_growing,"
           "        creation_time, modification_time"
           " FROM configs WHERE ROWID = %llu;",
           config);

      trash_config = sqlite3_last_insert_rowid (task_db);

      sql ("INSERT INTO config_preferences_trash"
           " (config, type, name, value)"
           " SELECT %llu, type, name, value"
           " FROM config_preferences WHERE config = %llu;",
           trash_config,
           config);

      /* Update the location of the config in any trashcan tasks. */
      sql ("UPDATE tasks"
           " SET config = %llu,"
           "     config_location = " G_STRINGIFY (LOCATION_TRASH)
           " WHERE config = %llu"
           " AND config_location = " G_STRINGIFY (LOCATION_TABLE) ";",
           trash_config,
           config);
    }

  sql ("DELETE FROM config_preferences WHERE config = %llu;", config);
  sql ("DELETE FROM configs WHERE ROWID = %llu;", config);

  sql ("COMMIT;");
  return 0;
}

/**
 * @brief Filter columns for scan configs iterator.
 */
#define CONFIG_ITERATOR_FILTER_COLUMNS                                        \
 { GET_ITERATOR_FILTER_COLUMNS, "nvt_selector", "families_total",             \
   "nvts_total", "families_trend", "nvts_trend", NULL }

/**
 * @brief Scan config iterator columns.
 */
#define CONFIG_ITERATOR_COLUMNS                                               \
  GET_ITERATOR_COLUMNS ", nvt_selector, family_count AS families_total,"      \
  " nvt_count AS nvts_total, families_growing AS families_trend,"             \
  " nvts_growing AS nvts_trend"

/**
 * @brief Scan config iterator columns for trash case.
 */
#define CONFIG_ITERATOR_TRASH_COLUMNS                                         \
  GET_ITERATOR_COLUMNS ", nvt_selector, family_count AS families_total,"      \
  " nvt_count AS nvts_total, families_growing AS families_trend,"             \
  " nvts_growing AS nvts_trend"

/**
 * @brief Count the number of scan configs.
 *
 * @param[in]  get  GET params.
 *
 * @return Total number of scan configs filtered set.
 */
int
config_count (const get_data_t *get)
{
  static const char *extra_columns[] = CONFIG_ITERATOR_FILTER_COLUMNS;
  return count ("config", get, CONFIG_ITERATOR_COLUMNS, extra_columns, 0, 0,
                0, TRUE);
}

/**
 * @brief Initialise a config iterator, limited to user's configs.
 *
 * @param[in]  iterator    Iterator.
 * @param[in]  config      Config.  0 for all.
 * @param[in]  trash       Whether to iterate over trashcan configs.
 * @param[in]  ascending   Whether to sort ascending or descending.
 * @param[in]  sort_field  Field to sort on, or NULL for "ROWID".
 */
void
init_user_config_iterator (iterator_t* iterator, config_t config, int trash,
                           int ascending, const char* sort_field)
{
  gchar *sql;

  assert (current_credentials.uuid);

  if (config)
    sql = g_strdup_printf ("SELECT " CONFIG_ITERATOR_COLUMNS
                           " FROM configs%s"
                           " WHERE ROWID = %llu"
                           " AND ((owner IS NULL) OR (owner ="
                           " (SELECT ROWID FROM users"
                           "  WHERE users.uuid = '%s')))"
                           " ORDER BY %s %s;",
                           trash ? "_trash" : "",
                           config,
                           current_credentials.uuid,
                           sort_field ? sort_field : "ROWID",
                           ascending ? "ASC" : "DESC");
  else
    sql = g_strdup_printf ("SELECT " CONFIG_ITERATOR_COLUMNS
                           " FROM configs%s"
                           " WHERE ((owner IS NULL) OR (owner ="
                           " (SELECT ROWID FROM users"
                           "  WHERE users.uuid = '%s')))"
                           " ORDER BY %s %s;",
                           trash ? "_trash" : "",
                           current_credentials.uuid,
                           sort_field ? sort_field : "ROWID",
                           ascending ? "ASC" : "DESC");
  init_iterator (iterator, sql);
  g_free (sql);
}

/**
 * @brief Initialise a scan config iterator.
 *
 * @param[in]  iterator  Iterator.
 * @param[in]  get         GET data.
 *
 * @return 0 success, 1 failed to find scan config, failed to find filter,
 *         -1 error.
 */
int
init_config_iterator (iterator_t* iterator, const get_data_t *get)
{
  static const char *filter_columns[] = CONFIG_ITERATOR_FILTER_COLUMNS;

  return init_get_iterator (iterator,
                            "config",
                            get,
                            /* Columns. */
                            CONFIG_ITERATOR_COLUMNS,
                            /* Columns for trashcan. */
                            CONFIG_ITERATOR_TRASH_COLUMNS,
                            filter_columns,
                            NULL,
                            0,
                            NULL,
                            NULL,
                            TRUE);
}

/**
 * @brief Get the config from a config iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Config.
 */
config_t
config_iterator_config (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (config_t) sqlite3_column_int64 (iterator->stmt, 0);
}

/**
 * @brief Get the uuid from a config iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The uuid of the config, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (config_iterator_uuid, 1);

/**
 * @brief Get the name from a config iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The name of the config, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (config_iterator_name, 2);

/**
 * @brief Get the comment from a scan config iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Comment, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (config_iterator_comment, 3);

/**
 * @brief Get the nvt_selector from a config iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The nvt_selector of the config, or NULL if iteration is complete.
 *         Freed by cleanup_iterator.
 */
DEF_ACCESS (config_iterator_nvt_selector, GET_ITERATOR_COLUMN_COUNT);

/**
 * @brief Get the family count from a config iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Family count if known, -1 else.
 */
int
config_iterator_family_count (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (int) sqlite3_column_int (iterator->stmt,
                                  GET_ITERATOR_COLUMN_COUNT + 1);
  return ret;
}

/**
 * @brief Get the nvt count from a config iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Nvt count if known, -1 else.
 */
int
config_iterator_nvt_count (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (int) sqlite3_column_int (iterator->stmt,
                                  GET_ITERATOR_COLUMN_COUNT + 2);
  return ret;
}

/**
 * @brief Get the families growing state from a config iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Families growing flag.
 */
int
config_iterator_families_growing (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (int) sqlite3_column_int (iterator->stmt,
                                  GET_ITERATOR_COLUMN_COUNT +3);
  return ret;
}

/**
 * @brief Get the NVTs growing state from a config iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return NVTs growing flag.
 */
int
config_iterator_nvts_growing (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (int) sqlite3_column_int (iterator->stmt,
                                  GET_ITERATOR_COLUMN_COUNT + 4);
  return ret;
}

/**
 * @brief Return whether a config is referenced by a task.
 *
 * The predefined configs are always in use.
 *
 * @param[in]  config  Config.
 *
 * @return 1 if in use, else 0.
 */
int
config_in_use (config_t config)
{
  if (config == CONFIG_ID_FULL_AND_FAST
      || config == CONFIG_ID_FULL_AND_FAST_ULTIMATE
      || config == CONFIG_ID_FULL_AND_VERY_DEEP
      || config == CONFIG_ID_FULL_AND_VERY_DEEP_ULTIMATE
      || config == sql_int (0, 0,
                            "SELECT ROWID FROM configs WHERE name = 'empty';"))
    return 1;

  return sql_int (0, 0,
                  "SELECT count(*) FROM tasks"
                  " WHERE config = %llu"
                  " AND config_location = " G_STRINGIFY (LOCATION_TABLE)
                  " AND (hidden = 0 OR hidden = 1);",
                  config);
}

/**
 * @brief Return whether a config is referenced by a task outside the trashcan.
 *
 * @param[in]  config  Config.
 *
 * @return 1 if in use, else 0.
 */
int
config_writable (config_t config)
{
  return !config_in_use (config);
}

/**
 * @brief Return whether a trashcan config is referenced by a task.
 *
 * @param[in]  config  Config.
 *
 * @return 1 if in use, else 0.
 */
int
trash_config_in_use (config_t config)
{
  return sql_int (0, 0,
                  "SELECT count(*) FROM tasks"
                  " WHERE config = %llu"
                  " AND config_location = " G_STRINGIFY (LOCATION_TRASH),
                  config);
}

/**
 * @brief Return whether a trashcan config is writable.
 *
 * @param[in]  config  Config.
 *
 * @return 1 if in use, else 0.
 */
int
trash_config_writable (config_t config)
{
  return !trash_config_in_use (config);
}

/**
 * @brief Initialise a preference iterator.
 *
 * Assume the caller has permission to access the config.
 *
 * @param[in]  iterator  Iterator.
 * @param[in]  config    Config.
 * @param[in]  section   Preference section, NULL for general preferences.
 */
static void
init_preference_iterator (iterator_t* iterator,
                          config_t config,
                          const char* section)
{
  gchar* sql;
  if (section)
    {
      gchar *quoted_section = sql_nquote (section, strlen (section));
      sql = g_strdup_printf ("SELECT name, value FROM config_preferences"
                             " WHERE config = %llu"
                             " AND type = '%s';",
                             config, quoted_section);
      g_free (quoted_section);
    }
  else
    sql = g_strdup_printf ("SELECT name, value FROM config_preferences"
                           " WHERE config = %llu"
                           " AND type is NULL;",
                           config);
  init_iterator (iterator, sql);
  g_free (sql);
}

/**
 * @brief Get the name from a preference iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The name of the preference iterator, or NULL if iteration is
 *         complete.  Freed by cleanup_iterator.
 */
static DEF_ACCESS (preference_iterator_name, 0);

/**
 * @brief Get the value from a preference iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The value of the preference iterator, or NULL if iteration is
 *         complete.  Freed by cleanup_iterator.
 */
static DEF_ACCESS (preference_iterator_value, 1);

/**
 * @brief Initialise an "OTP" preference iterator.
 *
 * Assume the caller has permission to access the config.
 *
 * This version substitutes the scanner preference when the NVT preference
 * is missing.
 *
 * @param[in]  iterator  Iterator.
 * @param[in]  config    Config containing preferences.
 * @param[in]  section   Preference section, NULL for general preferences.
 */
void
init_otp_pref_iterator (iterator_t* iterator,
                        config_t config,
                        const char* section)
{
  gchar *quoted_section;

  assert (config);
  assert (section);
  assert ((strcmp (section, "PLUGINS_PREFS") == 0)
          || (strcmp (section, "SERVER_PREFS") == 0));

  quoted_section = sql_quote (section);

  init_iterator (iterator,
                 "SELECT config_preferences.name, config_preferences.value"
                 " FROM config_preferences, nvt_preferences"
                 " WHERE config_preferences.config = %llu"
                 " AND config_preferences.type = '%s'"
                 " AND (config_preferences.name = nvt_preferences.name"
                 "      OR config_preferences.name LIKE 'timeout.%')"
                 " AND config_preferences.name != 'max_checks'"
                 " AND config_preferences.name != 'max_hosts'"
                 " UNION"
                 " SELECT nvt_preferences.name, nvt_preferences.value"
                 " FROM nvt_preferences"
                 " WHERE nvt_preferences.name %s"
                 " AND (SELECT COUNT(*) FROM config_preferences"
                 "      WHERE config = %llu"
                 "      AND config_preferences.name = nvt_preferences.name) = 0;",
                 config,
                 quoted_section,
                 strcmp (quoted_section, "SERVER_PREFS") == 0
                  ? "NOT LIKE '%[%]%'" : "LIKE '%[%]%'",
                 config);
  g_free (quoted_section);
}

/**
 * @brief Get the NAME from a host iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return NAME, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (otp_pref_iterator_name, 0);

/**
 * @brief Get the value from a otp_pref iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Value, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (otp_pref_iterator_value, 1);

/**
 * @brief Return the NVT selector associated with a config.
 *
 * @param[in]  config  Config.
 *
 * @return Name of NVT selector if config exists and NVT selector is set, else
 *         NULL.
 */
char*
config_nvt_selector (config_t config)
{
  return sql_string (0, 0,
                     "SELECT nvt_selector FROM configs WHERE ROWID = %llu;",
                     config);
}

/**
 * @brief Set a preference of a config.
 *
 * @param[in]  config    Config.
 * @param[in]  nvt       UUID of NVT.  NULL for scanner preference.
 * @param[in]  name      Preference name, including NVT name and preference
 *                       type.
 * @param[in]  value_64  Preference value in base64.  NULL for an NVT
 *                       preference removes the preference from the config.
 *
 * @return 0 success, 1 config in use, 2 empty radio value, -1 error.
 */
int
manage_set_config_preference (config_t config, const char* nvt, const char* name,
                              const char* value_64)
{
  gchar *quoted_name, *quoted_value, *value;
  int type_start = -1, type_end = -1, count;

  if (value_64 == NULL)
    {
      int end = -1;

      sql ("BEGIN IMMEDIATE;");

      if (sql_int (0, 0,
                   "SELECT count(*) FROM tasks"
                   " WHERE config = %llu AND (hidden = 0 OR hidden = 1);",
                   config))
        {
          sql ("ROLLBACK;");
          return 1;
        }

      quoted_name = sql_quote (name);

      /* scanner[scanner]:Timeout */
      count = sscanf (name, "%*[^[][scanner]:%n", &end);
      if (count == 0 && end > 0)
        {
          /* A scanner preference.  Remove type decoration from name. */
          g_free (quoted_name);
          quoted_name = sql_quote (name + end);
        }

      sql ("DELETE FROM config_preferences"
           " WHERE config = %llu"
           " AND name = '%s';",
           config,
           quoted_name);

      sql ("COMMIT;");

      g_free (quoted_name);
      return 0;
    }

  sql ("BEGIN IMMEDIATE;");

  if (sql_int (0, 0,
               "SELECT count(*) FROM tasks"
               " WHERE config = %llu AND (hidden = 0 OR hidden = 1);",
               config))
    {
      sql ("ROLLBACK;");
      return 1;
    }

  quoted_name = sql_quote (name);

  if (strlen (value_64))
    {
      gsize value_len;
      value = (gchar*) g_base64_decode (value_64, &value_len);
    }
  else
    value = g_strdup ("");

  /* LDAPsearch[entry]:Timeout value */
  count = sscanf (name, "%*[^[][%n%*[^]]%n]:", &type_start, &type_end);
  if (count == 0 && type_start > 0 && type_end > 0)
    {
      if (strncmp (name + type_start, "radio", type_end - type_start) == 0)
        {
          char *old_value;
          gchar **split, **point;
          GString *string;

          if (strlen (value) == 0)
            {
              g_free (quoted_name);
              g_free (value);
              sql ("ROLLBACK;");
              return 2;
            }

          /* A radio.  Put the new value on the front of the list of options. */

          old_value = sql_string (0, 0,
                                  "SELECT value FROM config_preferences"
                                  " WHERE config = %llu"
                                  " AND type %s"
                                  " AND name = '%s'",
                                  config,
                                  nvt ? "= 'PLUGINS_PREFS'" : "is NULL",
                                  quoted_name);
          if (old_value == NULL)
            old_value = sql_string (0, 0,
                                    "SELECT value FROM nvt_preferences"
                                    " WHERE name = '%s'",
                                    quoted_name);
          if (old_value)
            {
              string = g_string_new (value);
              split = g_strsplit (old_value, ";", 0);
              free (old_value);
              point = split;
              while (*point)
                {
                  if (strlen (*point) == 0)
                    {
                      g_free (quoted_name);
                      g_strfreev (split);
                      g_free (value);
                      g_string_free (string, TRUE);
                      sql ("ROLLBACK;");
                      return -1;
                    }

                  if (strcmp (*point, value))
                    {
                      g_string_append_c (string, ';');
                      g_string_append (string, *point);
                    }
                  point++;
                }
              g_strfreev (split);
              g_free (value);
              value = g_string_free (string, FALSE);
            }
        }
      else if (strncmp (name + type_start, "scanner", type_end - type_start)
               == 0)
        {
          /* A scanner preference.  Remove type decoration from name. */

          g_free (quoted_name);
          quoted_name = sql_quote (name + type_end + 2);
        }
    }

  quoted_value = sql_quote ((gchar*) value);
  g_free (value);

  sql ("DELETE FROM config_preferences"
       " WHERE config = %llu"
       " AND type %s"
       " AND name = '%s'",
       config,
       nvt ? "= 'PLUGINS_PREFS'" : "= 'SERVER_PREFS'",
       quoted_name);
  sql ("INSERT INTO config_preferences"
       " (config, type, name, value)"
       " VALUES (%llu, %s, '%s', '%s');",
       config,
       nvt ? "'PLUGINS_PREFS'" : "'SERVER_PREFS'",
       quoted_name,
       quoted_value);
  sql ("COMMIT;");

  g_free (quoted_name);
  g_free (quoted_value);
  return 0;
}

/**
 * @brief Set the comment of a config.
 *
 * @param[in]  config   Config.
 * @param[in]  comment  New comment.
 *
 * @return 0 success, -1 error.
 */
int
manage_set_config_comment (config_t config, const char* comment)
{
  gchar *quoted_comment;
  quoted_comment = sql_quote (comment);
  sql ("UPDATE configs SET comment = '%s', modification_time = now ()"
       " WHERE ROWID = %llu;",
       quoted_comment, config);
  g_free (quoted_comment);
  return 0;
}

/**
 * @brief Set the name of a config.
 *
 * @param[in]  config  Config.
 * @param[in]  name    New name.
 *
 * @return 0 success, 1 config with new name exists already, -1 error.
 */
int
manage_set_config_name (config_t config, const char* name)
{
  gchar *quoted_name;
  assert (current_credentials.uuid);
  sql ("BEGIN IMMEDIATE;");
  quoted_name = sql_quote (name);
  if (sql_int (0, 0,
               "SELECT count(*) FROM configs"
               " WHERE name = '%s' AND ROWID != %llu"
               " AND ((owner IS NULL) OR (owner ="
               " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
               quoted_name,
               config,
               current_credentials.uuid))
    {
      sql ("ROLLBACK;");
      return 1;
    }
  sql ("UPDATE configs SET name = '%s', modification_time = now ()"
       " WHERE ROWID = %llu;",
       quoted_name, config);
  g_free (quoted_name);
  sql ("COMMIT;");
  return 0;
}

/**
 * @brief Set the name of a config.
 *
 * @param[in]  config   Config.
 * @param[in]  name     New name.
 * @param[in]  comment  New comment.
 *
 * @return 0 success, 1 config with new name exists already, -1 error.
 */
int
manage_set_config_name_comment (config_t config, const char* name,
                                const char* comment)
{
  gchar *quoted_name, *quoted_comment;
  assert (current_credentials.uuid);
  sql ("BEGIN IMMEDIATE;");
  quoted_name = sql_quote (name);
  quoted_comment = sql_quote (comment);
  if (sql_int (0, 0,
               "SELECT count(*) FROM configs"
               " WHERE name = '%s' AND ROWID != %llu"
               " AND ((owner IS NULL) OR (owner ="
               " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
               quoted_name,
               config,
               current_credentials.uuid))
    {
      sql ("ROLLBACK;");
      return 1;
    }
  sql ("UPDATE configs SET name = '%s', comment = '%s',"
       " modification_time = now ()"
       " WHERE ROWID = %llu;",
       quoted_name, quoted_comment, config);
  g_free (quoted_name);
  g_free (quoted_comment);
  sql ("COMMIT;");
  return 0;
}

/**
 * @brief Set the NVT's selected for a single family of a config.
 *
 * @param[in]  config         Config.
 * @param[in]  family         Family name.
 * @param[in]  selected_nvts  NVT's.
 *
 * @return 0 success, 1 config in use, -1 error.
 */
int
manage_set_config_nvts (config_t config, const char* family,
                        GPtrArray* selected_nvts)
{
  char *selector;
  gchar *quoted_family, *quoted_selector;
  int new_nvt_count = 0, old_nvt_count;

  sql ("BEGIN EXCLUSIVE;");

  if (sql_int (0, 0,
               "SELECT count(*) FROM tasks"
               " WHERE config = %llu AND (hidden = 0 OR hidden = 1);",
               config))
    {
      sql ("ROLLBACK;");
      return 1;
    }

  quoted_family = sql_quote (family);

  selector = config_nvt_selector (config);
  if (selector == NULL)
    {
      /* The config should always have a selector. */
      g_free (quoted_family);
      return -1;
    }

  quoted_selector = sql_quote (selector);

  /* If the family is growing, then exclude all no's, otherwise the family
   * is static, so include all yes's. */

  if (nvt_selector_family_growing (selector,
                                   family,
                                   config_families_growing (config)))
    {
      iterator_t nvts;

      old_nvt_count = nvt_selector_nvt_count (selector, family, 1);

      free (selector);

      /* Clear any NVT selectors for this family from the config. */

      sql ("DELETE FROM nvt_selectors"
           " WHERE name = '%s'"
           " AND type = " G_STRINGIFY (NVT_SELECTOR_TYPE_NVT)
           " AND family = '%s';",
           quoted_selector,
           quoted_family);

      /* Exclude all no's. */

      new_nvt_count = family_nvt_count (family);

      init_nvt_iterator (&nvts, (nvt_t) 0, config, family, NULL, 1, NULL);
      while (next (&nvts))
        {
          const char *oid = nvt_iterator_oid (&nvts);
          gchar *quoted_oid;

          if (member (selected_nvts, oid)) continue;

          quoted_oid = sql_quote (oid);
          sql ("INSERT INTO nvt_selectors"
               " (name, exclude, type, family_or_nvt, family)"
               " VALUES ('%s', 1, "
               G_STRINGIFY (NVT_SELECTOR_TYPE_NVT)
               ", '%s', '%s');",
               quoted_selector,
               quoted_oid,
               quoted_family);
          g_free (quoted_oid);

          new_nvt_count--;
        }
      cleanup_iterator (&nvts);
    }
  else
    {
      old_nvt_count = nvt_selector_nvt_count (selector, family, 0);

      free (selector);

      /* Clear any NVT selectors for this family from the config. */

      sql ("DELETE FROM nvt_selectors"
           " WHERE name = '%s'"
           " AND type = " G_STRINGIFY (NVT_SELECTOR_TYPE_NVT)
           " AND family = '%s';",
           quoted_selector,
           quoted_family);

      /* Include all yes's. */

      if (selected_nvts)
        {
          gchar *nvt;
          new_nvt_count = 0;

          while ((nvt = (gchar*) g_ptr_array_index (selected_nvts,
                                                    new_nvt_count)))
            {
              gchar *quoted_nvt = sql_quote (nvt);
              sql ("INSERT INTO nvt_selectors"
                   " (name, exclude, type, family_or_nvt, family)"
                   " VALUES ('%s', 0, "
                   G_STRINGIFY (NVT_SELECTOR_TYPE_NVT)
                   ", '%s', '%s');",
                   quoted_selector,
                   quoted_nvt,
                   quoted_family);
              g_free (quoted_nvt);
              new_nvt_count++;
            }
        }
    }

  /* Update the cached config info. */

  sql ("UPDATE configs SET family_count = family_count + %i,"
       " nvt_count = nvt_count - %i + %i,"
       " modification_time = now ()"
       " WHERE ROWID = %llu;",
       old_nvt_count == 0
        ? (new_nvt_count == 0 ? 0 : 1)
        : (new_nvt_count == 0 ? -1 : 0),
       old_nvt_count,
       MAX (new_nvt_count, 0),
       config);

  sql ("COMMIT;");

  g_free (quoted_family);
  g_free (quoted_selector);
  return 0;
}

/**
 * @brief Switch between constraining and generating representation.
 *
 * It's up to the caller to start and end a transaction.
 *
 * @param[in]  config        Config name.
 * @param[in]  constraining  1 families currently growing, 0 families currently
 *                           static.
 *
 * @return 0 success, -1 error.
 */
static int
switch_representation (config_t config, int constraining)
{
  char* selector;
  gchar *quoted_selector;

  selector = config_nvt_selector (config);
  if (selector == NULL)
    return -1;
  quoted_selector = sql_quote (selector);

  if (constraining)
    {
      iterator_t families;

      /* Currently constraining the universe. */

      /* Remove the all selector. */

      nvt_selector_remove_selector (quoted_selector,
                                    NULL,
                                    NVT_SELECTOR_TYPE_ALL);

      /* Convert each family. */

      init_family_iterator (&families, 0, NULL, 1);
      while (next (&families))
        {
          const char *family = family_iterator_name (&families);
          if (family)
            {
              gchar *quoted_family = sql_quote (family);
              if (nvt_selector_family_growing (selector, family, 1))
                /* Add a family include. */
                nvt_selector_add (quoted_selector,
                                  quoted_family,
                                  NULL,
                                  0);
              else
                /* Remove the family exclude. */
                nvt_selector_remove_selector (quoted_selector,
                                              quoted_family,
                                              NVT_SELECTOR_TYPE_FAMILY);
              g_free (quoted_family);
            }
        }
      cleanup_iterator (&families);

      /* Update the cached config info. */

      sql ("UPDATE configs SET families_growing = 0 WHERE ROWID = %llu;",
           config);
    }
  else
    {
      iterator_t families;

      /* Currently generating from empty. */

      /* Add the all selector. */

      sql ("INSERT INTO nvt_selectors"
           " (name, exclude, type, family_or_nvt)"
           " VALUES ('%s', 0, 0, 0);",
           quoted_selector);

      /* Convert each family. */

      init_family_iterator (&families, 0, NULL, 1);
      while (next (&families))
        {
          const char *family = family_iterator_name (&families);
          if (family)
            {
              gchar *quoted_family = sql_quote (family);
              if (nvt_selector_family_growing (selector, family, 0))
                /* Remove the family include. */
                nvt_selector_remove_selector (quoted_selector,
                                              quoted_family,
                                              NVT_SELECTOR_TYPE_FAMILY);
              else
                /* Add a family exclude. */
                nvt_selector_add (quoted_selector,
                                  quoted_family,
                                  NULL,
                                  1);
              g_free (quoted_family);
            }
        }
      cleanup_iterator (&families);

      /* Update the cached config info. */

      sql ("UPDATE configs SET families_growing = 1 WHERE ROWID = %llu;",
           config);
    }

  free (selector);
  g_free (quoted_selector);
  return 0;
}

/**
 * @brief Initialise a config task iterator.
 *
 * Iterate over all tasks that use the config.
 *
 * @param[in]  iterator   Iterator.
 * @param[in]  config     Config.
 * @param[in]  ascending  Whether to sort ascending or descending.
 */
void
init_config_task_iterator (iterator_t* iterator, config_t config,
                           int ascending)
{
  assert (current_credentials.uuid);

  init_iterator (iterator,
                 "SELECT name, uuid FROM tasks"
                 " WHERE config = %llu"
                 " AND hidden = 0"
                 " AND ((owner IS NULL) OR (owner ="
                 " (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                 " ORDER BY name %s;",
                 config,
                 current_credentials.uuid,
                 ascending ? "ASC" : "DESC");
}

/**
 * @brief Get the name from a config_task iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (config_task_iterator_name, 0);

/**
 * @brief Get the UUID from a config_task iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return UUID, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (config_task_iterator_uuid, 1);


/* NVT's. */

/**
 * @brief Get the name of an NVT.
 *
 * @param[in]  nvt  NVT.
 *
 * @return Freshly allocated name of NVT if possible, else NULL.
 */
char *
manage_nvt_name (nvt_t nvt)
{
  return sql_string (0, 0, "SELECT name FROM nvts WHERE ROWID = %llu;", nvt);
}

/**
 * @brief Guess the OID of an NVT given a name.
 *
 * @param[in]  name  Name of NVT.
 *
 * @return OID of NVT if possible, else NULL.
 */
char *
nvt_oid (const char *name)
{
  gchar *quoted_name = sql_quote (name);
  char *ret = sql_string (0, 0,
                          "SELECT oid FROM nvts WHERE name = '%s' LIMIT 1;",
                          quoted_name);
  g_free (quoted_name);
  return ret;
}

/**
 * @brief Return number of plugins in the plugin cache.
 *
 * @return Number of plugins.
 */
int
nvts_size ()
{
  return sql_int (0, 0,
                  "SELECT count(*) FROM nvts WHERE family != 'Credentials';");
}

/**
 * @brief Return md5sum of the plugins in the plugin cache.
 *
 * @return Number of plugins if the plugins are cached, else NULL.
 */
char*
nvts_md5sum ()
{
  return sql_string (0, 0,
                     "SELECT value FROM main.meta"
                     " WHERE name = 'nvts_md5sum';");
}

/**
 * @brief Set the md5sum of the plugins in the plugin cache.
 *
 * @param[in]  md5sum  New md5sum.
 *
 * Also queue an update to the nvti cache.
 */
void
set_nvts_md5sum (const char *md5sum)
{
  gchar* quoted = sql_quote (md5sum);
  sql ("INSERT OR REPLACE INTO main.meta (name, value)"
       " VALUES ('nvts_md5sum', '%s');",
       quoted);
  g_free (quoted);

  sql ("UPDATE main.meta SET value = 1 WHERE name = 'update_nvti_cache';");
}

/**
 * @brief Find an NVT given an identifier.
 *
 * @param[in]   oid  An NVT identifier.
 * @param[out]  nvt  NVT return, 0 if succesfully failed to find task.
 *
 * @return FALSE on success (including if failed to find NVT), TRUE on error.
 */
gboolean
find_nvt (const char* oid, nvt_t* nvt)
{
  switch (sql_int64 (nvt, 0, 0,
                     "SELECT ROWID FROM nvts WHERE oid = '%s';",
                     oid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *nvt = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        return TRUE;
        break;
    }

  return FALSE;
}

/**
 * @brief Get the family of an NVT.
 *
 * @param[in]  nvt  NVT.
 *
 * @return Family name if set, else NULL.
 */
char *
nvt_family (nvt_t nvt)
{
  return sql_string (0, 0,
                     "SELECT family FROM nvts WHERE ROWID = %llu LIMIT 1;",
                     nvt);
}

/**
 * @brief Make an nvt from an nvti.
 *
 * @param[in]  nvti    NVTI.
 * @param[in]  remove  Whether to remove the NVT from the cache first.
 *
 * @return An NVT.
 */
nvt_t
make_nvt_from_nvti (const nvti_t *nvti, int remove)
{
  /** @todo Freeing string literals. */
  gchar *quoted_version, *quoted_name, *quoted_summary, *quoted_description;
  gchar *quoted_copyright, *quoted_cve, *quoted_bid, *quoted_xref, *quoted_tag;
  gchar *quoted_cvss_base, *quoted_risk_factor, *quoted_sign_key_ids;
  gchar *quoted_family, *quoted_original_tag;

  if (remove)
    {
      sql ("BEGIN EXCLUSIVE;");
      sql ("DELETE FROM nvts WHERE oid = '%s';", nvti_oid (nvti));
    }

  quoted_version = sql_quote (nvti_version (nvti));
  quoted_name = sql_quote (nvti_name (nvti) ? nvti_name (nvti) : "");
  quoted_summary = sql_quote (nvti_summary (nvti) ? nvti_summary (nvti) : "");
  quoted_description = sql_quote (nvti_description (nvti)
                                  ? nvti_description (nvti)
                                  : "");
  quoted_copyright = sql_quote (nvti_copyright (nvti)
                                ? nvti_copyright (nvti)
                                : "");
  quoted_cve = sql_quote (nvti_cve (nvti) ? nvti_cve (nvti) : "");
  quoted_bid = sql_quote (nvti_bid (nvti) ? nvti_bid (nvti) : "");
  quoted_xref = sql_quote (nvti_xref (nvti) ? nvti_xref (nvti) : "");
  if (nvti_tag (nvti))
    {
      const char *tags;
      gchar **split, **point;
      GString *tag;

      tags = nvti_tag (nvti);

      /* creation_date=2009-04-09 14:18:58 +0200 (Thu, 09 Apr 2009)|... */

      split = g_strsplit (tags, "|", 0);
      point = split;

      while (*point)
        {
          if (((strlen (*point) > strlen ("creation_date"))
               && (strncmp (*point, "creation_date", strlen ("creation_date"))
                   == 0)
               && ((*point)[strlen ("creation_date")] == '='))
              || ((strlen (*point) > strlen ("last_modification"))
                  && (strncmp (*point, "last_modification",
                               strlen ("last_modification"))
                      == 0)
                  && ((*point)[strlen ("last_modification")] == '=')))
            {
              gchar **move;
              move = point;
              g_free (*point);
              while (*move)
                {
                  move[0] = move[1];
                  move++;
                }
            }
          else
            point++;
        }

      point = split;
      tag = g_string_new ("");
      while (*point)
        {
          if (point[1])
            g_string_append_printf (tag, "%s|", *point);
          else
            g_string_append_printf (tag, "%s", *point);
          point++;
        }
      g_strfreev (split);

      quoted_tag = sql_quote (tag->str);
      g_string_free (tag, TRUE);
    }
  else
    quoted_tag = g_strdup ("");
  quoted_original_tag = sql_quote (nvti_tag (nvti) ? nvti_tag (nvti) : "");
  quoted_cvss_base = sql_quote (nvti_cvss_base (nvti)
                                 ? nvti_cvss_base (nvti)
                                 : "");
  quoted_risk_factor = sql_quote (nvti_risk_factor (nvti));
  quoted_sign_key_ids = sql_quote (nvti_sign_key_ids (nvti)
                                   ? nvti_sign_key_ids (nvti)
                                   : "");
  quoted_family = sql_quote (nvti_family (nvti) ? nvti_family (nvti) : "");

  sql ("INSERT into nvts (oid, version, name, summary, description, copyright,"
       " cve, bid, xref, tag, sign_key_ids, category, family, cvss_base,"
       " risk_factor, creation_time, modification_time, uuid)"
       " VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s',"
       " '%s', %i, '%s', '%s', '%s', parse_time (tag ('%s', 'creation_date')),"
       " parse_time (tag ('%s', 'last_modification')), '%s');",
       nvti_oid (nvti),
       quoted_version,
       quoted_name,
       quoted_summary,
       quoted_description,
       quoted_copyright,
       quoted_cve,
       quoted_bid,
       quoted_xref,
       quoted_tag,
       quoted_sign_key_ids,
       nvti_category (nvti),
       quoted_family,
       quoted_cvss_base,
       quoted_risk_factor,
       quoted_original_tag,
       quoted_original_tag,
       nvti_oid (nvti));

  if (remove)
    sql ("COMMIT;");

  g_free (quoted_version);
  g_free (quoted_name);
  g_free (quoted_summary);
  g_free (quoted_description);
  g_free (quoted_copyright);
  g_free (quoted_cve);
  g_free (quoted_bid);
  g_free (quoted_xref);
  g_free (quoted_original_tag);
  g_free (quoted_tag);
  g_free (quoted_cvss_base);
  g_free (quoted_risk_factor);
  g_free (quoted_sign_key_ids);
  g_free (quoted_family);

  return sqlite3_last_insert_rowid (task_db);
}

/**
 * @brief Filter columns for NVT info iterator.
 */
#define NVT_INFO_ITERATOR_FILTER_COLUMNS                                    \
 { GET_ITERATOR_FILTER_COLUMNS, "version", "summary", "cve", "bid", "xref", \
   "family", "cvss_base", "risk_factor", NULL }

/**
 * @brief NVT iterator columns.
 */
#define NVT_ITERATOR_COLUMNS                                           \
  GET_ITERATOR_COLUMNS ", oid, version, name, summary, description,"   \
  " copyright, cve, bid, xref, tag, sign_key_ids, category, family,"   \
  " cvss_base, risk_factor"

/**
 * @brief NVT iterator columns.
 */
#define NVT_ITERATOR_COLUMNS_NVTS                                              \
  GET_ITERATOR_COLUMNS_PREFIX("nvts.") ", oid, version, nvts.name, summary,"   \
  " description, copyright, cve, bid, xref, tag, sign_key_ids, category,"      \
  " nvts.family, cvss_base, risk_factor"

/**
 * @brief Initialise an NVT iterator.
 *
 * @param[in]  iterator    Iterator.
 * @param[in]  get         GET data.
 * @param[in]  name        Name of the info
 *
 * @return 0 success, 1 failed to find NVT, 2 failed to find filter,
 *         -1 error.
 */
int
init_nvt_info_iterator (iterator_t* iterator, get_data_t *get, const char *name)
{
  static const char *filter_columns[] = NVT_INFO_ITERATOR_FILTER_COLUMNS;
  gchar *clause = NULL;
  int ret;

  if (get->id)
    {
      // FIX what for anyway?
      gchar *quoted = sql_quote (get->id);
      clause = g_strdup_printf (" AND uuid = '%s'", quoted);
      g_free (quoted);
    }
  else if (name)
    {
      gchar *quoted = sql_quote (name);
      clause = g_strdup_printf (" AND name = '%s'", quoted);
      g_free (quoted);
      /* The entry is specified by name, so filtering just gets in the way. */
      g_free (get->filter);
      get->filter = NULL;
    }

  ret = init_get_iterator (iterator,
                           "nvt",
                           get,
                           /* Columns. */
                           NVT_ITERATOR_COLUMNS,
                           /* Columns for trashcan. */
                           NULL,
                           filter_columns,
                           NULL,
                           0,
                           NULL,
                           NULL,
                           0);

  g_free (clause);
  return ret;
}

/**
 * @brief Count number of nvt.
 *
 * @param[in]  get  GET params.
 *
 * @return Total number of cpes in filtered set.
 */
int
nvt_info_count (const get_data_t *get)
{
  static const char *extra_columns[] = NVT_INFO_ITERATOR_FILTER_COLUMNS;
  return count ("nvt", get, NVT_ITERATOR_COLUMNS, extra_columns, 0, 0, 0,
                FALSE);
}

/**
 * @brief Initialise an NVT iterator.
 *
 * @param[in]  iterator    Iterator.
 * @param[in]  nvt         NVT to iterate over, all if 0.
 * @param[in]  config      Config to limit selection to.  NULL for all NVTs.
 *                         Overridden by \arg nvt.
 * @param[in]  category    Category to limit selection to.  NULL for all.
 * @param[in]  family      Family to limit selection to.  NULL for all NVTs.
 *                         Overridden by \arg config.
 * @param[in]  ascending   Whether to sort ascending or descending.
 * @param[in]  sort_field  Field to sort on, or NULL for "ROWID".
 */
void
init_nvt_iterator (iterator_t* iterator, nvt_t nvt, config_t config,
                   const char* family, const char *category, int ascending,
                   const char* sort_field)
{
  assert ((nvt && family) == 0);

  if (nvt)
    {
      gchar* sql;
      sql = g_strdup_printf ("SELECT " NVT_ITERATOR_COLUMNS
                             " FROM nvts WHERE ROWID = %llu;",
                             nvt);
      init_iterator (iterator, sql);
      g_free (sql);
    }
  else if (config)
    {
      gchar* sql;
      if (family == NULL) abort ();
      sql = select_config_nvts (config, family, ascending, sort_field);
      if (sql)
        {
          init_iterator (iterator, sql);
          g_free (sql);
        }
      else
        init_iterator (iterator,
                       "SELECT " NVT_ITERATOR_COLUMNS
                       " FROM nvts LIMIT 0;");
    }
  else if (family)
    {
      gchar *quoted_family = sql_quote (family);
      init_iterator (iterator,
                     "SELECT " NVT_ITERATOR_COLUMNS
                     " FROM nvts"
                     " WHERE family = '%s'"
                     " ORDER BY %s %s;",
                     quoted_family,
                     sort_field ? sort_field : "name",
                     ascending ? "ASC" : "DESC");
      g_free (quoted_family);
    }
  else if (category)
    {
      gchar *quoted_category;
      quoted_category = sql_quote (category);
      init_iterator (iterator,
                     "SELECT " NVT_ITERATOR_COLUMNS
                     " FROM nvts"
                     " WHERE category = '%s'"
                     " ORDER BY %s %s;",
                     quoted_category,
                     sort_field ? sort_field : "name",
                     ascending ? "ASC" : "DESC");
      g_free (quoted_category);
    }
  else
    init_iterator (iterator,
                   "SELECT " NVT_ITERATOR_COLUMNS
                   " FROM nvts"
                   " ORDER BY %s %s;",
                   sort_field ? sort_field : "name",
                   ascending ? "ASC" : "DESC");
}

/**
 * @brief Initialise an NVT iterator, for NVTs of a certain CVE.
 *
 * @param[in]  iterator    Iterator.
 * @param[in]  cve         CVE name.
 * @param[in]  ascending   Whether to sort ascending or descending.
 * @param[in]  sort_field  Field to sort on, or NULL for "ROWID".
 */
void
init_cve_nvt_iterator (iterator_t* iterator, const char *cve, int ascending,
                       const char* sort_field)
{
  init_iterator (iterator,
                 "SELECT " NVT_ITERATOR_COLUMNS
                 " FROM nvts"
                 " WHERE cve LIKE '%%%s%%'"
                 " ORDER BY %s %s;",
                 cve ? cve : "",
                 sort_field ? sort_field : "name",
                 ascending ? "ASC" : "DESC");
}

/**
 * @brief Get the OID from an NVT iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return OID, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (nvt_iterator_oid, GET_ITERATOR_COLUMN_COUNT);

/**
 * @brief Get the version from an NVT iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Version, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (nvt_iterator_version, GET_ITERATOR_COLUMN_COUNT + 1);

/**
 * @brief Get the name from an NVT iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (nvt_iterator_name, GET_ITERATOR_COLUMN_COUNT + 2);

/**
 * @brief Get the summary from an NVT iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Summary, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (nvt_iterator_summary, GET_ITERATOR_COLUMN_COUNT + 3);

/**
 * @brief Get the description from an NVT iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Description, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (nvt_iterator_description, GET_ITERATOR_COLUMN_COUNT + 4);

/**
 * @brief Get the copyright from an NVT iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Copyright, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (nvt_iterator_copyright, GET_ITERATOR_COLUMN_COUNT + 5);

/**
 * @brief Get the cve from an NVT iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Cve, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (nvt_iterator_cve, GET_ITERATOR_COLUMN_COUNT + 6);

/**
 * @brief Get the bid from an NVT iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Bid, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (nvt_iterator_bid, GET_ITERATOR_COLUMN_COUNT + 7);

/**
 * @brief Get the xref from an NVT iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Xref, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (nvt_iterator_xref, GET_ITERATOR_COLUMN_COUNT + 8);

/**
 * @brief Get the tag from an NVT iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Tag, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (nvt_iterator_tag, GET_ITERATOR_COLUMN_COUNT + 9);

/**
 * @brief Get the sign_key_ids from an NVT iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Sign_key_ids, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (nvt_iterator_sign_key_ids, GET_ITERATOR_COLUMN_COUNT + 10);

/**
 * @brief Get the category from an NVT iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Category.
 */
int
nvt_iterator_category (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (int) sqlite3_column_int (iterator->stmt,
                                  GET_ITERATOR_COLUMN_COUNT + 11);
  return ret;
}

/**
 * @brief Get the family from an NVT iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Family, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (nvt_iterator_family, GET_ITERATOR_COLUMN_COUNT + 12);

/**
 * @brief Get the cvss_base from an NVT iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Cvss_base, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (nvt_iterator_cvss_base, GET_ITERATOR_COLUMN_COUNT + 13);

/**
 * @brief Get the risk_factor from an NVT iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Risk_factor, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (nvt_iterator_risk_factor, GET_ITERATOR_COLUMN_COUNT + 14);

/**
 * @brief Get the number of NVTs in one or all families.
 *
 * @param[in]  family  Family name.  NULL for all families.
 *
 * @return Number of NVTs in family, or total number of nvts.
 */
int
family_nvt_count (const char *family)
{
  gchar *quoted_family;

  if (family == NULL)
    {
      static int nvt_count = -1;
      if (nvt_count == -1)
        nvt_count = sql_int (0, 0,
                             "SELECT COUNT(*) FROM nvts"
                             " WHERE family != 'Credentials';");
      return nvt_count;
    }

  quoted_family = sql_quote (family);
  int ret = sql_int (0, 0,
                     "SELECT COUNT(*) FROM nvts WHERE family = '%s';",
                     quoted_family);
  g_free (quoted_family);
  return ret;
}

/**
 * @brief Get the number of families.
 *
 * @return Total number of families.
 */
int
family_count ()
{
  return sql_int (0, 0,
                  "SELECT COUNT(distinct family) FROM nvts"
                  " WHERE family != 'Credentials';");
}

/**
 * @brief Update the cached count and growing information in a config.
 *
 * It's up to the caller to organise a transaction.
 *
 * @param[in]  configs  Config to update.
 */
static void
update_config_cache (iterator_t *configs)
{
  const char *selector;
  gchar *quoted_selector, *quoted_name;
  int families_growing;

  quoted_name = sql_quote (config_iterator_name (configs));
  selector = config_iterator_nvt_selector (configs);
  families_growing = nvt_selector_families_growing (selector);
  quoted_selector = sql_quote (selector);

  sql ("UPDATE configs"
       " SET family_count = %i, nvt_count = %i,"
       " families_growing = %i, nvts_growing = %i"
       " WHERE name = '%s';",
       nvt_selector_family_count (quoted_selector, families_growing),
       nvt_selector_nvt_count (quoted_selector, NULL, families_growing),
       families_growing,
       nvt_selector_nvts_growing_2 (quoted_selector, families_growing),
       quoted_name);

  g_free (quoted_name);
  g_free (quoted_selector);
}

/**
 * @brief Update the cached count and growing information in every config.
 *
 * Only consider configs for the current user.
 *
 * It's up to the caller to organise a transaction.
 *
 * @param[in]  config  Config to update.  0 for all.
 */
static void
update_config_caches (config_t config)
{
  iterator_t configs;

  init_user_config_iterator (&configs, config, 0, 1, NULL);
  while (next (&configs))
    update_config_cache (&configs);
  cleanup_iterator (&configs);
}

/**
 * @brief Update count and growing info in every config across all users.
 *
 * It's up to the caller to organise a transaction.
 */
static void
update_all_config_caches ()
{
  iterator_t configs;

  init_iterator (&configs, "SELECT " CONFIG_ITERATOR_COLUMNS " FROM configs;");
  while (next (&configs))
    update_config_cache (&configs);
  cleanup_iterator (&configs);
}

/**
 * @brief Complete an update of the NVT cache.
 *
 * @param[in]  mode  -1 updating, -2 rebuilding.
 */
void
manage_complete_nvt_cache_update (int mode)
{
  iterator_t configs;

  /* Remove preferences from configs where the preference has vanished from
   * the associated NVT. */
  init_iterator (&configs, "SELECT ROWID FROM configs;");
  while (next (&configs))
    sql ("DELETE FROM config_preferences"
         " WHERE config = %llu"
         " AND type = 'PLUGINS_PREFS'"
         " AND name NOT IN (SELECT nvt_preferences.name FROM nvt_preferences);",
         config_iterator_config (&configs));
  cleanup_iterator (&configs);

  update_all_config_caches ();
  if (mode == -2) sql ("COMMIT;");
}


/* NVT selectors.
 *
 * An NVT selector is a named selection of NVT's from the cache of all
 * NVT's.
 *
 * An NVT selector is made up of zero or more selectors.  The selectors
 * combine in ROWID order to make a selection.  Depending on the choice
 * of selectors the selection can be static or growing.  A growing
 * selection can grow when new NVT's enter the NVT cache, either because it
 * selects new families or because it selects new NVT's within exising
 * families.
 *
 * There are three types of selectors that an NVT selector can contain.
 *
 *   1) The "all selector", which selects all families and all NVT's in
 *      those families.  The only way to construct the NVT selector so
 *      that it grows to includes new families, is to add this selector.
 *
 *   2) A "family" selector, which designates an entire family.
 *
 *   3) An "NVT" selector, which designates a single NVT.
 *
 *      The naming overlaps here.  It's a selector of type NVT, which is
 *      part of an "NVT selector" (a named collection of selectors).
 *
 * The family and NVT type selectors can either include or exclude the
 * designated NVT's.
 *
 * While the all selector provides a way to select every single NVT, the
 * empty NVT selector corresponds to an empty NVT set.
 *
 * The selectors provide a mechanism to select a wide range of NVT
 * combinations.  The mechanism allows for complex selections involving
 * redundant selectors.  The Manager, however, only implements a simple
 * subset of the possible combinations of selectors.  This simple subset
 * is split into two cases.
 *
 *   1) Constraining the universe.
 *
 *      The all selector and an optional exclude for each family,
 *      optional NVT includes in the excluded families, and optional NVT
 *      includes in all other families.
 *
 *      This allows a growing collection of families, while any family
 *      can still have a static NVT selection.
 *
 *   2) Generating from empty.
 *
 *      An empty set of selectors with an optional include for each family,
 *      optional NVT excludes in the included families, and optional NVT
 *      includes in all other families.
 *
 *      This allows a static collection of families, while any family
 *      can still grow when new NVT's enter the family.
 *
 * Either case allows one or more NVT's to be excluded from the family, both
 * when the family is growing and when the family is static.
 */

/* These could handle strange cases, like when a family is
 * included then excluded, or all is included then later excluded.
 * However, OMP prevents those cases from occuring. */

/**
 * @brief Get the number of families selected by an NVT selector.
 *
 * A growing family which has all current NVT's excluded is still
 * considered as selected by the NVT selector.
 *
 * @param[in]  quoted_selector   SQL-quoted selector name.
 * @param[in]  families_growing  1 if families are growing, else 0.
 *
 * @return The number of families selected by an NVT selector.
 */
static int
nvt_selector_family_count (const char* quoted_selector, int families_growing)
{
  if (families_growing)
    /* Assume the only family selectors are excludes. */
    return family_count ()
           - sql_int (0, 0,
                      "SELECT COUNT(distinct family_or_nvt) FROM nvt_selectors"
                      " WHERE name = '%s'"
                      " AND type = " G_STRINGIFY (NVT_SELECTOR_TYPE_FAMILY)
                      " AND exclude = 0"
                      " LIMIT 1;",
                      quoted_selector);

  /* Assume that the only family selectors are includes, and that if a
   * selection has any NVT includes then it only has NVT includes. */
  return sql_int (0, 0,
                  "SELECT COUNT(*) FROM nvt_selectors"
                  " WHERE name = '%s'"
                  " AND type = " G_STRINGIFY (NVT_SELECTOR_TYPE_FAMILY)
                  " AND exclude = 0"
                  " LIMIT 1;",
                  quoted_selector)
         + sql_int (0, 0,
                    "SELECT COUNT(DISTINCT family) FROM nvt_selectors"
                    " WHERE name = '%s'"
                    " AND type = " G_STRINGIFY (NVT_SELECTOR_TYPE_NVT)
                    " AND exclude = 0"
                    " AND family NOT NULL"
                    " LIMIT 1;",
                    quoted_selector);
}

/**
 * @brief Get the family growth status of an NVT selector.
 *
 * @param[in]  selector  NVT selector.
 *
 * @return 1 growing, 0 static.
 */
static int
nvt_selector_families_growing (const char* selector)
{
  /** @todo Quote selector. */
  /* The number of families can only grow if there is selector that includes
   * all. */
#if 0
  return sql_int (0, 0,
                  "SELECT COUNT(*) FROM nvt_selectors"
                  " WHERE name = '%s'"
                  " AND type = " G_STRINGIFY (NVT_SELECTOR_TYPE_ALL)
                  " AND exclude = 0"
                  " LIMIT 1;",
                  selector);
#else
  char *string;
  string = sql_string (0, 0,
                       "SELECT name FROM nvt_selectors"
                       " WHERE name = '%s'"
                       " AND type = " G_STRINGIFY (NVT_SELECTOR_TYPE_ALL)
                       " AND exclude = 0"
                       " LIMIT 1;",
                       selector);
  if (string == NULL) return 0;
  free (string);
  return 1;
#endif
}

/**
 * @brief Get the NVT growth status of an NVT selector.
 *
 * @param[in]  quoted_selector   SQL-quoted selector name.
 * @param[in]  families_growing  1 if families are growing, else 0.
 *
 * @return 1 growing, 0 static.
 */
static int
nvt_selector_nvts_growing_2 (const char* quoted_selector, int families_growing)
{
  if (families_growing)
    /* Assume the only family selectors are excludes. */
    return (family_count ()
            - sql_int (0, 0,
                       "SELECT COUNT(distinct family_or_nvt) FROM nvt_selectors"
                       " WHERE name = '%s'"
                       " AND type = " G_STRINGIFY (NVT_SELECTOR_TYPE_FAMILY)
                       " AND exclude = 0"
                       " LIMIT 1;",
                       quoted_selector))
           > 0;

  /* Assume the only family selectors are includes. */
  return sql_int (0, 0,
                  "SELECT COUNT(*) FROM nvt_selectors"
                  " WHERE name = '%s'"
                  " AND type = " G_STRINGIFY (NVT_SELECTOR_TYPE_FAMILY)
                  " AND exclude = 0"
                  " LIMIT 1;",
                  quoted_selector)
         > 0;
}

/**
 * @brief Get the NVT growth status of an NVT selector.
 *
 * @param[in]  selector   Selector name.
 *
 * @return 1 growing, 0 static.
 */
static int
nvt_selector_nvts_growing (const char* selector)
{
  int ret;
  gchar *quoted_selector = sql_quote (selector);
  ret = nvt_selector_nvts_growing_2 (quoted_selector,
                                     nvt_selector_families_growing (selector));
  g_free (quoted_selector);
  return ret;
}

/** @todo Move these config functions to the config section. */

/**
 * @brief Get the NVT growth status of a config.
 *
 * @param[in]  config  Config.
 *
 * @return 1 growing, 0 static.
 */
int
config_nvts_growing (config_t config)
{
  return sql_int (0, 0,
                  "SELECT nvts_growing FROM configs"
                  " WHERE ROWID = %llu;",
                  config);
}

/**
 * @brief Get the family growth status of a config.
 *
 * @param[in]  config  Config.
 *
 * @return 1 growing, 0 static.
 */
int
config_families_growing (config_t config)
{
  return sql_int (0, 0,
                  "SELECT families_growing FROM configs"
                  " WHERE ROWID = %llu;",
                  config);
}

/**
 * @brief Initialise an NVT selector iterator.
 *
 * @param[in]  iterator  Iterator.
 * @param[in]  selector  Name of single selector to iterate over, NULL for all.
 * @param[in]  config    Config to limit iteration to, 0 for all.
 * @param[in]  type      Type of selector.  All if config is given.
 */
void
init_nvt_selector_iterator (iterator_t* iterator, const char* selector,
                            config_t config, int type)
{
  gchar *sql;

  assert (selector ? config == 0 : (config ? selector == NULL : 1));
  assert (config ? type == NVT_SELECTOR_TYPE_ANY : (type >= 0 && type <= 2));

  if (selector)
    {
      gchar *quoted_selector = sql_quote (selector);
      sql = g_strdup_printf ("SELECT exclude, family_or_nvt, name, type"
                             " FROM nvt_selectors"
                             " WHERE name = '%s' AND type = %i;",
                             quoted_selector,
                             type);
      g_free (quoted_selector);
    }
  else if (config)
    sql = g_strdup_printf ("SELECT exclude, family_or_nvt, name, type"
                           " FROM nvt_selectors"
                           " WHERE name ="
                           " (SELECT nvt_selector FROM configs"
                           "  WHERE configs.ROWID = %llu);",
                           config);
  else
    sql = g_strdup_printf ("SELECT exclude, family_or_nvt, name, type"
                           " FROM nvt_selectors"
                           " WHERE type = %i;",
                           type);
  init_iterator (iterator, sql);
  g_free (sql);
}

/**
 * @brief Get whether the selector rule is an include rule.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return -1 if iteration is complete, 1 if include, else 0.
 */
int
nvt_selector_iterator_include (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (int) sqlite3_column_int (iterator->stmt, 0);
  return ret == 0;
}

/**
 * @brief Get the NVT or family from an NVT selector iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return NVT selector, or NULL if iteration is complete.
 */
DEF_ACCESS (nvt_selector_iterator_nvt, 1);

/**
 * @brief Get the name from an NVT selector iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return NVT selector, or NULL if iteration is complete.
 */
DEF_ACCESS (nvt_selector_iterator_name, 2);

/**
 * @brief Get the type from an NVT selector.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return -1 if iteration is complete, 1 if include, else 0.
 */
int
nvt_selector_iterator_type (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (int) sqlite3_column_int (iterator->stmt, 3);
  return ret;
}

/**
 * @brief Get the number of families included in a config.
 *
 * @param[in]  config  Config.
 *
 * @return Family count if known, else -1.
 */
int
config_family_count (config_t config)
{
  return sql_int (0, 0,
                  "SELECT family_count FROM configs"
                  " WHERE ROWID = %llu"
                  " LIMIT 1;",
                  config);
}

/**
 * @brief Get the number of families included in a trashcan config.
 *
 * @param[in]  config  Config.
 *
 * @return Family count if known, else -1.
 */
int
trash_config_family_count (config_t config)
{
  return sql_int (0, 0,
                  "SELECT family_count FROM configs_trash"
                  " WHERE ROWID = %llu"
                  " LIMIT 1;",
                  config);
}

/**
 * @brief Get the number of NVTs included in a config.
 *
 * @param[in]  config  Config.
 *
 * @return NVT count if known, else -1.
 */
int
config_nvt_count (config_t config)
{
  return sql_int (0, 0,
                  "SELECT nvt_count FROM configs"
                  " WHERE ROWID = %llu"
                  " LIMIT 1;",
                  config);
}

/**
 * @brief Get the number of NVTs included in a trashcan config.
 *
 * @param[in]  config  Config.
 *
 * @return NVT count if known, else -1.
 */
int
trash_config_nvt_count (config_t config)
{
  return sql_int (0, 0,
                  "SELECT nvt_count FROM configs_trash"
                  " WHERE ROWID = %llu"
                  " LIMIT 1;",
                  config);
}

/**
 * @brief Initialise an NVT selector family iterator.
 *
 * @param[in]  iterator   Iterator.
 * @param[in]  all        True if families are growing in the selector, else 0.
 *                        Only considered with a selector.
 * @param[in]  selector   Name of NVT selector.  NULL for all families.
 * @param[in]  ascending  Whether to sort ascending or descending.
 */
void
init_family_iterator (iterator_t* iterator, int all, const char* selector,
                      int ascending)
{
  gchar *quoted_selector;

  if (selector == NULL)
    {
      init_iterator (iterator,
                     "SELECT distinct family FROM nvts"
                     " WHERE family != 'Credentials'"
                     " ORDER BY family %s;",
                     ascending ? "ASC" : "DESC");
      return;
    }

  quoted_selector = sql_quote (selector);
  if (all)
    /* Constraining the universe.  Presume there is a family exclude for
     * every NVT include. */
    init_iterator (iterator,
                   "SELECT distinct family FROM nvts"
                   " WHERE family != 'Credentials'"
                   " EXCEPT"
                   " SELECT distinct family FROM nvt_selectors"
                   " WHERE type = " G_STRINGIFY (NVT_SELECTOR_TYPE_FAMILY)
                   " AND exclude = 1"
                   " AND name = '%s'"
                   " UNION"
                   " SELECT distinct family FROM nvt_selectors"
                   " WHERE type = " G_STRINGIFY (NVT_SELECTOR_TYPE_NVT)
                   " AND exclude = 0"
                   " AND name = '%s'"
                   " ORDER BY family %s;",
                   quoted_selector,
                   quoted_selector,
                   ascending ? "ASC" : "DESC");
  else
    /* Generating from empty.  Presume any exclude is covered by an include. */
    init_iterator (iterator,
                   "SELECT distinct family FROM nvt_selectors"
                   " WHERE (type = 1 OR type = 2) AND name = '%s'"
                   " AND family != 'Credentials'"
                   " ORDER BY family %s;",
                   quoted_selector,
                   ascending ? "ASC" : "DESC");
  g_free (quoted_selector);
}

/**
 * @brief Get the name from a family iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (family_iterator_name, 0);

/**
 * @brief Get whether an NVT selector family is growing.
 *
 * @param[in]  selector  NVT selector.
 * @param[in]  family    Family name.
 * @param[in]  all       True if selector is an "all" selector, else 0.
 *
 * @return 1 growing, 0 static.
 */
int
nvt_selector_family_growing (const char *selector,
                             const char *family,
                             int all)
{
  int ret;
  gchar *quoted_family;
  gchar *quoted_selector;

  quoted_selector = sql_quote (selector);
  quoted_family = sql_quote (family);

  if (all)
    {
      /* Constraining the universe.  It's static if there is a family
       * exclude. */

      ret = sql_int (0, 0,
                     "SELECT COUNT(*) FROM nvt_selectors"
                     " WHERE name = '%s'"
                     " AND type = " G_STRINGIFY (NVT_SELECTOR_TYPE_FAMILY)
                     " AND family_or_nvt = '%s'"
                     " AND exclude = 1"
                     " LIMIT 1;",
                     quoted_selector,
                     quoted_family);

      g_free (quoted_selector);
      g_free (quoted_family);

      return ret ? 0 : 1;
    }

  /* Generating from empty.  It's growing if there is a family include. */

  ret = sql_int (0, 0,
                 "SELECT COUNT(*) FROM nvt_selectors"
                 " WHERE name = '%s'"
                 " AND type = " G_STRINGIFY (NVT_SELECTOR_TYPE_FAMILY)
                 " AND family_or_nvt = '%s'"
                 " AND exclude = 0"
                 " LIMIT 1;",
                 quoted_selector,
                 quoted_family);

  g_free (quoted_selector);
  g_free (quoted_family);

  return ret ? 1 : 0;
}

/**
 * @brief Get the number of NVTs selected by an NVT selector.
 *
 * @param[in]  selector  NVT selector.
 * @param[in]  family    Family name.  NULL for all.
 * @param[in]  growing   True if the given family is growing, else 0.
 *                       If \param family is NULL, true if the the families
 *                       are growing, else 0.
 *
 * @return Number of NVTs selected in one or all families.
 */
int
nvt_selector_nvt_count (const char *selector,
                        const char *family,
                        int growing)
{
  if (family)
    {
      int ret;

      /* Count in a single family. */

      if (growing)
        {
          gchar *quoted_family = sql_quote (family);
          gchar *quoted_selector = sql_quote (selector);
          ret = sql_int (0, 0,
                         "SELECT COUNT(*) FROM nvts WHERE family = '%s';",
                         quoted_family);
          ret -= sql_int (0, 0,
                          "SELECT COUNT(*) FROM nvt_selectors"
                          " WHERE exclude = 1 AND type = 2"
                          " AND name = '%s' AND family = '%s';",
                          quoted_selector,
                          quoted_family);
          g_free (quoted_family);
          g_free (quoted_selector);
        }
      else
        {
          gchar *quoted_selector = sql_quote (selector);
          gchar *quoted_family = sql_quote (family);
          ret = sql_int (0, 0,
                         "SELECT COUNT(*) FROM nvt_selectors"
                         " WHERE exclude = 0 AND type = 2"
                         " AND name = '%s' AND family = '%s';",
                         quoted_selector,
                         quoted_family);
          g_free (quoted_family);
          g_free (quoted_selector);
        }

      return ret;
   }
 else
   {
     int count;
     iterator_t families;

     /* Count in each family. */

     count = 0;
     init_family_iterator (&families, 0, NULL, 1);
     while (next (&families))
       {
         const char *family = family_iterator_name (&families);
         if (family)
           count += nvt_selector_nvt_count (selector,
                                            family,
                                            nvt_selector_family_growing
                                             (selector, family, growing));
       }
     cleanup_iterator (&families);

     return count;
   }
}

/**
 * @brief Return SQL for selecting NVT's of a config from one family.
 *
 * @param[in]  config      Config.
 * @param[in]  family      Family to limit selection to.
 * @param[in]  ascending   Whether to sort ascending or descending.
 * @param[in]  sort_field  Field to sort on, or NULL for "nvts.ROWID".
 *
 * @return Freshly allocated SELECT statement on success, or NULL on error.
 */
static gchar*
select_config_nvts (const config_t config, const char* family, int ascending,
                    const char* sort_field)
{
  gchar *quoted_selector;
  char *selector = config_nvt_selector (config);
  if (selector == NULL)
    /* The config should always have a selector. */
    return NULL;

  /** @todo Free. */
  quoted_selector = sql_quote (selector);
  free (selector);

  /** @todo Quote family. */

  if (config_nvts_growing (config))
    {
      int constraining;

      /* The number of NVT's can increase. */

      constraining = config_families_growing (config);

      if (constraining)
        {
          /* Constraining the universe. */

          if (sql_int (0, 0,
                        "SELECT COUNT(*) FROM nvt_selectors WHERE name = '%s';",
                        quoted_selector)
              == 1)
            /* There is one selector, it should be the all selector. */
            return g_strdup_printf
                    ("SELECT " NVT_ITERATOR_COLUMNS
                     " FROM nvts WHERE family = '%s'"
                     " ORDER BY %s %s;",
                     family,
                     sort_field ? sort_field : "name",
                     ascending ? "ASC" : "DESC");

          /* There are multiple selectors. */

          if (sql_int (0, 0,
                       "SELECT COUNT(*) FROM nvt_selectors"
                       " WHERE name = '%s' AND exclude = 1"
                       " AND type = "
                       G_STRINGIFY (NVT_SELECTOR_TYPE_FAMILY)
                       " AND family_or_nvt = '%s'"
                       ";",
                       quoted_selector,
                       family))
            /* The family is excluded, just iterate the NVT includes. */
            return g_strdup_printf
                    ("SELECT " NVT_ITERATOR_COLUMNS_NVTS
                     " FROM nvts, nvt_selectors"
                     " WHERE"
                     " nvts.family = '%s'"
                     " AND nvt_selectors.name = '%s'"
                     " AND nvt_selectors.family = '%s'"
                     " AND nvt_selectors.type = "
                     G_STRINGIFY (NVT_SELECTOR_TYPE_NVT)
                     " AND nvt_selectors.exclude = 0"
                     " AND nvts.oid == nvt_selectors.family_or_nvt"
                     " ORDER BY %s %s;",
                     family,
                     quoted_selector,
                     family,
                     sort_field ? sort_field : "nvts.name",
                     ascending ? "ASC" : "DESC");

          /* The family is included.  Iterate all NVT's minus excluded NVT's. */
          return g_strdup_printf
                  ("SELECT " NVT_ITERATOR_COLUMNS
                   " FROM nvts"
                   " WHERE family = '%s'"
                   " EXCEPT"
                   " SELECT " NVT_ITERATOR_COLUMNS_NVTS
                   " FROM nvt_selectors, nvts"
                   " WHERE"
                   " nvts.family = '%s'"
                   " AND nvt_selectors.name = '%s'"
                   " AND nvt_selectors.family = '%s'"
                   " AND nvt_selectors.type = "
                   G_STRINGIFY (NVT_SELECTOR_TYPE_NVT)
                   " AND nvt_selectors.exclude = 1"
                   " AND nvts.oid == nvt_selectors.family_or_nvt"
                   " ORDER BY %s %s;",
                   family,
                   family,
                   quoted_selector,
                   family,
                   sort_field ? sort_field : "nvts.name",
                   ascending ? "ASC" : "DESC");
        }
      else
        {
          int all;

          /* Generating from empty. */

          all = sql_int (0, 0,
                         "SELECT COUNT(*) FROM nvt_selectors"
                         " WHERE name = '%s' AND exclude = 0"
                         " AND type = "
                         G_STRINGIFY (NVT_SELECTOR_TYPE_FAMILY)
                         " AND family_or_nvt = '%s';",
                         quoted_selector,
                         family);

          if (all)
            /* There is a family include for this family. */
            return g_strdup_printf
                    ("SELECT " NVT_ITERATOR_COLUMNS
                     " FROM nvts"
                     " WHERE family = '%s'"
                     " EXCEPT"
                     " SELECT " NVT_ITERATOR_COLUMNS_NVTS
                     " FROM nvt_selectors, nvts"
                     " WHERE"
                     " nvts.family = '%s'"
                     " AND nvt_selectors.name = '%s'"
                     " AND nvt_selectors.family = '%s'"
                     " AND nvt_selectors.type = "
                     G_STRINGIFY (NVT_SELECTOR_TYPE_NVT)
                     " AND nvt_selectors.exclude = 1"
                     " AND nvts.oid == nvt_selectors.family_or_nvt"
                     " ORDER BY %s %s;",
                     family,
                     family,
                     quoted_selector,
                     family,
                     sort_field ? sort_field : "nvts.name",
                     ascending ? "ASC" : "DESC");

          return g_strdup_printf
                  (" SELECT " NVT_ITERATOR_COLUMNS_NVTS
                   " FROM nvt_selectors, nvts"
                   " WHERE"
                   " nvts.family = '%s'"
                   " AND nvt_selectors.name = '%s'"
                   " AND nvt_selectors.family = '%s'"
                   " AND nvt_selectors.type = "
                   G_STRINGIFY (NVT_SELECTOR_TYPE_NVT)
                   " AND nvt_selectors.exclude = 0"
                   " AND nvts.oid == nvt_selectors.family_or_nvt"
                   " ORDER BY %s %s;",
                   family,
                   quoted_selector,
                   family,
                   sort_field ? sort_field : "nvts.name",
                   ascending ? "ASC" : "DESC");
        }
    }
  else
    {
      gchar *sql, *quoted_family;

      /* The number of NVT's is static.  Assume a simple list of NVT
       * includes. */

      quoted_family = sql_quote (family);
      sql = g_strdup_printf
             ("SELECT " NVT_ITERATOR_COLUMNS_NVTS
              " FROM nvt_selectors, nvts"
              " WHERE nvts.family = '%s'"
              " AND nvt_selectors.exclude = 0"
              " AND nvt_selectors.type = " G_STRINGIFY (NVT_SELECTOR_TYPE_NVT)
              " AND nvt_selectors.name = '%s'"
              " AND nvts.oid = nvt_selectors.family_or_nvt"
              " ORDER BY %s %s;",
              quoted_family,
              quoted_selector,
              sort_field ? sort_field : "nvts.ROWID",
              ascending ? "ASC" : "DESC");
      g_free (quoted_family);

      return sql;
    }
}

/**
 * @brief Remove all selectors of a certain family from an NVT selector.
 *
 * @param[in]  quoted_selector  SQL-quoted selector name.
 * @param[in]  quoted_family    SQL-quoted family name.
 * @param[in]  type             Selector type to remove.
 *
 * @return 0 success, -1 error.
 */
static void
nvt_selector_remove (const char* quoted_selector,
                     const char* quoted_family,
                     int type)
{
  if (type == NVT_SELECTOR_TYPE_ANY)
    sql ("DELETE FROM nvt_selectors"
         " WHERE name = '%s'"
         " AND"
         " ((type = " G_STRINGIFY (NVT_SELECTOR_TYPE_NVT)
         "   AND family = '%s')"
         "  OR (type = " G_STRINGIFY (NVT_SELECTOR_TYPE_FAMILY)
         "      AND family_or_nvt = '%s'));",
         quoted_selector,
         quoted_family,
         quoted_family);
  else if (type == NVT_SELECTOR_TYPE_NVT)
    sql ("DELETE FROM nvt_selectors"
         " WHERE name = '%s'"
         " AND type = " G_STRINGIFY (NVT_SELECTOR_TYPE_NVT)
         " AND family = '%s';",
         quoted_selector,
         quoted_family);
  else if (type == NVT_SELECTOR_TYPE_FAMILY)
    sql ("DELETE FROM nvt_selectors"
         " WHERE name = '%s'"
         " AND type = " G_STRINGIFY (NVT_SELECTOR_TYPE_FAMILY)
         " AND family_or_nvt = '%s';",
         quoted_selector,
         quoted_family);
}

/**
 * @brief Remove all selectors of a certain type from an NVT selector.
 *
 * @param[in]  quoted_selector  SQL-quoted selector name.
 * @param[in]  family_or_nvt    SQL-quoted family name or NVT UUID.
 * @param[in]  type             Selector type to remove.
 *
 * @return 0 success, -1 error.
 */
static void
nvt_selector_remove_selector (const char* quoted_selector,
                              const char* family_or_nvt,
                              int type)
{
  if (type == NVT_SELECTOR_TYPE_ANY)
    sql ("DELETE FROM nvt_selectors"
         " WHERE name = '%s' AND family_or_nvt = '%s');",
         quoted_selector,
         family_or_nvt);
  else if (type == NVT_SELECTOR_TYPE_ALL)
    sql ("DELETE FROM nvt_selectors"
         " WHERE name = '%s'"
         " AND type = " G_STRINGIFY (NVT_SELECTOR_TYPE_ALL) ";",
         quoted_selector);
  else
    sql ("DELETE FROM nvt_selectors"
         " WHERE name = '%s'"
         " AND type = %i"
         " AND family_or_nvt = '%s';",
         quoted_selector,
         type,
         family_or_nvt);
}

/**
 * @brief Add a selector to an NVT selector.
 *
 * @param[in]  quoted_selector  SQL-quoted selector name.
 * @param[in]  quoted_family_or_nvt  SQL-quoted family or NVT name.
 * @param[in]  quoted_family    SQL-quoted family name (NULL for families).
 * @param[in]  exclude          1 exclude selector, 0 include selector.
 *
 * @return 0 success, -1 error.
 */
static void
nvt_selector_add (const char* quoted_selector,
                  const char* quoted_family_or_nvt,
                  const char* quoted_family,
                  int exclude)
{
  if (quoted_family == NULL)
    sql ("INSERT INTO nvt_selectors"
         " (name, exclude, type, family_or_nvt, family)"
         " VALUES ('%s', %i, "
         G_STRINGIFY (NVT_SELECTOR_TYPE_FAMILY)
         ", '%s', '%s');",
         quoted_selector,
         exclude,
         quoted_family_or_nvt,
         quoted_family_or_nvt);
  else
    sql ("INSERT INTO nvt_selectors"
         " (name, exclude, type, family_or_nvt, family)"
         " VALUES ('%s', %i, "
         G_STRINGIFY (NVT_SELECTOR_TYPE_NVT)
         ", '%s', '%s');",
         quoted_selector,
         exclude,
         quoted_family_or_nvt,
         quoted_family);
}

/**
 * @brief Check whether a family is selected.
 *
 * Only works for "generating from empty" selection.
 *
 * @param[in]  quoted_selector  SQL-quoted selector name.
 * @param[in]  quoted_family    SQL-quoted family name (NULL for families).
 *
 * @return 1 if selected, else 0.
 */
static int
family_is_selected (const char* quoted_selector, const char* quoted_family)
{
  return sql_int (0, 0,
                  "SELECT count(*) FROM nvt_selectors"
                  " WHERE name = '%s'"
                  " AND (type = " G_STRINGIFY (NVT_SELECTOR_TYPE_NVT)
                  "      AND family = '%s')"
                  " OR (type = " G_STRINGIFY (NVT_SELECTOR_TYPE_FAMILY)
                  "     AND family_or_nvt = '%s');",
                  quoted_selector,
                  quoted_family,
                  quoted_family);
}

/**
 * @brief Check whether an NVT selector has a particular selector.
 *
 * @param[in]  quoted_selector  SQL-quoted selector name.
 * @param[in]  family_or_nvt    SQL-quoted UUID of NVT, or family name.
 * @param[in]  type             Selector type.
 * @param[in]  exclude          1 exclude, 0 include.
 *
 * @return 1 if contains include/exclude, else 0.
 */
static int
nvt_selector_has (const char* quoted_selector, const char* family_or_nvt,
                  int type, int exclude)
{
  return sql_int (0, 0,
                  "SELECT count(*) FROM nvt_selectors"
                  " WHERE name = '%s'"
                  " AND type = %i"
                  " AND exclude = %i"
                  " AND family_or_nvt = '%s'"
                  " LIMIT 1;",
                  quoted_selector,
                  type,
                  exclude,
                  family_or_nvt);
}

/**
 * @brief Refresh NVT selection of a config from given families.
 *
 * @param[in]  config                Config.
 * @param[in]  growing_all_families  Growing families with all selection.
 * @param[in]  static_all_families   Static families with all selection.
 * @param[in]  growing_families      The rest of the growing families.
 * @param[in]  grow_families         1 if families should grow, else 0.
 *
 * @return 0 success, config in use, -1 error.
 */
int
manage_set_config_families (config_t config,
                            GPtrArray* growing_all_families,
                            GPtrArray* static_all_families,
                            GPtrArray* growing_families,
                            int grow_families)
{
  iterator_t families;
  gchar *quoted_selector;
  int constraining;
  char *selector;

  sql ("BEGIN EXCLUSIVE;");

  if (sql_int (0, 0,
               "SELECT count(*) FROM tasks"
               " WHERE config = %llu AND (hidden = 0 OR hidden = 1);",
               config))
    {
      sql ("ROLLBACK;");
      return 1;
    }

  constraining = config_families_growing (config);

  if (constraining + grow_families == 1)
    {
      if (switch_representation (config, constraining))
        {
          sql ("ROLLBACK;");
          return -1;
        }
      constraining = constraining == 0;
    }

  selector = config_nvt_selector (config);
  if (selector == NULL)
    {
      /* The config should always have a selector. */
      sql ("ROLLBACK;");
      return -1;
    }
  quoted_selector = sql_quote (selector);

  /* Loop through all the known families. */

  init_family_iterator (&families, 1, NULL, 1);
  while (next (&families))
    {
      const char *family;

      family = family_iterator_name (&families);
      if (family)
        {
          int old_nvt_count, new_nvt_count = 0, was_selected, max_nvt_count;
          int family_growing;
          int growing_all = member (growing_all_families, family);
          int static_all = member (static_all_families, family);
          gchar *quoted_family = sql_quote (family);

          assert ((growing_all && static_all) == 0);

          family_growing = nvt_selector_family_growing (selector,
                                                        family,
                                                        constraining);

          old_nvt_count
            = nvt_selector_nvt_count (selector, family, family_growing);

          max_nvt_count = family_nvt_count (family);

          if (growing_all || static_all)
            {
              if (old_nvt_count == max_nvt_count
                  && ((growing_all && family_growing)
                      || (static_all && family_growing == 0)))
                {
                  /* Already in required state. */
                  g_free (quoted_family);
                  continue;
                }

              was_selected = family_is_selected (quoted_selector,
                                                 quoted_family);

              /* Flush all selectors in the family from the config. */

              nvt_selector_remove (quoted_selector,
                                   quoted_family,
                                   NVT_SELECTOR_TYPE_ANY);

              if (static_all)
                {
                  iterator_t nvts;

                  /* Static selection of all the NVT's currently in the
                   * family. */

                  if (constraining)
                    {
                      /* Constraining the universe. */

                      /* Add an exclude for the family. */

                      nvt_selector_add (quoted_selector,
                                        quoted_family,
                                        NULL,
                                        1);
                    }
                  else
                    {
                      /* Generating from empty. */
                    }

                  /* Add an include for every NVT in the family. */

                  init_nvt_iterator (&nvts, (nvt_t) 0, (config_t) 0, family,
                                     NULL, 1, NULL);
                  while (next (&nvts))
                    {
                      nvt_selector_add (quoted_selector,
                                        nvt_iterator_oid (&nvts),
                                        quoted_family,
                                        0);
                      new_nvt_count++;
                    }
                  cleanup_iterator (&nvts);
                }
              else if (growing_all)
                {
                  /* Selection of an entire family, which grows with the family. */

                  if (constraining)
                    {
                      /* Constraining the universe. */
                    }
                  else
                    {
                      /* Generating from empty.  Add an include for the
                       * family. */

                      nvt_selector_add (quoted_selector,
                                        quoted_family,
                                        NULL,
                                        0);

                    }

                  new_nvt_count = max_nvt_count;
                }

              /* Update the cached config info. */

              sql ("UPDATE configs SET nvt_count = nvt_count - %i + %i,"
                   " nvts_growing = %i, family_count = family_count + %i,"
                   " modification_time = now ()"
                   " WHERE ROWID = %llu;",
                   old_nvt_count,
                   new_nvt_count,
                   growing_all ? 1 : 0,
                   was_selected ? 0 : 1,
                   config);
            }
          else
            {
              int must_grow = member (growing_families, family);

              if (must_grow)
                {
                  /* The resulting family must be growing.  If currently
                   * growing, leave as is, otherwise switch family to
                   * growing. */

                  if (old_nvt_count == max_nvt_count)
                    {
                      iterator_t nvts;

                      /* All were selected.  Clear selection, ensuring that
                       * the family is growing in the process.  */

                      nvt_selector_remove (quoted_selector,
                                           quoted_family,
                                           NVT_SELECTOR_TYPE_ANY);

                      if (constraining == 0)
                        /* Generating. */
                        nvt_selector_add (quoted_selector,
                                          quoted_family,
                                          NULL,
                                          0);

                      /* Add an exclude for every NVT in the family. */

                      init_nvt_iterator (&nvts, (nvt_t) 0, (config_t) 0,
                                         family, NULL, 1, NULL);
                      while (next (&nvts))
                        nvt_selector_add (quoted_selector,
                                          nvt_iterator_oid (&nvts),
                                          quoted_family,
                                          1);
                      cleanup_iterator (&nvts);

                      /* Update the cached config info. */

                      sql ("UPDATE configs SET nvt_count = nvt_count - %i,"
                           " nvts_growing = 1, modification_time = now ()"
                           " WHERE ROWID = %llu;",
                           old_nvt_count,
                           config);
                    }
                  else if (family_growing == 0)
                    {
                      iterator_t nvts;

                      if (constraining == 0)
                        nvt_selector_add (quoted_selector,
                                          quoted_family,
                                          NULL,
                                          0);

                      /* Remove any included NVT, add excludes for all
                       * other NVT's. */

                      init_nvt_iterator (&nvts, (nvt_t) 0, (config_t) 0,
                                         family, NULL, 1, NULL);
                      while (next (&nvts))
                        if (nvt_selector_has (quoted_selector,
                                              nvt_iterator_oid (&nvts),
                                              NVT_SELECTOR_TYPE_NVT,
                                              0))
                          nvt_selector_remove_selector
                           (quoted_selector,
                            nvt_iterator_oid (&nvts),
                            NVT_SELECTOR_TYPE_NVT);
                        else
                          nvt_selector_add (quoted_selector,
                                            nvt_iterator_oid (&nvts),
                                            quoted_family,
                                            1);
                      cleanup_iterator (&nvts);

                      /* Update the cached config info. */

                      sql ("UPDATE configs SET nvts_growing = 1,"
                           " modification_time = now ()"
                           " WHERE ROWID = %llu;",
                           config);
                    }
                }
              else
                {
                  /* The resulting family must be static.  If currently
                   * static, leave as is, otherwise switch family to
                   * static. */

                  if (old_nvt_count == max_nvt_count)
                    {
                      /* All were selected, clear selection, ensuring the
                       * family is static in the process. */

                      nvt_selector_remove (quoted_selector,
                                           quoted_family,
                                           NVT_SELECTOR_TYPE_ANY);
                      if (constraining)
                        nvt_selector_add (quoted_selector,
                                          quoted_family,
                                          NULL,
                                          1);

                      /* Update the cached config info. */

                      sql ("UPDATE configs SET nvts_growing = %i,"
                           " nvt_count = nvt_count - %i,"
                           " family_count = family_count - 1,"
                           " modification_time = now ()"
                           " WHERE ROWID = %llu;",
                           /* Recalculate the NVT growing state. */
                           nvt_selector_nvts_growing_2 (quoted_selector,
                                                        constraining),
                           old_nvt_count,
                           config);
                    }
                  else if (family_growing)
                    {
                      iterator_t nvts;

                      if (constraining)
                        nvt_selector_add (quoted_selector,
                                          quoted_family,
                                          NULL,
                                          1);
                      else
                        nvt_selector_remove (quoted_selector,
                                             quoted_family,
                                             NVT_SELECTOR_TYPE_FAMILY);

                      /* Remove any excluded NVT; add includes for all
                       * other NVT's. */

                      init_nvt_iterator (&nvts, (nvt_t) 0, (config_t) 0,
                                         family, NULL, 1, NULL);
                      while (next (&nvts))
                        if (nvt_selector_has (quoted_selector,
                                              nvt_iterator_oid (&nvts),
                                              NVT_SELECTOR_TYPE_NVT,
                                              1))
                          nvt_selector_remove_selector
                            (quoted_selector,
                             nvt_iterator_oid (&nvts),
                             NVT_SELECTOR_TYPE_NVT);
                        else
                          nvt_selector_add (quoted_selector,
                                            nvt_iterator_oid (&nvts),
                                            quoted_family,
                                            0);
                      cleanup_iterator (&nvts);

                      /* Update the cached config info. */

                      sql ("UPDATE configs SET nvts_growing = %i,"
                           " modification_time = now ()"
                           " WHERE ROWID = %llu;",
                           /* Recalculate the NVT growing state. */
                           nvt_selector_nvts_growing_2 (quoted_selector,
                                                        constraining),
                           config);
                    }
                }
            }

          g_free (quoted_family);
        }
    }
  cleanup_iterator (&families);

  sql ("COMMIT;");

  g_free (quoted_selector);
  free (selector);
  return 0;
}

/**
 * @brief Insert NVT selectors.
 *
 * @param[in]  quoted_name  Name of NVT selector.
 * @param[in]  selectors    NVT selectors.
 *
 * @return 0 success, -1 error, -3 input error.
 */
static int
insert_nvt_selectors (const char *quoted_name,
                      const array_t* selectors /* nvt_selector_t. */)
{
  int index = 0;
  const nvt_selector_t *selector;
  if (selectors == NULL) return -3;
  while ((selector = (nvt_selector_t*) g_ptr_array_index (selectors, index++)))
    {
      int type;

      if (selector->type == NULL) return -3;

      /** @todo Check that selector->type is actually an integer. */
      type = atoi (selector->type);

      if ((selector->family_or_nvt != NULL)
          && (type == NVT_SELECTOR_TYPE_NVT))
        {
          gchar *quoted_family_or_nvt, *quoted_family, *family = NULL;
          nvti_t *nvti = nvtis_lookup (nvti_cache, selector->family_or_nvt);

          /* An NVT selector. */

          if (nvti)
            {
              family = nvti_family (nvti);

              if (family == NULL)
                {
                  g_warning ("%s: skipping NVT '%s' from import of config '%s'"
                             " because the NVT is missing a family in the"
                             " cache",
                             __FUNCTION__,
                             selector->family_or_nvt,
                             quoted_name);
                  continue;
                }
            }
          else
            {
              g_warning ("%s: skipping NVT '%s' from import of config '%s'"
                         " because the NVT is missing from the cache",
                         __FUNCTION__,
                         selector->family_or_nvt,
                         quoted_name);
              continue;
            }

          quoted_family_or_nvt = sql_quote (selector->family_or_nvt);
          quoted_family = sql_quote (family);
          sql ("INSERT into nvt_selectors (name, exclude, type, family_or_nvt,"
               " family)"
               " VALUES ('%s', %i, %i, '%s', '%s');",
               quoted_name,
               selector->include ? 0 : 1,
               type,
               quoted_family_or_nvt,
               quoted_family);
          g_free (quoted_family_or_nvt);
          g_free (quoted_family);
        }
      else if (selector->family_or_nvt)
        {
          gchar *quoted_family_or_nvt;

          /* A family selector. */

          if (type != NVT_SELECTOR_TYPE_FAMILY)
            {
              g_warning ("%s: skipping NVT '%s' from import of config '%s'"
                         " because the type is wrong (expected family)",
                         __FUNCTION__,
                         selector->family_or_nvt,
                         quoted_name);
              continue;
            }

          quoted_family_or_nvt = sql_quote (selector->family_or_nvt);

          sql ("INSERT into nvt_selectors (name, exclude, type, family_or_nvt,"
               " family)"
               " VALUES ('%s', %i, %i, '%s', '%s');",
               quoted_name,
               selector->include ? 0 : 1,
               type,
               quoted_family_or_nvt,
               quoted_family_or_nvt);
          g_free (quoted_family_or_nvt);
        }
      else
        {
          /* An "all" selector. */

          if (type != NVT_SELECTOR_TYPE_ALL)
            {
              g_warning ("%s: skipping NVT from import of config '%s'"
                         " because the type is wrong (expected all)",
                         __FUNCTION__,
                         quoted_name);
              continue;
            }

          sql ("INSERT into nvt_selectors (name, exclude, type, family_or_nvt,"
               " family)"
               " VALUES ('%s', %i, %i, NULL, NULL);",
               quoted_name,
               selector->include ? 0 : 1,
               type);
        }
    }
  return 0;
}


/* NVT preferences. */

/**
 * @brief Add an NVT preference.
 *
 * @param[in]  name    The name of the preference.
 * @param[in]  value   The value of the preference.
 * @param[in]  remove  Whether to remove the preference from the database first.
 */
void
manage_nvt_preference_add (const char* name, const char* value, int remove)
{
  gchar* quoted_name = sql_quote (name);
  gchar* quoted_value = sql_quote (value);

  if (remove)
    {
      sql ("BEGIN EXCLUSIVE;");
      sql ("DELETE FROM nvt_preferences WHERE name = '%s';", quoted_name);
    }

  if (strcmp (name, "port_range"))
    sql ("INSERT into nvt_preferences (name, value)"
         " VALUES ('%s', '%s');",
         quoted_name, quoted_value);

  if (remove)
    sql ("COMMIT;");

  g_free (quoted_name);
  g_free (quoted_value);
}

/**
 * @brief Enable the NVT preferences.
 */
void
manage_nvt_preferences_enable ()
{
  sql ("INSERT OR REPLACE INTO main.meta (name, value)"
       " VALUES ('nvt_preferences_enabled', 1);");
}

/**
 * @brief Initialise an NVT preference iterator.
 *
 * @param[in]  iterator  Iterator.
 * @param[in]  name      Name of NVT, NULL for all preferences.
 */
void
init_nvt_preference_iterator (iterator_t* iterator, const char *name)
{
  if (name)
    {
      gchar *quoted_name = sql_quote (name);
      init_iterator (iterator,
                     "SELECT name, value FROM nvt_preferences"
                     " WHERE name LIKE '%s[%%'"
                     " AND name != 'cache_folder'"
                     " AND name != 'include_folders'"
                     " AND name != 'nasl_no_signature_check'"
                     " AND name != 'network_targets'"
                     " AND name != 'ntp_save_sessions'"
                     " AND name NOT LIKE 'server_info_%%'"
                     /* Task preferences. */
                     " AND name != 'max_checks'"
                     " AND name != 'max_hosts'"
                     " ORDER BY name ASC",
                     quoted_name);
      g_free (quoted_name);
    }
  else
    init_iterator (iterator,
                   "SELECT name, value FROM nvt_preferences"
                   " WHERE name != 'cache_folder'"
                   " AND name != 'include_folders'"
                   " AND name != 'nasl_no_signature_check'"
                   " AND name != 'network_targets'"
                   " AND name != 'ntp_save_sessions'"
                   " AND name NOT LIKE 'server_info_%%'"
                   /* Task preferences. */
                   " AND name != 'max_checks'"
                   " AND name != 'max_hosts'"
                   " ORDER BY name ASC");
}

/**
 * @brief Get the name from an NVT preference iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (nvt_preference_iterator_name, 0);

/**
 * @brief Get the value from an NVT preference iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Value, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (nvt_preference_iterator_value, 1);

/**
 * @brief Get the real name from an NVT preference iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Real name.
 */
char*
nvt_preference_iterator_real_name (iterator_t* iterator)
{
  const char *ret;
  if (iterator->done) return NULL;
  ret = (const char*) sqlite3_column_text (iterator->stmt, 0);
  if (ret)
    {
      int value_start = -1, value_end = -1, count;
      /* LDAPsearch[entry]:Timeout value */
      count = sscanf (ret, "%*[^[][%*[^]]]:%n%*[ -~]%n", &value_start, &value_end);
      if (count == 0 && value_start > 0 && value_end > 0)
        {
          ret += value_start;
          return g_strndup (ret, value_end - value_start);
        }
      return g_strdup (ret);
    }
  return NULL;
}

/**
 * @brief Get the type from an NVT preference iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Type.
 */
char*
nvt_preference_iterator_type (iterator_t* iterator)
{
  const char *ret;
  if (iterator->done) return NULL;
  ret = (const char*) sqlite3_column_text (iterator->stmt, 0);
  if (ret)
    {
      int type_start = -1, type_end = -1, count;
      count = sscanf (ret, "%*[^[][%n%*[^]]%n]:", &type_start, &type_end);
      if (count == 0 && type_start > 0 && type_end > 0)
        {
          ret += type_start;
          return g_strndup (ret, type_end - type_start);
        }
      return NULL;
    }
  return NULL;
}

/**
 * @brief Get the NVT from an NVT preference iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return NVT.
 */
char*
nvt_preference_iterator_nvt (iterator_t* iterator)
{
  const char *ret;
  if (iterator->done) return NULL;
  ret = (const char*) sqlite3_column_text (iterator->stmt, 0);
  if (ret)
    {
      int type_start = -1, count;
      count = sscanf (ret, "%*[^[]%n[%*[^]]]:", &type_start);
      if (count == 0 && type_start > 0)
        {
          return g_strndup (ret, type_start);
        }
      return NULL;
    }
  return NULL;
}

/**
 * @brief Get the config value from an NVT preference iterator.
 *
 * @param[in]  iterator  Iterator.
 * @param[in]  config    Config.
 *
 * @return Freshly allocated config value.
 */
char*
nvt_preference_iterator_config_value (iterator_t* iterator, config_t config)
{
  gchar *quoted_name, *value;
  const char *ret;
  if (iterator->done) return NULL;

  quoted_name = sql_quote ((const char *) sqlite3_column_text (iterator->stmt, 0));
  value = sql_string (0, 0,
                      "SELECT value FROM config_preferences"
                      " WHERE config = %llu"
                      " AND name = '%s'"
                      /* Ensure that the NVT pref comes first, in case an
                       * error in the GSA added the NVT pref as a Scanner
                       * pref. */
                      " ORDER BY type",
                      config,
                      quoted_name);
  g_free (quoted_name);
  if (value) return value;

  ret = (const char*) sqlite3_column_text (iterator->stmt, 1);
  if (ret) return g_strdup (ret);
  return NULL;
}

/**
 * @brief Get the number preferences available for an NVT.
 *
 * @param[in]  name  Name of NVT.
 *
 * @return Number of possible preferences on NVT.
 */
int
nvt_preference_count (const char *name)
{
  gchar *quoted_name = sql_quote (name);
  int ret = sql_int (0, 0,
                     "SELECT COUNT(*) FROM nvt_preferences"
                     " WHERE name LIKE '%s[%%';",
                     quoted_name);
  g_free (quoted_name);
  return ret;
}

/**
 * @brief Initialise a task preference iterator.
 *
 * @param[in]  iterator  Iterator.
 */
void
init_task_preference_iterator (iterator_t* iterator)
{
  init_iterator (iterator,
                 "SELECT name, value FROM nvt_preferences"
                 " WHERE (name = 'max_checks'"
                 "        OR name = 'max_hosts')"
                 " ORDER BY name ASC");
}

/**
 * @brief Get the name from an task preference iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (task_preference_iterator_name, 0);

/**
 * @brief Get the value from an task preference iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Value, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (task_preference_iterator_value, 1);

/**
 * @brief Get the task value from a task preference iterator.
 *
 * @param[in]  iterator  Iterator.
 * @param[in]  task      Task.
 *
 * @return Freshly allocated task value.
 */
char*
task_preference_iterator_task_value (iterator_t* iterator, task_t task)
{
  gchar *quoted_name, *value;
  const char *ret;
  if (iterator->done) return NULL;

  quoted_name = sql_quote ((const char *) sqlite3_column_text (iterator->stmt, 0));
  value = sql_string (0, 0,
                      "SELECT value FROM task_preferences"
                      " WHERE task = %llu"
                      " AND name = '%s';",
                      task,
                      quoted_name);
  g_free (quoted_name);
  if (value) return value;

  ret = (const char*) sqlite3_column_text (iterator->stmt, 1);
  if (ret) return g_strdup (ret);
  return NULL;
}

/**
 * @brief Get the value of a task preference.
 *
 * @param[in]  task  Task.
 * @param[in]  name  Preference name.
 *
 * @return Freshly allocated task preference value or NULL if pref missing.
 */
char*
task_preference_value (task_t task, const char *name)
{
  gchar *quoted_name, *value;

  quoted_name = sql_quote (name);
  value = sql_string (0, 0,
                      "SELECT value FROM task_preferences"
                      " WHERE task = %llu"
                      " AND name = '%s';",
                      task,
                      quoted_name);
  if (value)
    {
      g_free (quoted_name);
      return value;
    }

  value = sql_string (0, 0,
                      "SELECT value FROM nvt_preferences"
                      " WHERE name = '%s';",
                      quoted_name);
  if (value)
    {
      g_free (quoted_name);
      return value;
    }

  return NULL;
}

/**
 * @brief Set the preferences of a task.
 *
 * Only the given preferences are affected.  A NULL value means to remove
 * the preference (reverts to using scanner value).
 *
 * @param[in]  task         Task.
 * @param[in]  preferences  Preferences.
 */
void
set_task_preferences (task_t task, array_t *preferences)
{
  if (preferences)
    {
      guint index;
      for (index = 0; index < preferences->len; index++)
        {
          name_value_t *pair;
          pair = (name_value_t*) g_ptr_array_index (preferences, index);
          if (pair && pair->name)
            {
              gchar *quoted_name;
              quoted_name = sql_quote (pair->name);
              if (pair->value)
                {
                  gchar *quoted_value;
                  quoted_value = sql_quote (pair->value);
                  sql ("BEGIN IMMEDIATE;");
                  if (sql_int (0, 0,
                               "SELECT COUNT(*) FROM task_preferences"
                               " WHERE task = %llu AND name = '%s';",
                               task,
                               quoted_name))
                    sql ("UPDATE task_preferences"
                         " SET value = '%s'"
                         " WHERE task = %llu AND name = '%s';",
                         quoted_value,
                         task,
                         quoted_name);
                  else
                    sql ("INSERT INTO task_preferences"
                         " (task, name, value)"
                         " VALUES"
                         " (%llu, '%s', '%s');",
                         task,
                         quoted_name,
                         quoted_value);
                  sql ("COMMIT;");
                  g_free (quoted_value);
                }
              else
                sql ("DELETE FROM task_preferences WHERE name = '%s';",
                     quoted_name);
              g_free (quoted_name);
              sql ("UPDATE tasks SET modification_time = now ()"
                   " WHERE ROWID = %llu;",
                   task);
            }
        }
    }
}


/* LSC Credentials. */

/**
 * @brief Find an LSC credential given a UUID.
 *
 * @param[in]   uuid            UUID of LSC credential.
 * @param[out]  lsc_credential  LSC credential return, 0 if succesfully failed
 *                              to find credential.
 *
 * @return FALSE on success (including if failed to find LSC credential),
 *         TRUE on error.
 */
gboolean
find_lsc_credential (const char* uuid, lsc_credential_t* lsc_credential)
{
  gchar *quoted_uuid = sql_quote (uuid);
  if (user_owns_uuid ("lsc_credential", quoted_uuid) == 0)
    {
      g_free (quoted_uuid);
      *lsc_credential = 0;
      return FALSE;
    }
  switch (sql_int64 (lsc_credential, 0, 0,
                     "SELECT ROWID FROM lsc_credentials WHERE uuid = '%s';",
                     quoted_uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *lsc_credential = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        g_free (quoted_uuid);
        return TRUE;
        break;
    }

  g_free (quoted_uuid);
  return FALSE;
}

/**
 * @brief Find an LSC credential given a UUID.
 *
 * @param[in]   uuid            UUID of LSC credential.
 * @param[out]  lsc_credential  LSC credential return, 0 if succesfully failed
 *                              to find credential.
 * @param[in]   actions         Actions.
 *
 * @return FALSE on success (including if failed to find LSC credential),
 *         TRUE on error.
 */
gboolean
find_lsc_credential_for_actions (const char* uuid,
                                 lsc_credential_t* lsc_credential,
                                 const char *actions)
{
  gchar *quoted_uuid = sql_quote (uuid);
  if (user_has_access_uuid ("lsc_credential", quoted_uuid, actions) == 0)
    {
      g_free (quoted_uuid);
      *lsc_credential = 0;
      return FALSE;
    }
  switch (sql_int64 (lsc_credential, 0, 0,
                     "SELECT ROWID FROM lsc_credentials WHERE uuid = '%s';",
                     quoted_uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *lsc_credential = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        g_free (quoted_uuid);
        return TRUE;
        break;
    }

  g_free (quoted_uuid);
  return FALSE;
}

/**
 * @brief Length of password generated in create_lsc_credential.
 */
#define PASSWORD_LENGTH 10

/**
 * @brief Create an LSC credential.
 *
 * @param[in]  name            Name of LSC credential.  Must be at least one
 *                             character long.
 * @param[in]  comment         Comment on LSC credential.
 * @param[in]  login           Name of LSC credential user.  Must be at least
 *                             one character long.
 * @param[in]  given_password  Password for password-only credential, NULL to
 *                             generate credentials.
 * @param[in]  key_private     Private key, or NULL.
 * @param[in]  key_public      Public key, or NULL.  Requires key_private.
 *                             Takes preference over password-only
 *                             and generated credentials.
 * @param[out] lsc_credential  Created LSC credential.
 *
 * @return 0 success, 1 LSC credential exists already, 2 name contains space,
 *         -1 error.
 */
int
create_lsc_credential (const char* name, const char* comment,
                       const char* login, const char* given_password,
                       const char* key_private, const char* key_public,
                       lsc_credential_t *lsc_credential)
{
  gchar *quoted_name;
  gchar *public_key, *private_key;
  int i;
  GRand *rand;
  gchar password[PASSWORD_LENGTH];
  const char *s = login;

  assert (name && strlen (name) > 0);
  assert (login && strlen (login) > 0);
  assert (current_credentials.uuid);
  assert (comment);

  quoted_name = sql_quote (name);

  sql ("BEGIN IMMEDIATE;");

  if (sql_int (0, 0,
               "SELECT COUNT(*) FROM lsc_credentials WHERE name = '%s'"
               " AND ((owner IS NULL) OR (owner ="
               " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
               quoted_name,
               current_credentials.uuid))
    {
      g_free (quoted_name);
      sql ("ROLLBACK;");
      return 1;
    }

  if (key_public)
    {
      lsc_crypt_ctx_t crypt_ctx;
      gchar *quoted_login, *quoted_phrase, *quoted_comment;
      gchar *quoted_public, *quoted_private;

      /* Key pair credential. */

      if (key_private == NULL)
        {
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return -1;
        }
      if (!strcmp (key_private, ";;encrypted;;"))
        {
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return -1;
        }

      /* Encrypt password and private key.  Note that we do not need
         to call sql_quote because the result of the encryption is
         base64 encoded and does not contain apostrophes.  */
      if (!disable_encrypted_credentials)
        {
          crypt_ctx = lsc_crypt_new ();
          quoted_phrase = lsc_crypt_encrypt (crypt_ctx,
                                             "password", given_password,
                                             "private_key", key_private, NULL);
          if (!quoted_phrase)
            {
              g_free (quoted_name);
              lsc_crypt_release (crypt_ctx);
              sql ("ROLLBACK;");
              return -1;
            }
          quoted_private = g_strdup (";;encrypted;;");
        }
      else
        {
          crypt_ctx = NULL;
          quoted_phrase = given_password ? sql_quote (given_password)
                                         : g_strdup ("");
          quoted_private = sql_quote (key_private);
        }
      quoted_login = sql_quote (login);
      quoted_comment = sql_quote (comment);
      quoted_public = sql_quote (key_public);

      sql ("INSERT INTO lsc_credentials"
           " (uuid, name, owner, login, password, comment, public_key,"
           "  private_key, rpm, deb, exe, creation_time, modification_time)"
           " VALUES"
           " (make_uuid (), '%s',"
           "  (SELECT ROWID FROM users WHERE users.uuid = '%s'),"
           "  '%s', '%s', '%s', '%s', '%s', NULL, NULL, NULL,"
           "  now (), now ());",
           quoted_name,
           current_credentials.uuid,
           quoted_login,
           quoted_phrase,
           quoted_comment,
           quoted_public,
           quoted_private);

      g_free (quoted_name);
      g_free (quoted_login);
      g_free (quoted_phrase);
      g_free (quoted_comment);
      g_free (quoted_private);
      g_free (quoted_public);
      lsc_crypt_release (crypt_ctx);

      if (lsc_credential)
        *lsc_credential = sqlite3_last_insert_rowid (task_db);

      sql ("COMMIT;");
      return 0;
    }

  if (given_password)
    {
      lsc_crypt_ctx_t crypt_ctx;
      gchar *quoted_login, *quoted_password, *quoted_comment, *quoted_private;

      /* Password-only credential. */

      if (!disable_encrypted_credentials)
        {
          crypt_ctx = lsc_crypt_new ();
          quoted_password = lsc_crypt_encrypt (crypt_ctx,
                                               "password", given_password,
                                               NULL);
          if (!quoted_password)
            {
              g_free (quoted_name);
              lsc_crypt_release (crypt_ctx);
              sql ("ROLLBACK;");
              return -1;
            }
          quoted_private = g_strdup ("';;encrypted;;'");
        }
      else
        {
          crypt_ctx = NULL;
          quoted_password = sql_quote (given_password);
          quoted_private = g_strdup ("NULL");
        }
      quoted_login = sql_quote (login);
      quoted_comment = sql_quote (comment);

      sql ("INSERT INTO lsc_credentials"
           " (uuid, name, owner, login, password, comment, public_key,"
           "  private_key, rpm, deb, exe, creation_time, modification_time)"
           " VALUES"
           " (make_uuid (), '%s',"
           "  (SELECT ROWID FROM users WHERE users.uuid = '%s'),"
           "  '%s', '%s', '%s', NULL, %s, NULL, NULL, NULL,"
           "  now (), now ());",
           quoted_name,
           current_credentials.uuid,
           quoted_login,
           quoted_password,
           quoted_comment,
           quoted_private);

      g_free (quoted_name);
      g_free (quoted_login);
      g_free (quoted_password);
      g_free (quoted_comment);
      g_free (quoted_private);
      lsc_crypt_release (crypt_ctx);

      if (lsc_credential)
        *lsc_credential = sqlite3_last_insert_rowid (task_db);

      sql ("COMMIT;");
      return 0;
    }

  /* Ensure the login is alphanumeric, to help the package generation. */

  while (*s)
    if (isalnum (*s))
      s++;
    else
      {
        g_free (quoted_name);
        sql ("ROLLBACK;");
        return 2;
      }

  /* Create the keys and packages. */

  rand = g_rand_new ();
  for (i = 0; i < PASSWORD_LENGTH - 1; i++)
    password[i] = (gchar) g_rand_int_range (rand, '0', 'z');
  password[PASSWORD_LENGTH - 1] = '\0';
  g_rand_free (rand);

  if (lsc_user_keys_create (login,
                            password,
                            &public_key,
                            &private_key))
    {
      g_free (quoted_name);
      sql ("ROLLBACK;");
      return -1;
    }

  {
    lsc_crypt_ctx_t crypt_ctx;
    gchar *quoted_login, *quoted_password, *quoted_comment;
    gchar *quoted_public_key, *quoted_private_key;

    /* Generated key credential. */

    if (!disable_encrypted_credentials)
      {
        crypt_ctx = lsc_crypt_new ();
        quoted_password = lsc_crypt_encrypt (crypt_ctx,
                                             "password", given_password,
                                             "private_key", private_key, NULL);
        if (!quoted_password)
          {
            lsc_crypt_release (crypt_ctx);
            g_free (public_key);
            g_free (private_key);
            g_free (quoted_name);
            sql ("ROLLBACK;");
            return -1;
          }
        quoted_private_key = g_strdup (";;encrypted;;");
      }
    else
      {
        crypt_ctx = NULL;
        quoted_password = sql_quote (password);
        quoted_private_key = sql_quote (private_key);
      }
    quoted_login = sql_quote (login);
    quoted_comment = sql_quote (comment);
    quoted_public_key = sql_quote (public_key);

    sql_quiet ("INSERT INTO lsc_credentials"
               " (uuid, name, owner, login, password, comment, public_key,"
               "  private_key, rpm, deb, exe,"
               "  creation_time, modification_time)"
               " VALUES"
               " (make_uuid (), '%s',"
               "  (SELECT ROWID FROM users WHERE users.uuid = '%s'),"
               "  '%s', '%s', '%s', '%s', '%s', NULL, NULL, NULL,"
               "  now (), now ());",
               quoted_name,
               current_credentials.uuid,
               quoted_login,
               quoted_password,
               quoted_comment,
               quoted_public_key,
               quoted_private_key);

    g_free (quoted_name);
    g_free (quoted_login);
    g_free (quoted_password);
    g_free (quoted_comment);
    g_free (quoted_public_key);
    g_free (quoted_private_key);
    lsc_crypt_release (crypt_ctx);
  }

  g_free (public_key);
  g_free (private_key);

  if (lsc_credential)
    *lsc_credential = sqlite3_last_insert_rowid (task_db);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Create an LSC Credential from an existing one.
 *
 * @param[in]  name                 Name of new LSC Credential. NULL to copy
 *                                  from existing.
 * @param[in]  comment              Comment on new LSC Credential. NULL to copy
 *                                  from existing.
 * @param[in]  lsc_credential_id    UUID of existing LSC Credential.
 * @param[out] new_lsc_credential   New LSC Credential.
 *
 * @return 0 success, 1 LSC Credential exists already, 2 failed to find
 *         existing LSC Credential, -1 error.
 */
int
copy_lsc_credential (const char* name, const char* comment,
                     const char *lsc_credential_id,
                     lsc_credential_t* new_lsc_credential)
{
  return copy_resource ("lsc_credential", name, comment, lsc_credential_id,
                        "login, password, public_key, private_key, rpm,"
                        " deb, exe",
                        new_lsc_credential);
}

/**
 * @brief Delete an LSC credential.
 *
 * @param[in]  lsc_credential_id  UUID of LSC credential.
 * @param[in]  ultimate           Whether to remove entirely, or to trashcan.
 *
 * @return 0 success, 1 fail because the LSC credential is in use, -1 error.
 */
int
delete_lsc_credential (const char *lsc_credential_id, int ultimate)
{
  lsc_credential_t lsc_credential = 0;

  sql ("BEGIN IMMEDIATE;");

  if (find_lsc_credential (lsc_credential_id, &lsc_credential))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (lsc_credential == 0)
    {
      if (find_trash ("lsc_credential", lsc_credential_id, &lsc_credential))
        {
          sql ("ROLLBACK;");
          return -1;
        }
      if (lsc_credential == 0)
        {
          sql ("ROLLBACK;");
          return 2;
        }
      if (ultimate == 0)
        {
          /* It's already in the trashcan. */
          sql ("COMMIT;");
          return 0;
        }

      /* Check if it's in use by a target in the trashcan. */
      if (sql_int (0, 0,
                   "SELECT count(*) FROM targets_trash"
                   " WHERE (lsc_credential = %llu"
                   "        AND ssh_location = " G_STRINGIFY (LOCATION_TRASH) ")"
                   " OR (smb_lsc_credential = %llu"
                   "     AND smb_location = " G_STRINGIFY (LOCATION_TRASH) ");",
                   lsc_credential,
                   lsc_credential))
        {
          sql ("ROLLBACK;");
          return 1;
        }

      sql ("DELETE FROM lsc_credentials_trash WHERE ROWID = %llu;", lsc_credential);
      sql ("COMMIT;");
      return 0;
    }


  if (sql_int (0, 0,
               "SELECT count(*) FROM targets"
               " WHERE lsc_credential = %llu OR smb_lsc_credential = %llu",
               lsc_credential,
               lsc_credential))
    {
      sql ("ROLLBACK;");
      return 1;
    }

  if (ultimate == 0)
    {
      sql ("INSERT INTO lsc_credentials_trash"
           " (uuid, owner, name, login, password, comment, public_key,"
           "  private_key, rpm, deb, exe, creation_time, modification_time)"
           " SELECT uuid, owner, name, login, password, comment, public_key,"
           "  private_key, rpm, deb, exe, creation_time, modification_time"
           " FROM lsc_credentials WHERE ROWID = %llu;",
           lsc_credential);
      /* Update the credential references in any trashcan targets.  This
       * situation is possible if the user restores the credential when the
       * target is in the trashcan. */
      sql ("UPDATE targets_trash"
           " SET ssh_location = " G_STRINGIFY (LOCATION_TRASH) ","
           "     lsc_credential = %llu"
           " WHERE lsc_credential = %llu;",
           sqlite3_last_insert_rowid (task_db),
           lsc_credential);
      sql ("UPDATE targets_trash"
           " SET smb_location = " G_STRINGIFY (LOCATION_TRASH) ","
           " smb_lsc_credential = %llu"
           " WHERE smb_lsc_credential = %llu;",
           sqlite3_last_insert_rowid (task_db),
           lsc_credential);
    }

  sql ("DELETE FROM lsc_credentials WHERE ROWID = %llu;", lsc_credential);

  sql ("COMMIT;");
  return 0;
}

/**
 * @brief Filter columns for LSC Credential iterator.
 */
#define LSC_CREDENTIAL_ITERATOR_FILTER_COLUMNS                                 \
 { GET_ITERATOR_FILTER_COLUMNS, "login", NULL }

/**
 * @brief LSC Credential iterator columns.
 */
#define LSC_CREDENTIAL_ITERATOR_COLUMNS                                       \
  GET_ITERATOR_COLUMNS ", login, password, public_key, private_key, rpm, "    \
  " deb, exe"

/**
 * @brief LSC Credential iterator columns for trash case.
 */
#define LSC_CREDENTIAL_ITERATOR_TRASH_COLUMNS                                 \
  GET_ITERATOR_COLUMNS ", login, password, public_key, private_key, rpm, "    \
  " deb, exe"

/**
 * @brief Count number of LSC Credentials.
 *
 * @param[in]  get  GET params.
 *
 * @return Total number of LSC Credentials in filtered set.
 */
int
lsc_credential_count (const get_data_t *get)
{
  static const char *extra_columns[] = LSC_CREDENTIAL_ITERATOR_FILTER_COLUMNS;
  return count ("lsc_credential", get, LSC_CREDENTIAL_ITERATOR_COLUMNS,
                extra_columns, 0, 0, 0, TRUE);
}

/**
 * @brief Check whether a LSC Credential is in use.
 *
 * @param[in]  lsc_credential  LSC Credential.
 *
 * @return 1 yes, 0 no.
 */
int
lsc_credential_in_use (lsc_credential_t lsc_credential)
{
  return !!sql_int (0, 0,
                    "SELECT count (*) FROM targets WHERE lsc_credential = %llu"
                    " OR smb_lsc_credential = %llu;",
                    lsc_credential,
                    lsc_credential);
}

/**
 * @brief Check whether a trashcan LSC Credential is in use.
 *
 * @param[in]  lsc_credential  LSC Credential.
 *
 * @return 1 yes, 0 no.
 */
int
trash_lsc_credential_in_use (lsc_credential_t lsc_credential)
{
  return !!sql_int (0, 0,
                    "SELECT count (*) FROM targets_trash"
                    " WHERE (lsc_credential = %llu"
                    " AND ssh_location = " G_STRINGIFY (LOCATION_TRASH)")"
                    " OR (smb_lsc_credential = %llu"
                    " AND smb_location = " G_STRINGIFY (LOCATION_TRASH) ");",
                    lsc_credential,
                    lsc_credential);
}

/**
 * @brief Check whether a LSC Credential is writable.
 *
 * @param[in]  lsc_credential  LSC Credential.
 *
 * @return 1 yes, 0 no.
 */
int
lsc_credential_writable (lsc_credential_t lsc_credential)
{
  return 1;
}

/**
 * @brief Check whether a trashcan LSC Credential is writable.
 *
 * @param[in]  lsc_credential  LSC Credential.
 *
 * @return 1 yes, 0 no.
 */
int
trash_lsc_credential_writable (lsc_credential_t lsc_credential)
{
  return 1;
}

/**
 * @brief Set the name of an LSC credential.
 *
 * @param[in]  lsc_credential  The LSC credential.
 * @param[in]  name            Name.
 */
void
set_lsc_credential_name (lsc_credential_t lsc_credential, const char *name)
{
  gchar *quoted_name = sql_quote (name);
  sql ("UPDATE lsc_credentials SET name = '%s', modification_time = now ()"
       " WHERE ROWID = %llu;",
       quoted_name,
       lsc_credential);
  g_free (quoted_name);
}

/**
 * @brief Set the comment of an LSC credential.
 *
 * @param[in]  lsc_credential  The LSC credential.
 * @param[in]  comment         Comment.
 */
void
set_lsc_credential_comment (lsc_credential_t lsc_credential,
                            const char *comment)
{
  gchar *quoted_comment = sql_quote (comment);
  sql ("UPDATE lsc_credentials SET comment = '%s', modification_time = now ()"
       " WHERE ROWID = %llu;",
       quoted_comment,
       lsc_credential);
  g_free (quoted_comment);
}

/**
 * @brief Set the login of an LSC credential.
 *
 * @param[in]  lsc_credential  The LSC credential.
 * @param[in]  login           Login.
 */
void
set_lsc_credential_login (lsc_credential_t lsc_credential, const char *login)
{
  gchar *quoted_login = sql_quote (login);
  sql ("UPDATE lsc_credentials SET login = '%s', modification_time = now ()"
       " WHERE ROWID = %llu;",
       quoted_login,
       lsc_credential);
  g_free (quoted_login);
}

/**
 * @brief Set the password of an LSC credential.
 *
 * @param[in]  lsc_credential  The LSC credential.
 * @param[in]  password        Password.
 */
void
set_lsc_credential_password (lsc_credential_t lsc_credential,
                             const char *password)
{
  lsc_crypt_ctx_t crypt_ctx;
  gchar *quoted_password, *quoted_private;

  if (!disable_encrypted_credentials)
    {
      crypt_ctx = lsc_crypt_new ();
      quoted_password = lsc_crypt_encrypt (crypt_ctx,
                                           "password", password, NULL);
      if (!quoted_password)
        {
          g_critical ("%s: encryption failed", G_STRFUNC);
          lsc_crypt_release (crypt_ctx);
          return;
        }
      quoted_private = g_strdup ("';;encrypted;;'");
    }
  else
    {
      crypt_ctx = NULL;
      quoted_password = sql_quote (password);
      quoted_private = g_strdup ("NULL");
    }

  sql ("UPDATE lsc_credentials SET password = '%s', private_key = %s,"
       " modification_time = now ()"
       " WHERE ROWID = %llu;",
       quoted_password, quoted_private,
       lsc_credential);
  g_free (quoted_password);
  g_free (quoted_private);
  lsc_crypt_release (crypt_ctx);
}

/**
 * @brief Return whether an LSC credential is the packaged type.
 *
 * @param[in]  lsc_credential  The LSC credential.
 *
 * @return 0 false, else true.
 */
int
lsc_credential_packaged (lsc_credential_t lsc_credential)
{
  return sql_int (0, 0,
                  "SELECT public_key NOTNULL FROM lsc_credentials"
                  " WHERE ROWID = %llu;",
                  lsc_credential);
}

/**
 * @brief Initialise an LSC Credential iterator, limiting to user's credentials.
 *
 * @param[in]  iterator        Iterator.
 * @param[in]  lsc_credential  Single LSC credential to iterate, 0 for all.
 * @param[in]  trash           Whether to iterate over trashcan credentials.
 * @param[in]  ascending       Whether to sort ascending or descending.
 * @param[in]  sort_field      Field to sort on, or NULL for "ROWID".
 */
void
init_user_lsc_credential_iterator (iterator_t* iterator,
                                   lsc_credential_t lsc_credential, int trash,
                                   int ascending, const char* sort_field)
{
  assert (current_credentials.uuid);

  if (lsc_credential)
    init_iterator (iterator,
                   "SELECT " LSC_CREDENTIAL_ITERATOR_COLUMNS
                   " FROM lsc_credentials%s"
                   " WHERE ROWID = %llu"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                   " ORDER BY %s %s;",
                   trash ? "_trash" : "",
                   lsc_credential,
                   current_credentials.uuid,
                   sort_field ? sort_field : "ROWID",
                   ascending ? "ASC" : "DESC");
  else
    init_iterator (iterator,
                   "SELECT " LSC_CREDENTIAL_ITERATOR_COLUMNS
                   " FROM lsc_credentials%s"
                   " WHERE ((owner IS NULL) OR (owner ="
                   " (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                   " ORDER BY %s %s;",
                   trash ? "_trash" : "",
                   current_credentials.uuid,
                   sort_field ? sort_field : "ROWID",
                   ascending ? "ASC" : "DESC");
}

/**
 * @brief Initialise a LSC Credential iterator.
 *
 * @param[in]  iterator  Iterator.
 * @param[in]  get         GET data.
 *
 * @return 0 success, 1 failed to find filter, failed to find filter (filt_id),
 *         -1 error.
 */
int
init_lsc_credential_iterator (iterator_t* iterator, const get_data_t *get)
{
  static const char *filter_columns[] = LSC_CREDENTIAL_ITERATOR_FILTER_COLUMNS;

  return init_get_iterator (iterator,
                            "lsc_credential",
                            get,
                            /* Columns. */
                            LSC_CREDENTIAL_ITERATOR_COLUMNS,
                            /* Columns for trashcan. */
                            LSC_CREDENTIAL_ITERATOR_TRASH_COLUMNS,
                            filter_columns,
                            NULL,
                            0,
                            NULL,
                            NULL,
                            TRUE);
}

/*
 * Common code for lsc_credential_iterator_password and
 * lsc_credential_iterator_private_key.
 */
static const char*
lsc_credential_iterator_pass_or_priv (iterator_t* iterator, int want_privkey)
{
  const char *password, *privkey, *result;

  if (iterator->done)
    return NULL;
  password = (const char*) sqlite3_column_text (iterator->stmt,
                                                GET_ITERATOR_COLUMN_COUNT + 1);
  privkey  = (const char*) sqlite3_column_text (iterator->stmt,
                                                GET_ITERATOR_COLUMN_COUNT + 3);
  /* If we do not have a private key, there is no encrypted data.
     Return the password as is or NULL.  */
  if (!privkey)
    return want_privkey? NULL : password;
  /* If we have a private key but it has not the flag value, we return
     the password field or the private key.  */
  if (strcmp (privkey, ";;encrypted;;"))
    return want_privkey? privkey : password;
  /* This is an encrypted credential.  */
  if (!iterator->crypt_ctx)
    iterator->crypt_ctx = lsc_crypt_new ();
  if (want_privkey)
    result = lsc_crypt_get_private_key (iterator->crypt_ctx, password);
  else
    result = lsc_crypt_get_password (iterator->crypt_ctx, password);

  return result;
}

/**
 * @brief Get the LSC credential from an LSC credential iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return LSC credential.
 */
lsc_credential_t
lsc_credential_iterator_lsc_credential (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (lsc_credential_t) sqlite3_column_int64 (iterator->stmt, 0);
}

/**
 * @brief Get the UUID from an LSC credential iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return UUID, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (lsc_credential_iterator_uuid, 1);

/**
 * @brief Get the name from an LSC credential iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (lsc_credential_iterator_name, 2);

/**
 * @brief Get the comment from an LSC credential iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Comment, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (lsc_credential_iterator_comment, 3);

/**
 * @brief Get the login from an LSC credential iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Login, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (lsc_credential_iterator_login, GET_ITERATOR_COLUMN_COUNT);

/**
 * @brief Get the password from an LSC credential iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Password, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
const char*
lsc_credential_iterator_password (iterator_t* iterator)
{
  return lsc_credential_iterator_pass_or_priv (iterator, 0);
}


/**
 * @brief Get the public_key from an LSC credential iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Public_key, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (lsc_credential_iterator_public_key, GET_ITERATOR_COLUMN_COUNT + 2);

/**
 * @brief Get the private_key from an LSC credential iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Private_key, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
const char*
lsc_credential_iterator_private_key (iterator_t* iterator)
{
  return lsc_credential_iterator_pass_or_priv (iterator, 1);
}

/**
 * @brief Get the rpm from an LSC credential iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Rpm, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
const char*
lsc_credential_iterator_rpm (iterator_t *iterator)
{
  const char *public_key, *name;
  void *rpm;
  gsize rpm_size;
  gchar *rpm64;

  if (iterator->done) return NULL;

  public_key = lsc_credential_iterator_public_key (iterator);
  name = lsc_credential_iterator_name (iterator);
  if (lsc_user_rpm_recreate (name, public_key, &rpm, &rpm_size))
    return NULL;
  rpm64 = (rpm && rpm_size)
          ? g_base64_encode (rpm, rpm_size)
          : g_strdup ("");
  free (rpm);
  return rpm64;
}

/**
 * @brief Get the deb from an LSC credential iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Deb, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
const char*
lsc_credential_iterator_deb (iterator_t *iterator)
{
  const char *name, *public_key;
  void *deb, *rpm;
  gsize deb_size, rpm_size;
  gchar *deb64;

  if (iterator->done) return NULL;

  public_key = lsc_credential_iterator_public_key (iterator);
  name = lsc_credential_iterator_name (iterator);
  if (lsc_user_rpm_recreate (name, public_key, &rpm, &rpm_size))
    return NULL;

  if (lsc_user_deb_recreate (name, rpm, rpm_size, &deb, &deb_size))
    {
      free (rpm);
      return NULL;
    }
  free (rpm);
  deb64 = (deb && deb_size)
          ? g_base64_encode (deb, deb_size)
          : g_strdup ("");
  free (deb);
  return deb64;
}

/**
 * @brief Get the exe from an LSC credential iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Exe, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
const char*
lsc_credential_iterator_exe (iterator_t *iterator)
{
  const char *name, *password;
  void *exe;
  gsize exe_size;
  gchar *exe64;

  if (iterator->done) return NULL;

  name = lsc_credential_iterator_name (iterator);
  password = lsc_credential_iterator_password (iterator);
  if (lsc_user_exe_recreate (name, password, &exe, &exe_size))
    return NULL;
  exe64 = (exe && exe_size)
          ? g_base64_encode (exe, exe_size)
          : g_strdup ("");
  free (exe);
  return exe64;
}

/**
 * @brief Get the UUID of an LSC credential.
 *
 * @param[in]  lsc_credential  LSC credential.
 *
 * @return UUID.
 */
char*
lsc_credential_uuid (lsc_credential_t lsc_credential)
{
  return sql_string (0, 0,
                     "SELECT uuid FROM lsc_credentials WHERE ROWID = %llu;",
                     lsc_credential);
}

/**
 * @brief Get the UUID of an LSC credential in the trashcan.
 *
 * @param[in]  lsc_credential  LSC credential.
 *
 * @return UUID.
 */
char*
trash_lsc_credential_uuid (lsc_credential_t lsc_credential)
{
  return sql_string (0, 0,
                     "SELECT uuid FROM lsc_credentials_trash"
                     " WHERE ROWID = %llu;",
                     lsc_credential);
}

/**
 * @brief Get the name of an LSC credential.
 *
 * @param[in]  lsc_credential  LSC credential.
 *
 * @return Name.
 */
char*
lsc_credential_name (lsc_credential_t lsc_credential)
{
  return sql_string (0, 0,
                     "SELECT name FROM lsc_credentials WHERE ROWID = %llu;",
                     lsc_credential);
}

/**
 * @brief Get the name of an LSC credential in the trashcan.
 *
 * @param[in]  lsc_credential  LSC credential.
 *
 * @return Name.
 */
char*
trash_lsc_credential_name (lsc_credential_t lsc_credential)
{
  return sql_string (0, 0,
                     "SELECT name FROM lsc_credentials_trash"
                     " WHERE ROWID = %llu;",
                     lsc_credential);
}

/**
 * @brief Initialise an LSC credential target iterator.
 *
 * Iterates over all targets that use the credential.
 *
 * @param[in]  iterator        Iterator.
 * @param[in]  lsc_credential  Name of LSC credential.
 * @param[in]  ascending       Whether to sort ascending or descending.
 */
void
init_lsc_credential_target_iterator (iterator_t* iterator,
                                     lsc_credential_t lsc_credential,
                                     int ascending)
{
  init_iterator (iterator,
                 "SELECT uuid, name FROM targets"
                 " WHERE lsc_credential = %llu OR smb_lsc_credential = %llu"
                 " ORDER BY name %s;",
                 lsc_credential,
                 lsc_credential,
                 ascending ? "ASC" : "DESC");
}

/**
 * @brief Get the uuid from an LSC credential_target iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Uuid, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (lsc_credential_target_iterator_uuid, 0);

/**
 * @brief Get the name from an LSC credential_target iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (lsc_credential_target_iterator_name, 1);


/* Agents. */

/**
 * @brief Find an agent given a name.
 *
 * @param[in]   uuid   UUID of agent.
 * @param[out]  agent  Agent return, 0 if succesfully failed to find agent.
 *
 * @return FALSE on success (including if failed to find agent), TRUE on error.
 */
gboolean
find_agent (const char* uuid, agent_t* agent)
{
  gchar *quoted_uuid = sql_quote (uuid);
  if (user_owns_uuid ("agent", quoted_uuid) == 0)
    {
      g_free (quoted_uuid);
      *agent = 0;
      return FALSE;
    }
  switch (sql_int64 (agent, 0, 0,
                     "SELECT ROWID FROM agents WHERE uuid = '%s';",
                     quoted_uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *agent = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        g_free (quoted_uuid);
        return TRUE;
        break;
    }

  g_free (quoted_uuid);
  return FALSE;
}

/**
 * @brief Find a signature in a feed.
 *
 * @param[in]   location            Feed directory to search for signature.
 * @param[in]   installer_filename  Installer filename.
 * @param[out]  signature           Freshly allocated installer signature.
 * @param[out]  signature_size      Size of installer signature.
 *
 * @return 0 success, -1 error.
 */
static int
find_signature (const gchar *location, const gchar *installer_filename,
                gchar **signature, gsize *signature_size)
{
  gchar *installer_basename = g_path_get_basename (installer_filename);

  if (strlen (installer_basename))
    {
      gchar *signature_filename, *signature_basename;
      GError *error = NULL;

      signature_basename  = g_strdup_printf ("%s.asc", installer_basename);
      g_free (installer_basename);
      signature_filename = g_build_filename (OPENVAS_NVT_DIR,
                                             location,
                                             signature_basename,
                                             NULL);
      g_free (signature_basename);

      tracef ("signature_filename: %s\n", signature_filename);

      g_file_get_contents (signature_filename, signature, signature_size,
                           &error);
      g_free (signature_filename);
      if (error)
        {
          g_error_free (error);
          return -1;
        }
      return 0;
    }

  g_free (installer_basename);
  return -1;
}

/**
 * @brief Execute gpg to verify an installer signature.
 *
 * @param[in]  installer       Installer.
 * @param[in]  installer_size  Size of installer.
 * @param[in]  signature       Installer signature.
 * @param[in]  signature_size  Size of installer signature.
 * @param[out] trust           Trust value.
 *
 * @return 0 success, -1 error.
 */
static int
verify_signature (const gchar *installer, gsize installer_size,
                  const gchar *signature, gsize signature_size,
                  int *trust)
{
  gchar **cmd;
  gint exit_status;
  int ret = 0, installer_fd, signature_fd;
  gchar *standard_out = NULL;
  gchar *standard_err = NULL;
  char installer_file[] = "/tmp/openvasmd-installer-XXXXXX";
  char signature_file[] = "/tmp/openvasmd-signature-XXXXXX";
  GError *error = NULL;

  installer_fd = mkstemp (installer_file);
  if (installer_fd == -1)
    return -1;

  g_file_set_contents (installer_file, installer, installer_size, &error);
  if (error)
    {
      g_warning ("%s", error->message);
      g_error_free (error);
      close (installer_fd);
      return -1;
    }

  signature_fd = mkstemp (signature_file);
  if (signature_fd == -1)
    {
      close (installer_fd);
      return -1;
    }

  g_file_set_contents (signature_file, signature, signature_size, &error);
  if (error)
    {
      g_warning ("%s", error->message);
      g_error_free (error);
      close (installer_fd);
      close (signature_fd);
      return -1;
    }

  cmd = (gchar **) g_malloc (8 * sizeof (gchar *));

  cmd[0] = g_strdup ("gpg");
  cmd[1] = g_strdup ("--batch");
  cmd[2] = g_strdup ("--quiet");
  cmd[3] = g_strdup ("--no-tty");
  cmd[4] = g_strdup ("--verify");
  cmd[5] = g_strdup (signature_file);
  cmd[6] = g_strdup (installer_file);
  cmd[7] = NULL;
  g_debug ("%s: Spawning in /tmp/: %s %s %s %s %s %s %s\n",
           __FUNCTION__,
           cmd[0], cmd[1], cmd[2], cmd[3], cmd[4], cmd[5], cmd[6]);
  if ((g_spawn_sync ("/tmp/",
                     cmd,
                     NULL,                 /* Environment. */
                     G_SPAWN_SEARCH_PATH,
                     NULL,                 /* Setup func. */
                     NULL,
                     &standard_out,
                     &standard_err,
                     &exit_status,
                     NULL) == FALSE)
      || (WIFEXITED (exit_status) == 0)
      || WEXITSTATUS (exit_status))
    {
      if (WEXITSTATUS (exit_status) == 1)
        *trust = TRUST_NO;
      else
        {
#if 0
          g_debug ("%s: failed to run gpg --verify: %d (WIF %i, WEX %i)",
                   __FUNCTION__,
                   exit_status,
                   WIFEXITED (exit_status),
                   WEXITSTATUS (exit_status));
          g_debug ("%s: stdout: %s\n", __FUNCTION__, standard_out);
          g_debug ("%s: stderr: %s\n", __FUNCTION__, standard_err);
          ret = -1;
#endif
          /* This can be caused by the contents of the signature file, so
           * always return success. */
          *trust = TRUST_UNKNOWN;
        }
    }
  else
    *trust = TRUST_YES;

  g_free (cmd[0]);
  g_free (cmd[1]);
  g_free (cmd[2]);
  g_free (cmd[3]);
  g_free (cmd[4]);
  g_free (cmd[5]);
  g_free (cmd[6]);
  g_free (cmd);
  g_free (standard_out);
  g_free (standard_err);
  close (installer_fd);
  close (signature_fd);

  return ret;
}

/**
 * @brief Create an agent entry.
 *
 * @param[in]  name           Name of agent.  Must be at least one character long.
 * @param[in]  comment        Comment on agent.
 * @param[in]  installer_64   Installer, in base64.
 * @param[in]  installer_filename   Installer filename.
 * @param[in]  installer_signature_64   Installer signature, in base64.
 * @param[in]  howto_install  Install HOWTO, in base64.
 * @param[in]  howto_use      Usage HOWTO, in base64.
 * @param[out] agent          Created agent.
 *
 * @return 0 success, 1 agent exists already, -1 error.
 */
int
create_agent (const char* name, const char* comment, const char* installer_64,
              const char* installer_filename, const char* installer_signature_64,
              const char* howto_install, const char* howto_use, agent_t *agent)
{
  gchar *quoted_name = sql_nquote (name, strlen (name));
  gchar *quoted_comment, *installer, *installer_signature;
  int installer_trust = TRUST_UNKNOWN;
  gsize installer_size = 0, installer_signature_size = 0;

  assert (strlen (name) > 0);
  assert (installer_64);
  assert (installer_filename);
  assert (installer_signature_64);
  assert (current_credentials.uuid);

  /* Translate the installer and signature. */

  if (strlen (installer_64))
    installer = (gchar*) g_base64_decode (installer_64, &installer_size);
  else
    installer = g_strdup ("");

  if (strlen (installer_signature_64))
    installer_signature = (gchar*) g_base64_decode (installer_signature_64,
                                                    &installer_signature_size);
  else
    installer_signature = g_strdup ("");

  /* Verify the installer signature. */

  if (strlen (installer_signature))
    {
      if (verify_signature (installer, installer_size, installer_signature,
                            installer_signature_size, &installer_trust))
        {
          g_free (quoted_name);
          g_free (installer);
          g_free (installer_signature);
          return -1;
        }
    }
  else
    {
      g_free (installer_signature);

      if (find_signature ("agents", installer_filename, &installer_signature,
                          &installer_signature_size)
          == 0)
        {
          if (verify_signature (installer, installer_size, installer_signature,
                                installer_signature_size, &installer_trust))
            {
              g_free (quoted_name);
              g_free (installer);
              g_free (installer_signature);
              return -1;
            }
        }
    }

  /* Check that the name is unique. */

  sql ("BEGIN IMMEDIATE;");

  if (sql_int (0, 0,
               "SELECT COUNT(*) FROM agents WHERE name = '%s'"
               " AND ((owner IS NULL) OR (owner ="
               " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
               quoted_name,
               current_credentials.uuid))
    {
      g_free (quoted_name);
      g_free (installer);
      g_free (installer_signature);
      sql ("ROLLBACK;");
      return 1;
    }

  /* Insert the packages. */

  {
    const char* tail;
    int ret;
    sqlite3_stmt* stmt;
    gchar* formatted;
    gchar* quoted_filename = sql_quote (installer_filename);

    if (comment)
      {
        quoted_comment = sql_nquote (comment, strlen (comment));
        formatted = g_strdup_printf ("INSERT INTO agents"
                                     " (uuid, name, owner, comment, installer,"
                                     "  installer_64, installer_filename,"
                                     "  installer_signature_64,"
                                     "  installer_trust, installer_trust_time,"
                                     "  howto_install, howto_use,"
                                     "  creation_time, modification_time)"
                                     " VALUES"
                                     " (make_uuid (), '%s',"
                                     "  (SELECT ROWID FROM users"
                                     "   WHERE users.uuid = '%s'),"
                                     "  '%s',"
                                     "  $installer, $installer_64,"
                                     "  '%s',"
                                     "  $installer_signature_64,"
                                     "  %i, %i, $howto_install,"
                                     "  $howto_use, now (), now ());",
                                     quoted_name,
                                     current_credentials.uuid,
                                     quoted_comment,
                                     quoted_filename,
                                     installer_trust,
                                     (int) time (NULL));
        g_free (quoted_comment);
      }
    else
      {
        formatted = g_strdup_printf ("INSERT INTO agents"
                                     " (uuid, name, owner, comment, installer,"
                                     "  installer_64, installer_filename,"
                                     "  installer_signature_64,"
                                     "  installer_trust, howto_install,"
                                     "  howto_use, creation_time,"
                                     "  modification_time)"
                                     " VALUES"
                                     " (make_uuid (), '%s',"
                                     "  (SELECT ROWID FROM users"
                                     "   WHERE users.uuid = '%s'),"
                                     "  '',"
                                     "  $installer, $installer_64,"
                                     "  '%s',"
                                     "  $installer_signature_64,"
                                     "  %i, %i, $howto_install,"
                                     "  $howto_use, now (), now ());",
                                     quoted_name,
                                     current_credentials.uuid,
                                     quoted_filename,
                                     installer_trust,
                                     (int) time (NULL));
      }

    g_free (quoted_name);
    g_free (quoted_filename);

    tracef ("   sql: %s\n", formatted);

    /* Prepare statement. */

    while (1)
      {
        ret = sqlite3_prepare (task_db, (char*) formatted, -1, &stmt, &tail);
        if (ret == SQLITE_BUSY) continue;
        g_free (formatted);
        if (ret == SQLITE_OK)
          {
            if (stmt == NULL)
              {
                g_warning ("%s: sqlite3_prepare failed with NULL stmt: %s\n",
                           __FUNCTION__,
                           sqlite3_errmsg (task_db));
                g_free (installer);
                g_free (installer_signature);
                sql ("ROLLBACK;");
                return -1;
              }
            break;
          }
        g_warning ("%s: sqlite3_prepare failed: %s\n",
                   __FUNCTION__,
                   sqlite3_errmsg (task_db));
        g_free (installer);
        g_free (installer_signature);
        sql ("ROLLBACK;");
        return -1;
      }

    /* Bind the packages to the "$values" in the SQL statement. */

    while (1)
      {
        ret = sqlite3_bind_text (stmt,
                                 1,
                                 installer,
                                 installer_size,
                                 SQLITE_TRANSIENT);
        if (ret == SQLITE_BUSY) continue;
        if (ret == SQLITE_OK) break;
        g_warning ("%s: sqlite3_prepare failed: %s\n",
                   __FUNCTION__,
                   sqlite3_errmsg (task_db));
        sql ("ROLLBACK;");
        g_free (installer);
        g_free (installer_signature);
        return -1;
      }
    g_free (installer);

    while (1)
      {
        ret = sqlite3_bind_text (stmt,
                                 2,
                                 installer_64,
                                 strlen (installer_64),
                                 SQLITE_TRANSIENT);
        if (ret == SQLITE_BUSY) continue;
        if (ret == SQLITE_OK) break;
        g_warning ("%s: sqlite3_prepare failed: %s\n",
                   __FUNCTION__,
                   sqlite3_errmsg (task_db));
        sql ("ROLLBACK;");
        g_free (installer_signature);
        return -1;
      }
    g_free (installer_signature);

    while (1)
      {
        ret = sqlite3_bind_text (stmt,
                                 3,
                                 installer_signature_64,
                                 strlen (installer_signature_64),
                                 SQLITE_TRANSIENT);
        if (ret == SQLITE_BUSY) continue;
        if (ret == SQLITE_OK) break;
        g_warning ("%s: sqlite3_prepare failed: %s\n",
                   __FUNCTION__,
                   sqlite3_errmsg (task_db));
        sql ("ROLLBACK;");
        return -1;
      }

    while (1)
      {
        ret = sqlite3_bind_text (stmt,
                                 4,
                                 howto_install,
                                 strlen (howto_install),
                                 SQLITE_TRANSIENT);
        if (ret == SQLITE_BUSY) continue;
        if (ret == SQLITE_OK) break;
        g_warning ("%s: sqlite3_prepare failed: %s\n",
                   __FUNCTION__,
                   sqlite3_errmsg (task_db));
        sql ("ROLLBACK;");
        return -1;
      }

    while (1)
      {
        ret = sqlite3_bind_blob (stmt,
                                 5,
                                 howto_use,
                                 strlen (howto_use),
                                 SQLITE_TRANSIENT);
        if (ret == SQLITE_BUSY) continue;
        if (ret == SQLITE_OK) break;
        g_warning ("%s: sqlite3_prepare failed: %s\n",
                   __FUNCTION__,
                   sqlite3_errmsg (task_db));
        sql ("ROLLBACK;");
        return -1;
      }

    /* Run the statement. */

    while (1)
      {
        ret = sqlite3_step (stmt);
        if (ret == SQLITE_BUSY) continue;
        if (ret == SQLITE_DONE) break;
        if (ret == SQLITE_ERROR || ret == SQLITE_MISUSE)
          {
            if (ret == SQLITE_ERROR) ret = sqlite3_reset (stmt);
            g_warning ("%s: sqlite3_step failed: %s\n",
                       __FUNCTION__,
                       sqlite3_errmsg (task_db));
            sql ("ROLLBACK;");
            return -1;
          }
      }

    sqlite3_finalize (stmt);
  }

  if (agent)
    *agent = sqlite3_last_insert_rowid (task_db);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Create an agent from an existing agent.
 *
 * @param[in]  name          Name of new agent. NULL to copy from existing.
 * @param[in]  comment       Comment on new agent. NULL to copy from existing.
 * @param[in]  agent_id      UUID of existing schedule.
 * @param[out] new_agent     New agent.
 *
 * @return 0 success, 1 agent exists already, 2 failed to find existing
 *         agent, -1 error.
 */
int
copy_agent (const char* name, const char* comment, const char *agent_id,
            agent_t* new_agent)
{
  return copy_resource ("agent", name, comment, agent_id,
                        "installer, installer_64, installer_filename,"
                        " installer_signature_64, installer_trust,"
                        " installer_trust_time, howto_install, howto_use",
                        new_agent);
}

/**
 * @brief Modify an agent.
 *
 * @param[in]   agent_id        UUID of agent.
 * @param[in]   name            Name of agent.
 * @param[in]   comment         Comment on agent.
 *
 * @return 0 success, 1 failed to find agent, 2 agent with new name exists,
 *         3 agent_id required, -1 internal error.
 */
int
modify_agent (const char *agent_id, const char *name, const char *comment)
{
  gchar *quoted_name, *quoted_comment;
  agent_t agent;

  if (agent_id == NULL)
    return 3;

  sql ("BEGIN IMMEDIATE;");

  assert (current_credentials.uuid);

  agent = 0;
  if (find_agent (agent_id, &agent))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (agent == 0)
    {
      sql ("ROLLBACK;");
      return 1;
    }

  /* Check whether a agent with the same name exists already. */
  if (name)
    {
      quoted_name = sql_quote (name);
      if (sql_int (0, 0,
                   "SELECT COUNT(*) FROM agents"
                   " WHERE name = '%s'"
                   " AND ROWID != %llu"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                   quoted_name,
                   agent,
                   current_credentials.uuid))
        {
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return 2;
        }
    }
  else
    quoted_name = sql_quote("");

  quoted_comment = sql_quote (comment ? comment : "");

  sql ("UPDATE agents SET"
       " name = '%s',"
       " comment = '%s',"
       " modification_time = now ()"
       " WHERE ROWID = %llu;",
       quoted_name,
       quoted_comment,
       agent);

  g_free (quoted_comment);
  g_free (quoted_name);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Delete an agent.
 *
 * @param[in]  agent_id   UUID of agent.
 * @param[in]  ultimate   Whether to remove entirely, or to trashcan.
 *
 * @return 0 success, 2 failed to find agent, -1 error.
 */
int
delete_agent (const char *agent_id, int ultimate)
{
  agent_t agent = 0;

  sql ("BEGIN IMMEDIATE;");

  if (find_agent (agent_id, &agent))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (agent == 0)
    {
      if (find_trash ("agent", agent_id, &agent))
        {
          sql ("ROLLBACK;");
          return -1;
        }
      if (agent == 0)
        {
          sql ("ROLLBACK;");
          return 2;
        }
      if (ultimate == 0)
        {
          /* It's already in the trashcan. */
          sql ("COMMIT;");
          return 0;
        }

      sql ("DELETE FROM agents_trash WHERE ROWID = %llu;", agent);
      sql ("COMMIT;");
      return 0;
    }

  if (ultimate == 0)
    {
      sql ("INSERT INTO agents_trash"
           " (uuid, owner, name, comment, installer, installer_64,"
           "  installer_filename, installer_signature_64, installer_trust,"
           "  installer_trust_time, howto_install, howto_use, creation_time,"
           "  modification_time)"
           " SELECT"
           "  uuid, owner, name, comment, installer, installer_64,"
           "  installer_filename, installer_signature_64, installer_trust,"
           "  installer_trust_time, howto_install, howto_use, creation_time,"
           "  modification_time"
           " FROM agents WHERE ROWID = %llu;",
           agent);
    }

  sql ("DELETE FROM agents WHERE ROWID = %llu;", agent);
  sql ("COMMIT;");
  return 0;
}

/**
 * @brief Check whether an agent is in use.
 *
 * @param[in]  agent  Agent.
 *
 * @return 1 yes, 0 no.
 */
int
agent_in_use (agent_t agent)
{
  return 0;
}

/**
 * @brief Check whether a trashcan agent is writable.
 *
 * @param[in]  agent  Agent.
 *
 * @return 1 yes, 0 no.
 */
int
trash_agent_in_use (agent_t agent)
{
  return 0;
}

/**
 * @brief Check whether a agent is writable.
 *
 * @param[in]  agent  Agent.
 *
 * @return 1 yes, 0 no.
 */
int
agent_writable (agent_t agent)
{
  return (agent_in_use (agent) == 0);
}

/**
 * @brief Check whether a trashcan agent is writable.
 *
 * @param[in]  agent  Agent.
 *
 * @return 1 yes, 0 no.
 */
int
trash_agent_writable (agent_t agent)
{
  return (trash_agent_in_use (agent) == 0);
}

/**
 * @brief Verify an agent.
 *
 * @param[in]  agent  Agent.
 *
 * @return 0 success, -1 error.
 */
int
verify_agent (agent_t agent)
{
  int agent_trust = TRUST_UNKNOWN;
  iterator_t agents;
  get_data_t get;

  sql ("BEGIN IMMEDIATE;");

  memset (&get, 0, sizeof (get));
  get.filter = "asc=ROWID";
  init_agent_iterator (&agents, &get);
  if (next (&agents))
    {
      const char *signature_64;
      gchar *agent_signature = NULL;
      gsize agent_signature_size;

      signature_64 = agent_iterator_installer_signature_64 (&agents);

      find_signature ("agents",
                      agent_iterator_installer_filename (&agents),
                      &agent_signature,
                      &agent_signature_size);

      if ((signature_64 && strlen (signature_64))
          || agent_signature)
        {
          const char *installer;
          gsize installer_size;

          installer = agent_iterator_installer (&agents);
          installer_size = agent_iterator_installer_size (&agents);

          if (signature_64 && strlen (signature_64))
            {
              gchar *signature;
              gsize signature_length;

              /* Try the signature from the database. */

              signature = (gchar*) g_base64_decode (signature_64,
                                                    &signature_length);

              if (verify_signature (installer, installer_size, signature,
                                    signature_length, &agent_trust))
                {
                  cleanup_iterator (&agents);
                  g_free (agent_signature);
                  sql ("ROLLBACK;");
                  return -1;
                }
            }

          /* If the database signature is empty or the database
           * signature is bad, and there is a feed signature, then
           * try the feed signature. */
          if (((agent_trust == TRUST_NO)
               || (agent_trust == TRUST_UNKNOWN))
              && agent_signature)
            {
              if (verify_signature (installer, installer_size, agent_signature,
                                    strlen (agent_signature), &agent_trust))
                {
                  cleanup_iterator (&agents);
                  g_free (agent_signature);
                  sql ("ROLLBACK;");
                  return -1;
                }

              if (agent_trust == TRUST_YES)
                {
                  gchar *quoted_signature, *base64;
                  base64 = (strlen (agent_signature)
                            ? g_base64_encode ((guchar*) agent_signature,
                                               agent_signature_size)
                            : g_strdup (""));
                  quoted_signature = sql_quote (base64);
                  g_free (base64);
                  sql ("UPDATE agents SET installer_signature_64 = '%s'"
                       " WHERE ROWID = %llu;",
                       quoted_signature,
                       agent);
                  g_free (quoted_signature);
                }
            }
          g_free (agent_signature);
        }
    }
  else
    {
      cleanup_iterator (&agents);
      sql ("ROLLBACK;");
      return -1;
    }
  cleanup_iterator (&agents);

  sql ("UPDATE agents SET installer_trust = %i, installer_trust_time = %i"
       " WHERE ROWID = %llu;",
       agent_trust,
       time (NULL),
       agent);
  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Return the UUID of an agent.
 *
 * @param[in]   agent  Agent.
 *
 * @return UUID of Agent.
 */
char *
agent_uuid (agent_t agent)
{
  return sql_string (0, 0,
                     "SELECT uuid FROM agents WHERE ROWID = %llu;",
                     agent);
}

/**
 * @brief Filter columns for agent iterator.
 */
#define AGENT_ITERATOR_FILTER_COLUMNS          \
 { GET_ITERATOR_FILTER_COLUMNS, /* FIX "trust", */ NULL }

/**
 * @brief Agent iterator columns.
 */
#define AGENT_ITERATOR_COLUMNS                              \
  GET_ITERATOR_COLUMNS ", installer, installer_64,"         \
  " installer_filename, installer_signature_64,"            \
  " installer_trust, installer_trust_time, howto_install,"  \
  " howto_use"

/**
 * @brief Get the resource from a GET iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Resource.
 */
resource_t
get_iterator_resource (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return sqlite3_column_int64 (iterator->stmt, 0);
}

/**
 * @brief Get the UUID of the resource from a GET iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return UUID of the resource or NULL if iteration is complete.
 */
DEF_ACCESS (get_iterator_uuid, 1);

/**
 * @brief Get the name of the resource from a GET iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name of the resource or NULL if iteration is complete.
 */
DEF_ACCESS (get_iterator_name, 2);

/**
 * @brief Get the comment from a GET iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Comment.
 */
const char*
get_iterator_comment (iterator_t* iterator)
{
  const char *ret;
  if (iterator->done) return "";
  ret = (const char*) sqlite3_column_text (iterator->stmt, 3);
  return ret ? ret : "";
}

/**
 * @brief Get the creation time of the resource from a GET iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Creation time of the resource or NULL if iteration is complete.
 */
DEF_ACCESS (get_iterator_creation_time, 4);

/**
 * @brief Get the modification time of the resource from a GET iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Modification time of the resource or NULL if iteration is complete.
 */
DEF_ACCESS (get_iterator_modification_time, 5);

/**
 * @brief Agent iterator columns for trash case.
 */
#define AGENT_ITERATOR_TRASH_COLUMNS NULL

/**
 * @brief Initialise an agent iterator.
 *
 * @param[in]  iterator    Iterator.
 * @param[in]  get         GET data.
 *
 * @return 0 success, 1 failed to find agent, failed to find filter, -1 error.
 */
int
init_agent_iterator (iterator_t* iterator, const get_data_t *get)
{
  static const char *filter_columns[] = AGENT_ITERATOR_FILTER_COLUMNS;

  return init_get_iterator (iterator,
                            "agent",
                            get,
                            /* Columns. */
                            AGENT_ITERATOR_COLUMNS,
                            /* Columns for trashcan. */
                            AGENT_ITERATOR_TRASH_COLUMNS,
                            filter_columns,
                            NULL,
                            0,
                            NULL,
                            NULL,
                            TRUE);
}

/**
 * @brief Get the UUID from an agent iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return UUID, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (agent_iterator_uuid, 1);

/**
 * @brief Get the name from an agent iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (agent_iterator_name, 2);

/**
 * @brief Get the comment from an agent iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Comment.
 */
const char*
agent_iterator_comment (iterator_t* iterator)
{
  const char *ret;
  if (iterator->done) return "";
  ret = (const char*) sqlite3_column_text (iterator->stmt, 3);
  return ret ? ret : "";
}

/**
 * @brief Get the installer from an agent iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Installer, or NULL if iteration is complete.  Freed
 *         by cleanup_iterator.
 */
DEF_ACCESS (agent_iterator_installer, GET_ITERATOR_COLUMN_COUNT);

/**
 * @brief Get the installer_64 from an agent iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Base 64 encoded installer, or NULL if iteration is complete.  Freed
 *         by cleanup_iterator.
 */
DEF_ACCESS (agent_iterator_installer_64, GET_ITERATOR_COLUMN_COUNT + 1);

/**
 * @brief Get the installer size from an agent iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Installer size, or NULL if iteration is complete.  Freed
 *         by cleanup_iterator.
 */
gsize
agent_iterator_installer_size (iterator_t* iterator)
{
  const char *installer_64;
  gsize installer_size;

  installer_64 = agent_iterator_installer_64 (iterator);
  if (installer_64 && strlen (installer_64))
    {
      gchar *installer;
      installer = (gchar*) g_base64_decode ((gchar*) installer_64,
                                            &installer_size);
      g_free (installer);
      return installer_size;
    }
  return 0;
}

/**
 * @brief Get the installer_filename from an agent iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Installer filename, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (agent_iterator_installer_filename, GET_ITERATOR_COLUMN_COUNT + 2);

/**
 * @brief Get the installer_signature_64 from an agent iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Installer signature in base64, or NULL if iteration is complete.
 *         Freed by cleanup_iterator.
 */
DEF_ACCESS (agent_iterator_installer_signature_64,
            GET_ITERATOR_COLUMN_COUNT + 3);

/**
 * @brief Get the trust value from an agent iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Trust value.
 */
const char*
agent_iterator_trust (iterator_t* iterator)
{
  if (iterator->done) return NULL;
  switch (sqlite3_column_int (iterator->stmt, GET_ITERATOR_COLUMN_COUNT + 4))
    {
      case 1:  return "yes";
      case 2:  return "no";
      case 3:  return "unknown";
      default: return NULL;
    }
}

/**
 * @brief Get the installer trust time from a agent iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Time agent installer was verified.
 */
time_t
agent_iterator_trust_time (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (time_t) sqlite3_column_int (iterator->stmt,
                                     GET_ITERATOR_COLUMN_COUNT + 5);
  return ret;
}

/**
 * @brief Get the install HOWTO from an agent iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Install HOWTO, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (agent_iterator_howto_install, GET_ITERATOR_COLUMN_COUNT + 6);

/**
 * @brief Get the usage HOWTO from an agent iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Usage HOWTO, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (agent_iterator_howto_use, GET_ITERATOR_COLUMN_COUNT + 7);

/**
 * @brief Count number of agents.
 *
 * @param[in]  get  GET params.
 *
 * @return Total number of agents in filtered set.
 */
int
agent_count (const get_data_t *get)
{
  static const char *extra_columns[] = AGENT_ITERATOR_FILTER_COLUMNS;
  return count ("agent", get, AGENT_ITERATOR_COLUMNS, extra_columns, 0, 0, 0,
                TRUE);
}

/**
 * @brief Get the name of an agent.
 *
 * @param[in]  agent  Agent.
 *
 * @return Name.
 */
char*
agent_name (agent_t agent)
{
  return sql_string (0, 0,
                     "SELECT name FROM agents WHERE ROWID = %llu;",
                     agent);
}


/* Notes. */

/**
 * @brief Find a note given a UUID.
 *
 * @param[in]   uuid  UUID of note.
 * @param[out]  note  Note return, 0 if succesfully failed to find note.
 *
 * @return FALSE on success (including if failed to find note), TRUE on error.
 */
gboolean
find_note (const char* uuid, note_t* note)
{
  gchar *quoted_uuid = sql_quote (uuid);
  if (user_owns_uuid ("note", quoted_uuid) == 0)
    {
      g_free (quoted_uuid);
      *note = 0;
      return FALSE;
    }
  switch (sql_int64 (note, 0, 0,
                     "SELECT ROWID FROM notes WHERE uuid = '%s';",
                     quoted_uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *note = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        g_free (quoted_uuid);
        return TRUE;
        break;
    }

  g_free (quoted_uuid);
  return FALSE;
}

/**
 * @brief Create a note.
 *
 * @param[in]  active      NULL or -1 on, 0 off, n on for n days.
 * @param[in]  nvt         OID of noted NVT.
 * @param[in]  text        Note text.
 * @param[in]  hosts       Hosts to apply note to, NULL for any host.
 * @param[in]  port        Port to apply note to, NULL for any port.
 * @param[in]  threat      Threat to apply note to, "" or NULL for any threat.
 * @param[in]  task        Task to apply note to, 0 for any task.
 * @param[in]  result      Result to apply note to, 0 for any result.
 * @param[out] note        Created note.
 *
 * @return 0 success, 1 failed to find NVT, 2 Invalid port, -1 error.
 */
int
create_note (const char* active, const char* nvt, const char* text,
             const char* hosts, const char* port, const char* threat,
             task_t task, result_t result, note_t *note)
{
  gchar *quoted_text, *quoted_hosts, *quoted_port, *quoted_threat, *quoted_nvt;

  if (nvt == NULL)
    return -1;

  quoted_nvt = sql_quote (nvt);
  if (strcmp (nvt, "0")
      && (sql_int (0, 0, "SELECT count (*) FROM nvts WHERE oid = '%s'", quoted_nvt)
          == 0))
    {
      g_free (quoted_nvt);
      return 1;
    }
  g_free (quoted_nvt);

  if (port && validate_results_port (port))
    return 2;

  if (text == NULL)
    return -1;

  if (threat && strcmp (threat, "High") && strcmp (threat, "Medium")
      && strcmp (threat, "Low") && strcmp (threat, "Log")
      && strcmp (threat, "Debug") && strcmp (threat, ""))
    return -1;

  quoted_text = sql_insert (text);
  quoted_hosts = sql_insert (hosts);
  quoted_port = sql_insert (port);
  quoted_threat = sql_insert ((threat && strlen (threat))
                                ? threat_message_type (threat) : NULL);

  sql ("INSERT INTO notes"
       " (uuid, owner, nvt, creation_time, modification_time, text, hosts,"
       "  port, threat, task, result, end_time)"
       " VALUES"
       " (make_uuid (), (SELECT ROWID FROM users WHERE users.uuid = '%s'),"
       "  '%s', %i, %i, %s, %s, %s, %s, %llu, %llu, %i);",
       current_credentials.uuid,
       nvt,
       time (NULL),
       time (NULL),
       quoted_text,
       quoted_hosts,
       quoted_port,
       quoted_threat,
       task,
       result,
       (active == NULL || (strcmp (active, "-1") == 0))
         ? 0
         : (strcmp (active, "0")
             ? (time (NULL) + (atoi (active) * 60 * 60 * 24))
             : 1));

  g_free (quoted_text);
  g_free (quoted_hosts);
  g_free (quoted_port);
  g_free (quoted_threat);

  if (note)
    *note = sqlite3_last_insert_rowid (task_db);

  return 0;
}

/**
 * @brief Create a note from an existing note.
 *
 * @param[in]  note_id   UUID of existing note.
 * @param[out] new_note  New note.
 *
 * @return 0 success, 1 note exists already, 2 failed to find existing
 *         note, -1 error.
 */
int
copy_note (const char *note_id, note_t* new_note)
{
  return copy_resource ("note", NULL, NULL, note_id,
                        "nvt, text, hosts, port, threat, task, result, end_time",
                        new_note);
}

/**
 * @brief Delete a note.
 *
 * @param[in]  note_id    UUID of note.
 * @param[in]  ultimate   Whether to remove entirely, or to trashcan.
 *
 * @return 0 success, 2 failed to find note, -1 error.
 */
int
delete_note (const char *note_id, int ultimate)
{
  note_t note = 0;

  sql ("BEGIN IMMEDIATE;");

  if (find_note (note_id, &note))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (note == 0)
    {
      if (find_trash ("note", note_id, &note))
        {
          sql ("ROLLBACK;");
          return -1;
        }
      if (note == 0)
        {
          sql ("ROLLBACK;");
          return 2;
        }
      if (ultimate == 0)
        {
          /* It's already in the trashcan. */
          sql ("COMMIT;");
          return 0;
        }

      sql ("DELETE FROM notes_trash WHERE ROWID = %llu;", note);
      sql ("COMMIT;");
      return 0;
    }

  if (ultimate == 0)
    {
      sql ("INSERT INTO notes_trash"
           " (uuid, owner, nvt, creation_time, modification_time, text, hosts,"
           "  port, threat, task, result, end_time)"
           " SELECT uuid, owner, nvt, creation_time, modification_time, text,"
           "        hosts, port, threat, task, result, end_time"
           " FROM notes WHERE ROWID = %llu;",
           note);
    }

  sql ("DELETE FROM notes WHERE ROWID = %llu;", note);

  sql ("COMMIT;");
  return 0;
}

/**
 * @brief Return the UUID of a note.
 *
 * @param[in]   note  Note.
 * @param[out]  id    Pointer to a newly allocated string.
 *
 * @return 0.
 */
int
note_uuid (note_t note, char ** id)
{
  *id = sql_string (0, 0,
                    "SELECT uuid FROM notes WHERE ROWID = %llu;",
                    note);
  return 0;
}

/**
 * @brief Modify a note.
 *
 * @param[in]  note        Note.
 * @param[in]  active      NULL or -2 leave as is, -1 on, 0 off, n on for n
 *                         days.
 * @param[in]  text        Note text.
 * @param[in]  hosts       Hosts to apply note to, NULL for any host.
 * @param[in]  port        Port to apply note to, NULL for any port.
 * @param[in]  threat      Threat to apply note to, "" or NULL for any threat.
 * @param[in]  task        Task to apply note to, 0 for any task.
 * @param[in]  result      Result to apply note to, 0 for any result.
 *
 * @return 0 success, -1 error, 1 syntax error in active, 2 Invalid port.
 */
int
modify_note (note_t note, const char *active, const char* text,
             const char* hosts, const char* port, const char* threat,
             task_t task, result_t result)
{
  gchar *quoted_text, *quoted_hosts, *quoted_port, *quoted_threat;

  if (note == 0)
    return -1;

  if (text == NULL)
    return -1;

  if (threat && strcmp (threat, "High") && strcmp (threat, "Medium")
      && strcmp (threat, "Low") && strcmp (threat, "Log")
      && strcmp (threat, "Debug") && strcmp (threat, ""))
    return -1;

  if (port && validate_results_port (port))
    return 2;

  quoted_text = sql_insert (text);
  quoted_hosts = sql_insert (hosts);
  quoted_port = sql_insert (port);
  quoted_threat = sql_insert ((threat && strlen (threat))
                                ? threat_message_type (threat) : NULL);

  if ((active == NULL) || (strcmp (active, "-2") == 0))
    sql ("UPDATE notes SET"
         " modification_time = %i,"
         " text = %s,"
         " hosts = %s,"
         " port = %s,"
         " threat = %s,"
         " task = %llu,"
         " result = %llu"
         " WHERE ROWID = %llu;",
         time (NULL),
         quoted_text,
         quoted_hosts,
         quoted_port,
         quoted_threat,
         task,
         result,
         note);
  else
    {
      const char *point;
      point = active;
      if (strcmp (point, "-1"))
        {
          while (*point && isdigit (*point)) point++;
          if (*point)
            return 1;
        }
      sql ("UPDATE notes SET"
           " end_time = %i,"
           " modification_time = %i,"
           " text = %s,"
           " hosts = %s,"
           " port = %s,"
           " threat = %s,"
           " task = %llu,"
           " result = %llu"
           " WHERE ROWID = %llu;",
           (strcmp (active, "-1")
             ? (strcmp (active, "0")
                 ? (time (NULL) + atoi (active) * 60 * 60 * 24)
                 : 1)
             : 0),
           time (NULL),
           quoted_text,
           quoted_hosts,
           quoted_port,
           quoted_threat,
           task,
           result,
           note);
    }

  g_free (quoted_text);
  g_free (quoted_hosts);
  g_free (quoted_port);
  g_free (quoted_threat);

  return 0;
}

/**
 * @brief Filter columns for note iterator.
 */
#define NOTE_ITERATOR_FILTER_COLUMNS                                          \
 { ANON_GET_ITERATOR_FILTER_COLUMNS, "name", "nvt", "text", "nvt_id",         \
   "task_name", "task_id", "hosts", "port", "result", NULL }

/**
 * @brief Note iterator columns.
 */
#define NOTE_ITERATOR_COLUMNS                                              \
  /* ANON_GET_ITERATOR_COLUMNS, */  /* Need the notes prefix. */           \
  "notes.ROWID, notes.uuid,"                                               \
  " (SELECT name FROM nvts WHERE oid = notes.nvt) AS name, '',"            \
  " iso_time (notes.creation_time),"                                       \
  " iso_time (notes.modification_time), notes.creation_time AS created,"   \
  " notes.modification_time AS modified,"                                  \
  /* Columns specific to notes. */                                         \
  " notes.nvt AS oid, notes.text,"                                         \
  " notes.hosts, notes.port, notes.threat, notes.task, notes.result,"      \
  " notes.end_time, (notes.end_time = 0) OR (notes.end_time >= now ()),"   \
  " (SELECT name FROM nvts WHERE oid = notes.nvt) AS nvt,"                 \
  " notes.nvt AS nvt_id,"                                                  \
  " (SELECT uuid FROM tasks WHERE ROWID = notes.task) AS task_id,"         \
  " (SELECT name FROM tasks WHERE ROWID = notes.task) AS task_name"

/**
 * @brief Note iterator columns for trash case.
 */
#define NOTE_ITERATOR_TRASH_COLUMNS                                        \
  /* ANON_GET_ITERATOR_TRASH_COLUMNS, */  /* Need the notes prefix. */     \
  "notes_trash.ROWID, notes_trash.uuid, '', '',"                           \
  " iso_time (notes_trash.creation_time),"                                 \
  " iso_time (notes_trash.modification_time),"                             \
  " notes_trash.creation_time AS created,"                                 \
  " notes_trash.modification_time AS modified,"                            \
  /* Columns specific to notes_trash. */                                   \
  " notes_trash.nvt AS oid, notes_trash.text,"                             \
  " notes_trash.hosts, notes_trash.port, notes_trash.threat,"              \
  " notes_trash.task, notes_trash.result,"                                 \
  " notes_trash.end_time,"                                                 \
  " (notes_trash.end_time = 0) OR (notes_trash.end_time >= now ()),"       \
  " (SELECT name FROM nvts WHERE oid = notes_trash.nvt) AS nvt,"           \
  " notes_trash.nvt AS nvt_id,"                                            \
  " (SELECT uuid FROM tasks WHERE ROWID = notes_trash.task) AS task_id,"   \
  " (SELECT name FROM tasks WHERE ROWID = notes_trash.task) AS task_name"

/**
 * @brief Count number of notes.
 *
 * @param[in]  get         GET params.
 * @param[in]  result      Result to limit notes to, 0 for all.
 * @param[in]  task        If result is > 0, task whose notes on result to
 *                         include, otherwise task to limit notes to.  0 for
 *                         all tasks.
 * @param[in]  nvt         NVT to limit notes to, 0 for all.
 *
 * @return Total number of notes in filtered set.
 */
int
note_count (const get_data_t *get, nvt_t nvt, result_t result, task_t task)
{
  static const char *filter_columns[] = NOTE_ITERATOR_FILTER_COLUMNS;
  gchar *result_clause, *filter, *task_id;
  int ret;

  /* Treat the "task_id" filter keyword as if the task was given in "task". */

  if (get->filt_id && strcmp (get->filt_id, "0"))
    {
      filter = filter_term (get->filt_id);
      if (filter == NULL)
        return 2;
    }
  else
    filter = NULL;

  task_id = filter_term_value (filter ? filter : get->filter, "task_id");

  g_free (filter);

  if (task_id)
    {
      find_task (task_id, &task);
      g_free (task_id);
    }

  if (result)
    result_clause = g_strdup_printf (" AND"
                                     " (result = %llu"
                                     "  OR (result = 0 AND nvt ="
                                     "      (SELECT results.nvt FROM results"
                                     "       WHERE results.ROWID = %llu)))"
                                     " AND (hosts is NULL"
                                     "      OR hosts = \"\""
                                     "      OR hosts_contains (hosts,"
                                     "      (SELECT results.host FROM results"
                                     "       WHERE results.ROWID = %llu)))"
                                     " AND (port is NULL"
                                     "      OR port = \"\""
                                     "      OR port ="
                                     "      (SELECT results.port FROM results"
                                     "       WHERE results.ROWID = %llu))"
                                     " AND (threat is NULL"
                                     "      OR threat = \"\""
                                     "      OR threat ="
                                     "      (SELECT results.type FROM results"
                                     "       WHERE results.ROWID = %llu))"
                                     " AND (task = 0 OR task = %llu)",
                                     result,
                                     result,
                                     result,
                                     result,
                                     result,
                                     task);
  else if (task)
    {
      result_clause = g_strdup_printf
                       (" AND (notes.task = %llu OR notes.task = 0)"
                        " AND nvt IN"
                        " (SELECT DISTINCT nvt FROM results"
                        "  WHERE results.task = %llu)"
                        " AND (notes.result = 0"
                        "      OR (SELECT task FROM results"
                        "          WHERE results.ROWID = notes.result)"
                        "         = %llu)",
                        task,
                        task,
                        task);
    }
  else if (nvt)
    {
      result_clause = g_strdup_printf
                       (" AND (notes.nvt ="
                        " (SELECT oid FROM nvts WHERE nvts.ROWID = %llu))"
                        " AND ((notes.owner IS NULL) OR (notes.owner ="
                        " (SELECT ROWID FROM users WHERE users.uuid = '%s')))",
                        nvt,
                        current_credentials.uuid);
    }
  else
    result_clause = NULL;

  ret = count ("note",
               get,
               NOTE_ITERATOR_COLUMNS,
               filter_columns,
               task || nvt,
               NULL,
               result_clause,
               TRUE);

  g_free (result_clause);

  return ret;
}

/**
 * @brief Initialise a note iterator.
 *
 * @param[in]  iterator    Iterator.
 * @param[in]  get         GET data.
 * @param[in]  result      Result to limit notes to, 0 for all.
 * @param[in]  task        If result is > 0, task whose notes on result to
 *                         include, otherwise task to limit notes to.  0 for
 *                         all tasks.
 * @param[in]  nvt         NVT to limit notes to, 0 for all.
 *
 * @return 0 success, 1 failed to find target, 2 failed to find filter,
 *         -1 error.
 */
int
init_note_iterator (iterator_t* iterator, const get_data_t *get, nvt_t nvt,
                    result_t result, task_t task)
{
  static const char *filter_columns[] = NOTE_ITERATOR_FILTER_COLUMNS;
  gchar *result_clause, *filter, *task_id;
  int ret;

  assert (current_credentials.uuid);
  assert ((nvt && get->id) == 0);
  assert ((task && get->id) == 0);

  assert (result ? nvt == 0 : 1);
  assert (task ? nvt == 0 : 1);

  /* Treat the "task_id" filter keyword as if the task was given in "task". */

  if (get->filt_id && strcmp (get->filt_id, "0"))
    {
      filter = filter_term (get->filt_id);
      if (filter == NULL)
        return 2;
    }
  else
    filter = NULL;

  task_id = filter_term_value (filter ? filter : get->filter, "task_id");

  g_free (filter);

  if (task_id)
    {
      find_task (task_id, &task);
      g_free (task_id);
    }

  if (result)
    result_clause = g_strdup_printf (" AND"
                                     " (result = %llu"
                                     "  OR (result = 0 AND nvt ="
                                     "      (SELECT results.nvt FROM results"
                                     "       WHERE results.ROWID = %llu)))"
                                     " AND (hosts is NULL"
                                     "      OR hosts = \"\""
                                     "      OR hosts_contains (hosts,"
                                     "      (SELECT results.host FROM results"
                                     "       WHERE results.ROWID = %llu)))"
                                     " AND (port is NULL"
                                     "      OR port = \"\""
                                     "      OR port ="
                                     "      (SELECT results.port FROM results"
                                     "       WHERE results.ROWID = %llu))"
                                     " AND (threat is NULL"
                                     "      OR threat = \"\""
                                     "      OR threat ="
                                     "      (SELECT results.type FROM results"
                                     "       WHERE results.ROWID = %llu))"
                                     " AND (task = 0 OR task = %llu)",
                                     result,
                                     result,
                                     result,
                                     result,
                                     result,
                                     task);
  else if (task)
    {
      result_clause = g_strdup_printf
                       (" AND (notes.task = %llu OR notes.task = 0)"
                        " AND nvt IN"
                        " (SELECT DISTINCT nvt FROM results"
                        "  WHERE results.task = %llu)"
                        " AND (notes.result = 0"
                        "      OR (SELECT task FROM results"
                        "          WHERE results.ROWID = notes.result)"
                        "         = %llu)",
                        task,
                        task,
                        task);
    }
  else if (nvt)
    {
      result_clause = g_strdup_printf
                       (" AND (notes.nvt ="
                        " (SELECT oid FROM nvts WHERE nvts.ROWID = %llu))"
                        " AND ((notes.owner IS NULL) OR (notes.owner ="
                        " (SELECT ROWID FROM users WHERE users.uuid = '%s')))",
                        nvt,
                        current_credentials.uuid);
    }
  else
    result_clause = NULL;

  ret = init_get_iterator (iterator,
                           "note",
                           get,
                           /* Columns. */
                           NOTE_ITERATOR_COLUMNS,
                           /* Columns for trashcan. */
                           NOTE_ITERATOR_TRASH_COLUMNS,
                           filter_columns,
                           NULL,
                           task || nvt,
                           NULL,
                           result_clause,
                           TRUE);

  g_free (result_clause);

  return ret;
}

/**
 * @brief Get the NVT OID from a note iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return NVT OID, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (note_iterator_nvt_oid, GET_ITERATOR_COLUMN_COUNT);

/**
 * @brief Get the text from a note iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Text, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (note_iterator_text, GET_ITERATOR_COLUMN_COUNT + 1);

/**
 * @brief Get the hosts from a note iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Hosts, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (note_iterator_hosts, GET_ITERATOR_COLUMN_COUNT + 2);

/**
 * @brief Get the port from a note iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Port, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (note_iterator_port, GET_ITERATOR_COLUMN_COUNT + 3);

/**
 * @brief Get the threat from a note iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Threat.
 */
const char *
note_iterator_threat (iterator_t *iterator)
{
  const char *ret;
  if (iterator->done) return NULL;
  ret = (const char*) sqlite3_column_text (iterator->stmt,
                                           GET_ITERATOR_COLUMN_COUNT + 4);
  if (ret == NULL) return NULL;
  return message_type_threat (ret);
}

/**
 * @brief Get the task from a note iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The task associated with the note, or 0 on error.
 */
task_t
note_iterator_task (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (task_t) sqlite3_column_int64 (iterator->stmt,
                                        GET_ITERATOR_COLUMN_COUNT + 5);
}

/**
 * @brief Get the result from a note iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The result associated with the note, or 0 on error.
 */
result_t
note_iterator_result (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (result_t) sqlite3_column_int64 (iterator->stmt,
                                          GET_ITERATOR_COLUMN_COUNT + 6);
}

/**
 * @brief Get the end time from an note iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Time until which note applies.  0 for always.  1 means the
 *         note has been explicitly turned off.
 */
time_t
note_iterator_end_time (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (time_t) sqlite3_column_int (iterator->stmt,
                                     GET_ITERATOR_COLUMN_COUNT + 7);
  return ret;
}

/**
 * @brief Get the active status from an note iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return 1 if active, else 0.
 */
int
note_iterator_active (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = sqlite3_column_int (iterator->stmt,
                            GET_ITERATOR_COLUMN_COUNT + 8);
  return ret;
}

/**
 * @brief Get the NVT name from a note iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return NVT name, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (note_iterator_nvt_name, GET_ITERATOR_COLUMN_COUNT + 9);


/* Overrides. */

/**
 * @brief Find an override given a UUID.
 *
 * @param[in]   uuid  UUID of override.
 * @param[out]  override  Override return, 0 if succesfully failed to find override.
 *
 * @return FALSE on success (including if failed to find override), TRUE on error.
 */
gboolean
find_override (const char* uuid, override_t* override)
{
  gchar *quoted_uuid = sql_quote (uuid);
  if (user_owns_uuid ("override", quoted_uuid) == 0)
    {
      g_free (quoted_uuid);
      *override = 0;
      return FALSE;
    }
  switch (sql_int64 (override, 0, 0,
                     "SELECT ROWID FROM overrides WHERE uuid = '%s';",
                     quoted_uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *override = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        g_free (quoted_uuid);
        return TRUE;
        break;
    }

  g_free (quoted_uuid);
  return FALSE;
}

/**
 * @brief Create an override.
 *
 * @param[in]  active      NULL or -1 on, 0 off, n on for n days.
 * @param[in]  nvt         OID of overrided NVT.
 * @param[in]  text        Override text.
 * @param[in]  hosts       Hosts to apply override to, NULL for any host.
 * @param[in]  port        Port to apply override to, NULL for any port.
 * @param[in]  threat      Threat to apply override to, "" or NULL for any threat.
 * @param[in]  new_threat  Threat to override result to.
 * @param[in]  task        Task to apply override to, 0 for any task.
 * @param[in]  result      Result to apply override to, 0 for any result.
 * @param[out] override    Created override.
 *
 * @return 0 success, 1 Invalid port, -1 error.
 */
int
create_override (const char* active, const char* nvt, const char* text,
                 const char* hosts, const char* port, const char* threat,
                 const char* new_threat, task_t task, result_t result,
                 override_t* override)
{
  gchar *quoted_text, *quoted_hosts, *quoted_port, *quoted_threat;
  gchar *quoted_new_threat;

  if (nvt == NULL)
    return -1;

  if (text == NULL)
    return -1;

  if (port && validate_results_port (port))
    return 1;

  if (threat && strcmp (threat, "High") && strcmp (threat, "Medium")
      && strcmp (threat, "Low") && strcmp (threat, "Log")
      && strcmp (threat, "Debug") && strcmp (threat, ""))
    return -1;

  if (new_threat && strcmp (new_threat, "High") && strcmp (new_threat, "Medium")
      && strcmp (new_threat, "Low") && strcmp (new_threat, "Log")
      && strcmp (new_threat, "Debug") && strcmp (new_threat, "False Positive")
      && strcmp (new_threat, ""))
    return -1;

  quoted_text = sql_insert (text);
  quoted_hosts = sql_insert (hosts);
  quoted_port = sql_insert (port);
  quoted_threat = sql_insert ((threat && strlen (threat))
                                ? threat_message_type (threat) : NULL);
  quoted_new_threat = sql_insert ((new_threat && strlen (new_threat))
                                    ? threat_message_type (new_threat) : NULL);

  sql ("INSERT INTO overrides"
       " (uuid, owner, nvt, creation_time, modification_time, text, hosts,"
       "  port, threat, new_threat, task, result, end_time)"
       " VALUES"
       " (make_uuid (), (SELECT ROWID FROM users WHERE users.uuid = '%s'),"
       "  '%s', %i, %i, %s, %s, %s,  %s, %s, %llu, %llu, %i);",
       current_credentials.uuid,
       nvt,
       time (NULL),
       time (NULL),
       quoted_text,
       quoted_hosts,
       quoted_port,
       quoted_threat,
       quoted_new_threat,
       task,
       result,
       (active == NULL || (strcmp (active, "-1") == 0))
         ? 0
         : (strcmp (active, "0")
             ? (time (NULL) + (atoi (active) * 60 * 60 * 24))
             : 1));

  g_free (quoted_text);
  g_free (quoted_hosts);
  g_free (quoted_port);
  g_free (quoted_threat);
  g_free (quoted_new_threat);

  if (override)
    *override = sqlite3_last_insert_rowid (task_db);

  reports_clear_count_cache (1);

  return 0;
}

/**
 * @brief Return the UUID of an override.
 *
 * @param[in]   override  Override.
 * @param[out]  id        Pointer to a newly allocated string.
 *
 * @return 0.
 */
int
override_uuid (override_t override, char ** id)
{
  *id = sql_string (0, 0,
                    "SELECT uuid FROM overrides WHERE ROWID = %llu;",
                    override);
  return 0;
}

/**
 * @brief Create a override from an existing override.
 *
 * @param[in]  override_id   UUID of existing override.
 * @param[out] new_override  New override.
 *
 * @return 0 success, 1 override exists already, 2 failed to find existing
 *         override, -1 error.
 */
int
copy_override (const char *override_id, override_t* new_override)
{
  return copy_resource ("override", NULL, NULL, override_id,
                        "nvt, text, hosts, port, threat, new_threat, task,"
                        " result, end_time",
                        new_override);
}

/**
 * @brief Delete a override.
 *
 * @param[in]  override_id  UUID of override.
 * @param[in]  ultimate     Whether to remove entirely, or to trashcan.
 *
 * @return 0 success, 2 failed to find override, -1 error.
 */
int
delete_override (const char *override_id, int ultimate)
{
  override_t override;

  sql ("BEGIN IMMEDIATE;");

  override = 0;

  if (find_override (override_id, &override))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (override == 0)
    {
      if (find_trash ("override", override_id, &override))
        {
          sql ("ROLLBACK;");
          return -1;
        }
      if (override == 0)
        {
          sql ("ROLLBACK;");
          return 2;
        }
      if (ultimate == 0)
        {
          /* It's already in the trashcan. */
          sql ("COMMIT;");
          return 0;
        }

      sql ("DELETE FROM overrides_trash WHERE ROWID = %llu;", override);
      sql ("COMMIT;");
      return 0;
    }

  if (ultimate == 0)
    {
      sql ("INSERT INTO overrides_trash"
           " (uuid, owner, nvt, creation_time, modification_time, text, hosts,"
           "  port, threat, new_threat, task, result, end_time)"
           " SELECT uuid, owner, nvt, creation_time, modification_time, text,"
           "        hosts, port, threat, new_threat, task, result, end_time"
           " FROM overrides WHERE ROWID = %llu;",
           override);
    }

  sql ("DELETE FROM overrides WHERE ROWID = %llu;", override);

  reports_clear_count_cache (1);

  sql ("COMMIT;");
  return 0;
}

/**
 * @brief Modify an override.
 *
 * @param[in]  override    Override.
 * @param[in]  active      NULL or -2 leave as is, -1 on, 0 off, n on for n
 *                         days.
 * @param[in]  text        Override text.
 * @param[in]  hosts       Hosts to apply override to, NULL for any host.
 * @param[in]  port        Port to apply override to, NULL for any port.
 * @param[in]  threat      Threat to apply override to, "" or NULL for any threat.
 * @param[in]  new_threat  Threat to override result to.
 * @param[in]  task        Task to apply override to, 0 for any task.
 * @param[in]  result      Result to apply override to, 0 for any result.
 *
 * @return 0 success, -1 error, 1 syntax error in active, 2 Invalid port.
 */
int
modify_override (override_t override, const char *active, const char* text,
                 const char* hosts, const char* port, const char* threat,
                 const char* new_threat, task_t task, result_t result)
{
  gchar *quoted_text, *quoted_hosts, *quoted_port, *quoted_threat;
  gchar *quoted_new_threat;

  if (override == 0)
    return -1;

  if (text == NULL)
    return -1;

  if (port && validate_results_port (port))
    return 2;

  if (threat && strcmp (threat, "High") && strcmp (threat, "Medium")
      && strcmp (threat, "Low") && strcmp (threat, "Log")
      && strcmp (threat, "Debug") && strcmp (threat, ""))
    return -1;

  if (new_threat && strcmp (new_threat, "High") && strcmp (new_threat, "Medium")
      && strcmp (new_threat, "Low") && strcmp (new_threat, "Log")
      && strcmp (new_threat, "Debug") && strcmp (new_threat, "False Positive")
      && strcmp (new_threat, ""))
    return -1;

  quoted_text = sql_insert (text);
  quoted_hosts = sql_insert (hosts);
  quoted_port = sql_insert (port);
  quoted_threat = sql_insert ((threat && strlen (threat))
                                ? threat_message_type (threat) : NULL);
  quoted_new_threat = sql_insert ((new_threat && strlen (new_threat))
                                    ? threat_message_type (new_threat) : NULL);

  if ((active == NULL) || (strcmp (active, "-2") == 0))
    sql ("UPDATE overrides SET"
         " modification_time = %i,"
         " text = %s,"
         " hosts = %s,"
         " port = %s,"
         " threat = %s,"
         " new_threat = %s,"
         " task = %llu,"
         " result = %llu"
         " WHERE ROWID = %llu;",
         time (NULL),
         quoted_text,
         quoted_hosts,
         quoted_port,
         quoted_threat,
         quoted_new_threat,
         task,
         result,
         override);
  else
    {
      const char *point;
      point = active;
      if (strcmp (point, "-1"))
        {
          while (*point && isdigit (*point)) point++;
          if (*point)
            return 1;
        }
      sql ("UPDATE overrides SET"
           " end_time = %i,"
           " modification_time = %i,"
           " text = %s,"
           " hosts = %s,"
           " port = %s,"
           " threat = %s,"
           " new_threat = %s,"
           " task = %llu,"
           " result = %llu"
           " WHERE ROWID = %llu;",
           (strcmp (active, "-1")
             ? (strcmp (active, "0")
                 ? (time (NULL) + atoi (active) * 60 * 60 * 24)
                 : 1)
             : 0),
           time (NULL),
           quoted_text,
           quoted_hosts,
           quoted_port,
           quoted_threat,
           quoted_new_threat,
           task,
           result,
           override);
    }

  g_free (quoted_text);
  g_free (quoted_hosts);
  g_free (quoted_port);
  g_free (quoted_threat);
  g_free (quoted_new_threat);

  reports_clear_count_cache (1);

  return 0;
}

/**
 * @brief Filter columns for override iterator.
 */
#define OVERRIDE_ITERATOR_FILTER_COLUMNS                                      \
 { ANON_GET_ITERATOR_FILTER_COLUMNS, "name", "nvt", "text", "nvt_id",         \
   "task_name", "task_id", "hosts", "port", "threat", "new_threat", "result", \
   NULL }

/**
 * @brief Override iterator columns.
 */
#define OVERRIDE_ITERATOR_COLUMNS                                              \
  /* ANON_GET_ITERATOR_COLUMNS, */  /* Need the overrides prefix. */           \
  "overrides.ROWID, overrides.uuid,"                                           \
  " (SELECT name FROM nvts WHERE oid = overrides.nvt) AS name, '',"            \
  " iso_time (overrides.creation_time),"                                       \
  " iso_time (overrides.modification_time),"                                   \
  " overrides.creation_time AS created,"                                       \
  " overrides.modification_time AS modified,"                                  \
  /* Columns specific to overrides. */                                         \
  " overrides.nvt AS oid, overrides.text,"                                     \
  " overrides.hosts, overrides.port, overrides.threat, overrides.new_threat, overrides.task, overrides.result,"      \
  " overrides.end_time, (overrides.end_time = 0) OR (overrides.end_time >= now ()),"   \
  " (SELECT name FROM nvts WHERE oid = overrides.nvt) AS nvt,"                 \
  " overrides.nvt AS nvt_id,"                                                  \
  " (SELECT uuid FROM tasks WHERE ROWID = overrides.task) AS task_id,"         \
  " (SELECT name FROM tasks WHERE ROWID = overrides.task) AS task_name"

/**
 * @brief Override iterator columns for trash case.
 */
#define OVERRIDE_ITERATOR_TRASH_COLUMNS                                        \
  /* ANON_GET_ITERATOR_TRASH_COLUMNS, */  /* Need the overrides prefix. */     \
  "overrides_trash.ROWID, overrides_trash.uuid, '', '',"                       \
  " iso_time (overrides_trash.creation_time),"                                 \
  " iso_time (overrides_trash.modification_time),"                             \
  " overrides_trash.creation_time AS created,"                                 \
  " overrides_trash.modification_time AS modified,"                            \
  /* Columns specific to overrides_trash. */                                   \
  " overrides_trash.nvt AS oid, overrides_trash.text,"                         \
  " overrides_trash.hosts, overrides_trash.port, overrides_trash.threat,"      \
  " overrides_trash.new_threat, overrides_trash.task, overrides_trash.result," \
  " overrides_trash.end_time,"                                                 \
  " (overrides_trash.end_time = 0) OR (overrides_trash.end_time >= now ()),"   \
  " (SELECT name FROM nvts WHERE oid = overrides_trash.nvt) AS nvt,"           \
  " overrides_trash.nvt AS nvt_id,"                                            \
  " (SELECT uuid FROM tasks WHERE ROWID = overrides_trash.task) AS task_id,"   \
  " (SELECT name FROM tasks WHERE ROWID = overrides_trash.task) AS task_name"

/**
 * @brief Count number of overrides.
 *
 * @param[in]  get         GET params.
 * @param[in]  result      Result to limit overrides to, 0 for all.
 * @param[in]  task        If result is > 0, task whose overrides on result to
 *                         include, otherwise task to limit overrides to.  0 for
 *                         all tasks.
 * @param[in]  nvt         NVT to limit overrides to, 0 for all.
 *
 * @return Total number of overrides in filtered set.
 */
int
override_count (const get_data_t *get, nvt_t nvt, result_t result, task_t task)
{
  static const char *filter_columns[] = OVERRIDE_ITERATOR_FILTER_COLUMNS;
  gchar *result_clause, *filter, *task_id;
  int ret;

  /* Treat the "task_id" filter keyword as if the task was given in "task". */

  if (get->filt_id && strcmp (get->filt_id, "0"))
    {
      filter = filter_term (get->filt_id);
      if (filter == NULL)
        return 2;
    }
  else
    filter = NULL;

  task_id = filter_term_value (filter ? filter : get->filter, "task_id");

  g_free (filter);

  if (task_id)
    {
      find_task (task_id, &task);
      g_free (task_id);
    }

  if (result)
    result_clause = g_strdup_printf (" AND"
                                     " (result = %llu"
                                     "  OR (result = 0 AND nvt ="
                                     "      (SELECT results.nvt FROM results"
                                     "       WHERE results.ROWID = %llu)))"
                                     " AND (hosts is NULL"
                                     "      OR hosts = \"\""
                                     "      OR hosts_contains (hosts,"
                                     "      (SELECT results.host FROM results"
                                     "       WHERE results.ROWID = %llu)))"
                                     " AND (port is NULL"
                                     "      OR port = \"\""
                                     "      OR port ="
                                     "      (SELECT results.port FROM results"
                                     "       WHERE results.ROWID = %llu))"
                                     " AND (threat is NULL"
                                     "      OR threat = \"\""
                                     "      OR threat ="
                                     "      (SELECT results.type FROM results"
                                     "       WHERE results.ROWID = %llu))"
                                     " AND (task = 0 OR task = %llu)",
                                     result,
                                     result,
                                     result,
                                     result,
                                     result,
                                     task);
  else if (task)
    {
      result_clause = g_strdup_printf
                       (" AND (overrides.task = %llu OR overrides.task = 0)"
                        " AND nvt IN"
                        " (SELECT DISTINCT nvt FROM results"
                        "  WHERE results.task = %llu)"
                        " AND (overrides.result = 0"
                        "      OR (SELECT task FROM results"
                        "          WHERE results.ROWID = overrides.result)"
                        "         = %llu)",
                        task,
                        task,
                        task);
    }
  else if (nvt)
    {
      result_clause = g_strdup_printf
                       (" AND (overrides.nvt ="
                        " (SELECT oid FROM nvts WHERE nvts.ROWID = %llu))"
                        " AND ((overrides.owner IS NULL) OR (overrides.owner ="
                        " (SELECT ROWID FROM users WHERE users.uuid = '%s')))",
                        nvt,
                        current_credentials.uuid);
    }
  else
    result_clause = NULL;

  ret = count ("override",
               get,
               OVERRIDE_ITERATOR_COLUMNS,
               filter_columns,
               task || nvt,
               NULL,
               result_clause,
               TRUE);

  g_free (result_clause);

  return ret;
}

/**
 * @brief Initialise an override iterator.
 *
 * @param[in]  iterator    Iterator.
 * @param[in]  get         GET data.
 * @param[in]  result      Result to limit overrides to, 0 for all.
 * @param[in]  task        If result is > 0, task whose overrides on result to
 *                         include, otherwise task to limit overrides to.  0 for
 *                         all tasks.
 * @param[in]  nvt         NVT to limit overrides to, 0 for all.
 *
 * @return 0 success, 1 failed to find target, 2 failed to find filter,
 *         -1 error.
 */
int
init_override_iterator (iterator_t* iterator, const get_data_t *get, nvt_t nvt,
                        result_t result, task_t task)
{
  static const char *filter_columns[] = OVERRIDE_ITERATOR_FILTER_COLUMNS;
  gchar *result_clause, *filter, *task_id;
  int ret;

  assert (current_credentials.uuid);
  assert ((nvt && get->id) == 0);
  assert ((task && get->id) == 0);

  assert (result ? nvt == 0 : 1);
  assert (task ? nvt == 0 : 1);

  /* Treat the "task_id" filter keyword as if the task was given in "task". */

  if (get->filt_id && strcmp (get->filt_id, "0"))
    {
      filter = filter_term (get->filt_id);
      if (filter == NULL)
        return 2;
    }
  else
    filter = NULL;

  task_id = filter_term_value (filter ? filter : get->filter, "task_id");

  g_free (filter);

  if (task_id)
    {
      find_task (task_id, &task);
      g_free (task_id);
    }

  if (result)
    result_clause = g_strdup_printf (" AND"
                                     " (result = %llu"
                                     "  OR (result = 0 AND nvt ="
                                     "      (SELECT results.nvt FROM results"
                                     "       WHERE results.ROWID = %llu)))"
                                     " AND (hosts is NULL"
                                     "      OR hosts = \"\""
                                     "      OR hosts_contains (hosts,"
                                     "      (SELECT results.host FROM results"
                                     "       WHERE results.ROWID = %llu)))"
                                     " AND (port is NULL"
                                     "      OR port = \"\""
                                     "      OR port ="
                                     "      (SELECT results.port FROM results"
                                     "       WHERE results.ROWID = %llu))"
                                     " AND (threat is NULL"
                                     "      OR threat = \"\""
                                     "      OR threat ="
                                     "      (SELECT results.type FROM results"
                                     "       WHERE results.ROWID = %llu))"
                                     " AND (task = 0 OR task = %llu)",
                                     result,
                                     result,
                                     result,
                                     result,
                                     result,
                                     task);
  else if (task)
    {
      result_clause = g_strdup_printf
                       (" AND (overrides.task = %llu OR overrides.task = 0)"
                        " AND nvt IN"
                        " (SELECT DISTINCT nvt FROM results"
                        "  WHERE results.task = %llu)"
                        " AND (overrides.result = 0"
                        "      OR (SELECT task FROM results"
                        "          WHERE results.ROWID = overrides.result)"
                        "         = %llu)",
                        task,
                        task,
                        task);
    }
  else if (nvt)
    {
      result_clause = g_strdup_printf
                       (" AND (overrides.nvt ="
                        " (SELECT oid FROM nvts WHERE nvts.ROWID = %llu))"
                        " AND ((overrides.owner IS NULL) OR (overrides.owner ="
                        " (SELECT ROWID FROM users WHERE users.uuid = '%s')))",
                        nvt,
                        current_credentials.uuid);
    }
  else
    result_clause = NULL;

  ret = init_get_iterator (iterator,
                           "override",
                           get,
                           /* Columns. */
                           OVERRIDE_ITERATOR_COLUMNS,
                           /* Columns for trashcan. */
                           OVERRIDE_ITERATOR_TRASH_COLUMNS,
                           filter_columns,
                           NULL,
                           task || nvt,
                           NULL,
                           result_clause,
                           TRUE);

  g_free (result_clause);

  return ret;
}

/**
 * @brief Get the NVT OID from a override iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return NVT OID, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (override_iterator_nvt_oid, GET_ITERATOR_COLUMN_COUNT);

/**
 * @brief Get the text from a override iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Text, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (override_iterator_text, GET_ITERATOR_COLUMN_COUNT + 1);

/**
 * @brief Get the hosts from a override iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Hosts, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (override_iterator_hosts, GET_ITERATOR_COLUMN_COUNT + 2);

/**
 * @brief Get the port from a override iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Port, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (override_iterator_port, GET_ITERATOR_COLUMN_COUNT + 3);

/**
 * @brief Get the threat from a override iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Threat.
 */
const char *
override_iterator_threat (iterator_t *iterator)
{
  const char *ret;
  if (iterator->done) return NULL;
  ret = (const char*) sqlite3_column_text (iterator->stmt,
                                           GET_ITERATOR_COLUMN_COUNT + 4);
  if (ret == NULL) return NULL;
  return message_type_threat (ret);
}

/**
 * @brief Get the threat from an override iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Threat.
 */
const char *
override_iterator_new_threat (iterator_t *iterator)
{
  const char *ret;
  if (iterator->done) return NULL;
  ret = (const char*) sqlite3_column_text (iterator->stmt,
                                           GET_ITERATOR_COLUMN_COUNT + 5);
  if (ret == NULL) return NULL;
  return message_type_threat (ret);
}

/**
 * @brief Get the task from a override iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The task associated with the override, or 0 on error.
 */
task_t
override_iterator_task (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (task_t) sqlite3_column_int64 (iterator->stmt,
                                        GET_ITERATOR_COLUMN_COUNT + 6);
}

/**
 * @brief Get the result from a override iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The result associated with the override, or 0 on error.
 */
result_t
override_iterator_result (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (result_t) sqlite3_column_int64 (iterator->stmt,
                                          GET_ITERATOR_COLUMN_COUNT + 7);
}

/**
 * @brief Get the end time from an override iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Time until which override applies.  0 for always.  1 means the
 *         override has been explicitly turned off.
 */
time_t
override_iterator_end_time (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (time_t) sqlite3_column_int (iterator->stmt,
                                     GET_ITERATOR_COLUMN_COUNT + 8);
  return ret;
}

/**
 * @brief Get the active status from an override iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return 1 if active, else 0.
 */
int
override_iterator_active (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = sqlite3_column_int (iterator->stmt,
                            GET_ITERATOR_COLUMN_COUNT + 9);
  return ret;
}

/**
 * @brief Get the NVT name from a override iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return NVT name, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (override_iterator_nvt_name, GET_ITERATOR_COLUMN_COUNT + 10);


/* Schedules. */

/**
 * @brief Find a schedule given a UUID.
 *
 * @param[in]   uuid      UUID of schedule.
 * @param[out]  schedule  Schedule return, 0 if succesfully failed to find schedule.
 *
 * @return FALSE on success (including if failed to find schedule), TRUE on error.
 */
gboolean
find_schedule (const char* uuid, schedule_t* schedule)
{
  return find_resource ("schedule", uuid, schedule);
}

/**
 * @brief Create a schedule.
 *
 * @param[in]   name        Name of schedule.
 * @param[in]   comment     Comment on schedule.
 * @param[in]   first_time  First time action will run.
 * @param[in]   period      How often the action will run in seconds.  0 means
 *                          once.
 * @param[in]   period_months  The months part of the period.
 * @param[in]   duration    The length of the time window the action will run
 *                          in.  0 means entire duration of action.
 * @param[out]  schedule    Created schedule.
 *
 * @return 0 success, 1 schedule exists already.
 */
int
create_schedule (const char* name, const char *comment, time_t first_time,
                 time_t period, time_t period_months, time_t duration,
                 schedule_t *schedule)
{
  gchar *quoted_name = sql_quote (name);
  long offset;

  sql ("BEGIN IMMEDIATE;");

  assert (current_credentials.uuid);

  if (sql_int (0, 0,
               "SELECT COUNT(*) FROM schedules"
               " WHERE name = '%s'"
               " AND ((owner IS NULL) OR (owner ="
               " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
               quoted_name,
               current_credentials.uuid))
    {
      g_free (quoted_name);
      sql ("ROLLBACK;");
      return 1;
    }

  offset = current_offset (sql_string (0, 0,
                                       "SELECT timezone FROM users"
                                       " WHERE users.uuid = '%s';",
                                       current_credentials.uuid));

  if (comment)
    {
      gchar *quoted_comment = sql_nquote (comment, strlen (comment));
      sql ("INSERT INTO schedules"
           " (uuid, name, owner, comment, first_time, period, period_months,"
           "  duration, timezone, initial_offset, creation_time,"
           "  modification_time)"
           " VALUES"
           " (make_uuid (), '%s',"
           "  (SELECT ROWID FROM users WHERE users.uuid = '%s'),"
           "  '%s', %i, %i, %i, %i,"
           "  (SELECT timezone FROM users WHERE users.uuid = '%s'),"
           "  %li, now(), now());",
           quoted_name, current_credentials.uuid, quoted_comment, first_time,
           period, period_months, duration, current_credentials.uuid, offset);
      g_free (quoted_comment);
    }
  else
    sql ("INSERT INTO schedules"
         " (uuid, name, owner, comment, first_time, period, period_months,"
         "  duration, timezone, initial_offset, creation_time,"
         "  modification_time)"
         " VALUES"
         " (make_uuid (), '%s',"
         "  (SELECT ROWID FROM users WHERE users.uuid = '%s'),"
         "  '', %i, %i, %i, %i,"
         "  (SELECT timezone FROM users WHERE users.uuid = '%s'),"
         "  %li, now(), now());",
         quoted_name, current_credentials.uuid, first_time, period,
         period_months, duration, current_credentials.uuid, offset);

  if (schedule)
    *schedule = sqlite3_last_insert_rowid (task_db);

  g_free (quoted_name);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Create a schedule from an existing schedule.
 *
 * @param[in]  name          Name of new schedule. NULL to copy from existing.
 * @param[in]  comment       Comment on new schedule. NULL to copy from
 *                           existing.
 * @param[in]  schedule_id   UUID of existing schedule.
 * @param[out] new_schedule  New schedule.
 *
 * @return 0 success, 1 schedule exists already, 2 failed to find existing
 *         schedule, -1 error.
 */
int
copy_schedule (const char* name, const char* comment, const char *schedule_id,
               schedule_t* new_schedule)
{
  return copy_resource ("schedule", name, comment, schedule_id,
                        "first_time, period, period_months, duration,"
                        " timezone, initial_offset",
                        new_schedule);
}

/**
 * @brief Delete a schedule.
 *
 * @param[in]  schedule_id  Schedule.
 * @param[in]  ultimate     Whether to remove entirely, or to trashcan.
 *
 * @return 0 success, 1 fail because a task refers to the schedule, -1 error.
 */
int
delete_schedule (const char *schedule_id, int ultimate)
{
  schedule_t schedule = 0;

  sql ("BEGIN IMMEDIATE;");

  if (find_schedule (schedule_id, &schedule))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (schedule == 0)
    {
      if (find_trash ("schedule", schedule_id, &schedule))
        {
          sql ("ROLLBACK;");
          return -1;
        }
      if (schedule == 0)
        {
          sql ("ROLLBACK;");
          return 2;
        }
      if (ultimate == 0)
        {
          /* It's already in the trashcan. */
          sql ("COMMIT;");
          return 0;
        }

      /* Check if it's in use by a task in the trashcan. */
      if (sql_int (0, 0,
                   "SELECT count(*) FROM tasks"
                   " WHERE schedule = %llu"
                   " AND schedule_location = " G_STRINGIFY (LOCATION_TRASH) ";",
                   schedule))
        {
          sql ("ROLLBACK;");
          return 1;
        }

      sql ("DELETE FROM schedules_trash WHERE ROWID = %llu;", schedule);
      sql ("COMMIT;");
      return 0;
    }

  if (ultimate == 0)
    {
      if (sql_int (0, 0,
                   "SELECT count(*) FROM tasks"
                   " WHERE schedule = %llu"
                   " AND schedule_location = " G_STRINGIFY (LOCATION_TABLE)
                   " AND (hidden = 0 OR hidden = 1);",
                   schedule))
        {
          sql ("ROLLBACK;");
          return 1;
        }

      sql ("INSERT INTO schedules_trash"
           " (uuid, owner, name, comment, first_time, period, period_months,"
           "  duration, timezone, initial_offset, creation_time,"
           "  modification_time)"
           " SELECT uuid, owner, name, comment, first_time, period, period_months,"
           "        duration, timezone, initial_offset, creation_time,"
           "        modification_time"
           " FROM schedules WHERE ROWID = %llu;",
           schedule);

      /* Update the location of the schedule in any trashcan tasks. */
      sql ("UPDATE tasks"
           " SET schedule = %llu,"
           "     schedule_location = " G_STRINGIFY (LOCATION_TRASH)
           " WHERE schedule = %llu"
           " AND schedule_location = " G_STRINGIFY (LOCATION_TABLE) ";",
           sqlite3_last_insert_rowid (task_db),
           schedule);
    }
  else if (sql_int (0, 0,
           "SELECT count(*) FROM tasks"
           " WHERE schedule = %llu"
           " AND schedule_location = " G_STRINGIFY (LOCATION_TABLE),
           schedule))
    {
      sql ("ROLLBACK;");
      return 1;
    }

  sql ("DELETE FROM schedules WHERE ROWID = %llu;", schedule);

  sql ("COMMIT;");
  return 0;
}

/**
 * @brief Return whether a schedule is in use by a task.
 *
 * @param[in]  schedule  Schedule.
 *
 * @return 1 if in use, else 0.
 */
int
schedule_in_use (schedule_t schedule)
{
  return !!sql_int (0, 0,
                    "SELECT count (*) FROM tasks WHERE schedule = %llu;",
                    schedule);
}

/**
 * @brief Return whether a trashcan schedule is in use by a task.
 *
 * @param[in]  schedule  schedule.
 *
 * @return 1 if in use, else 0.
 */
int
trash_schedule_in_use (schedule_t schedule)
{
  return !!sql_int (0, 0,
                    "SELECT count(*) FROM tasks"
                    " WHERE schedule = %llu"
                    " AND schedule_location = " G_STRINGIFY (LOCATION_TRASH),
                    schedule);
}

/**
 * @brief Return whether a schedule is writable.
 *
 * @param[in]  schedule  Schedule.
 *
 * @return 1 if writable, else 0.
 */
int
schedule_writable (schedule_t schedule)
{
  return (schedule_in_use (schedule) == 0);
}

/**
 * @brief Return whether a trashcan schedule is writable.
 *
 * @param[in]  schedule  Schedule.
 *
 * @return 1 if writable, else 0.
 */
int
trash_schedule_writable (schedule_t schedule)
{
  return (trash_schedule_in_use (schedule) == 0);
}

/**
 * @brief Code fragment for months_between.
 */
#define MONTHS_WITHIN_YEAR()                                 \
  (same_month                                                \
    ? 0                                                      \
    : ((broken2->tm_mon - broken1.tm_mon)                    \
       - (same_day                                           \
           ? (same_hour                                      \
               ? (same_minute                                \
                   ? (same_second                            \
                       ? 0                                   \
                       : (broken2->tm_sec < broken1.tm_sec)) \
                   : (broken2->tm_min < broken1.tm_min))     \
               : (broken2->tm_hour < broken1.tm_hour))       \
           : (broken2->tm_mday < broken1.tm_mday))))

/**
 * @brief Count number of full months between two times.
 *
 * There are two full months between 0h00.00 1 February 2010 and 0h00.00 1
 * April 2010.  There is one full month between 0h00.00 1 February 2010 and
 * 23h59.59 31 March 2010.
 *
 * @param[in]  time1  Earlier time.
 * @param[in]  time2  Later time.
 *
 * @return Number of full months between time1 and time2.
 */
time_t
months_between (time_t time1, time_t time2)
{
  struct tm broken1, *broken2;
  int same_year, same_month, same_day, same_hour, same_minute, same_second;
  int month1_less, day1_less, hour1_less, minute1_less;
  int second1_less;

  assert (time1 < time2);

  localtime_r (&time1, &broken1);
  broken2 = localtime (&time2);

  same_year = (broken1.tm_year == broken2->tm_year);
  same_month = (broken1.tm_mon == broken2->tm_mon);
  same_day = (broken1.tm_mday == broken2->tm_mday);
  same_hour = (broken1.tm_hour == broken2->tm_hour);
  same_minute = (broken1.tm_min == broken2->tm_min);
  same_second = (broken1.tm_sec == broken2->tm_sec);

  month1_less = (broken1.tm_mon < broken2->tm_mon);
  day1_less = (broken1.tm_mday < broken2->tm_mday);
  hour1_less = (broken1.tm_hour < broken2->tm_hour);
  minute1_less = (broken1.tm_min < broken2->tm_min);
  second1_less = (broken1.tm_sec < broken2->tm_sec);

  return
    (same_year
      ? MONTHS_WITHIN_YEAR ()
      : ((month1_less
          || (same_month
              && (day1_less
                  || (same_day
                      && (hour1_less
                          || (same_hour
                              && (minute1_less
                                  || (same_minute
                                      && second1_less))))))))
         ? (/* time1 is earlier in the year than time2. */
            ((broken2->tm_year - broken1.tm_year) * 12)
            + MONTHS_WITHIN_YEAR ())
         : (/* time1 is later in the year than time2. */
            ((broken2->tm_year - broken1.tm_year - 1) * 12)
            /* Months left in year of time1. */
            + (11 - broken1.tm_mon)
            /* Months past in year of time2. */
            + broken2->tm_mon
            /* Possible extra month due to position in month of each time. */
            + (day1_less
               || (same_day
                   && (hour1_less
                       || (same_hour
                           && (minute1_less
                               || (same_minute
                                   && second1_less)))))))));
}

/**
 * @brief Add months to a time.
 *
 * @param[in]  time    Time.
 * @param[in]  months  Months.
 *
 * @return Time plus given number of months.
 */
time_t
add_months (time_t time, int months)
{
  struct tm *broken = localtime (&time);
  broken->tm_mon += months;
  return mktime (broken);
}

/**
 * @brief Return the UUID of a schedule.
 *
 * @param[in]  schedule  Schedule.
 *
 * @return Newly allocated UUID.
 */
char *
schedule_uuid (schedule_t schedule)
{
  return sql_string (0, 0,
                     "SELECT uuid FROM schedules WHERE ROWID = %llu;",
                     schedule);
}

/**
 * @brief Return the name of a schedule.
 *
 * @param[in]  schedule  Schedule.
 *
 * @return Newly allocated name.
 */
char *
schedule_name (schedule_t schedule)
{
  return sql_string (0, 0,
                     "SELECT name FROM schedules WHERE ROWID = %llu;",
                     schedule);
}

/**
 * @brief Filter columns for schedule iterator.
 */
#define SCHEDULE_ITERATOR_FILTER_COLUMNS                                      \
 { GET_ITERATOR_FILTER_COLUMNS, "first_time", "period", "period_months",      \
   "duration", "timezone", "initial_offset", NULL }

/**
 * @brief Schedule iterator columns.
 */
#define SCHEDULE_ITERATOR_COLUMNS                                             \
  GET_ITERATOR_COLUMNS ", first_time, period, period_months, duration,"       \
  " timezone, initial_offset"

/**
 * @brief Schedule iterator columns for trash case.
 */
#define SCHEDULE_ITERATOR_TRASH_COLUMNS                                       \
  GET_ITERATOR_COLUMNS ", first_time, period, period_months, duration, "      \
  " timezone, initial_offset"

/**
 * @brief Count the number of schedules.
 *
 * @param[in]  get  GET params.
 *
 * @return Total number of schedules filtered set.
 */
int
schedule_count (const get_data_t *get)
{
  static const char *extra_columns[] = SCHEDULE_ITERATOR_FILTER_COLUMNS;
  return count ("schedule", get, SCHEDULE_ITERATOR_COLUMNS, extra_columns, 0, 0,
                0, TRUE);
}

/**
 * @brief Initialise a schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 * @param[in]  get         GET data.
 *
 * @return 0 success, 1 failed to find filter, failed to find filter (filt_id),
 *         -1 error.
 */
int
init_schedule_iterator (iterator_t* iterator, const get_data_t *get)
{
  static const char *filter_columns[] = SCHEDULE_ITERATOR_FILTER_COLUMNS;

  return init_get_iterator (iterator,
                            "schedule",
                            get,
                            /* Columns. */
                            SCHEDULE_ITERATOR_COLUMNS,
                            /* Columns for trashcan. */
                            SCHEDULE_ITERATOR_TRASH_COLUMNS,
                            filter_columns,
                            "task",
                            0,
                            NULL,
                            NULL,
                            TRUE);
}

/**
 * @brief Get the schedule from a schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Schedule.
 */
schedule_t
schedule_iterator_schedule (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (task_t) sqlite3_column_int64 (iterator->stmt, 0);
}

/**
 * @brief Get the UUID from a schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return UUID, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (schedule_iterator_uuid, 1);

/**
 * @brief Get the name from a schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (schedule_iterator_name, 2);

/**
 * @brief Get the comment from a schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Comment, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (schedule_iterator_comment, 3);

/**
 * @brief Get the first time from a schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return First time of schedule.
 */
time_t
schedule_iterator_first_time (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (time_t) sqlite3_column_int (iterator->stmt,
                                     GET_ITERATOR_COLUMN_COUNT);
  return ret;
}

/**
 * @brief Get the next time a schedule could be schedulable.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Next time an action associated with schedule could be run.
 */
time_t
schedule_iterator_next_time (iterator_t* iterator)
{
  time_t period = schedule_iterator_period (iterator);
  time_t first = schedule_iterator_first_time (iterator);
  time_t now = time (NULL);
  if (first >= now)
    {
      return first;
    }
  else if (period > 0)
    {
      return first + ((((now - first) / period) + 1) * period);
    }
  return 0;
}

/**
 * @brief Get the period from a schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Period of schedule.
 */
time_t
schedule_iterator_period (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (time_t) sqlite3_column_int (iterator->stmt,
                                     GET_ITERATOR_COLUMN_COUNT + 1);
  return ret;
}

/**
 * @brief Get the period months from a schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Period of schedule (months).
 */
time_t
schedule_iterator_period_months (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (time_t) sqlite3_column_int (iterator->stmt,
                                     GET_ITERATOR_COLUMN_COUNT + 2);
  return ret;
}

/**
 * @brief Get the duration from a schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Duration of schedule.
 */
time_t
schedule_iterator_duration (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (time_t) sqlite3_column_int (iterator->stmt,
                                     GET_ITERATOR_COLUMN_COUNT + 3);
  return ret;
}

/**
 * @brief Get the timezone from a schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Timezone, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (schedule_iterator_timezone, GET_ITERATOR_COLUMN_COUNT + 4);

/**
 * @brief Get the initial offset from a schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Initial offset, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
time_t
schedule_iterator_initial_offset (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (time_t) sqlite3_column_int (iterator->stmt,
                                     GET_ITERATOR_COLUMN_COUNT + 5);
  return ret;
}

/**
 * @brief Initialise a task schedule iterator.
 *
 * Lock the database before initialising.
 *
 * @param[in]  iterator        Iterator.
 */
void
init_task_schedule_iterator (iterator_t* iterator)
{
  sql ("BEGIN EXCLUSIVE;");
  init_iterator (iterator,
                 "SELECT tasks.ROWID, tasks.uuid,"
                 " schedules.ROWID, tasks.schedule_next_time,"
                 " schedules.period, schedules.period_months,"
                 " schedules.first_time,"
                 " schedules.duration,"
                 " users.uuid, users.name, schedules.owner,"
                 " schedules.timezone, schedules.initial_offset"
                 " FROM tasks, schedules, users"
                 " WHERE tasks.schedule = schedules.ROWID"
                 " AND tasks.hidden = 0"
                 " AND tasks.owner = users.ROWID;");
}

/**
 * @brief Cleanup a task schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 */
void
cleanup_task_schedule_iterator (iterator_t* iterator)
{
  cleanup_iterator (iterator);
  sql ("COMMIT;");
}

/**
 * @brief Get the task from a task schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return task.
 */
task_t
task_schedule_iterator_task (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (task_t) sqlite3_column_int64 (iterator->stmt, 0);
}

/**
 * @brief Get the task UUID from a task schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Task UUID, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (task_schedule_iterator_task_uuid, 1);

/**
 * @brief Get the schedule from a task schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return task.
 */
schedule_t
task_schedule_iterator_schedule (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (schedule_t) sqlite3_column_int64 (iterator->stmt, 2);
}

/**
 * @brief Get the next time from a task schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Next time.
 */
time_t
task_schedule_iterator_next_time (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (time_t) sqlite3_column_int64 (iterator->stmt, 3);
}

/**
 * @brief Get the period from a task schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return period.
 */
time_t
task_schedule_iterator_period (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (time_t) sqlite3_column_int64 (iterator->stmt, 4);
}

/**
 * @brief Get the period months from a task schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Period months.
 */
time_t
task_schedule_iterator_period_months (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (time_t) sqlite3_column_int64 (iterator->stmt, 5);
}

/**
 * @brief Get the first time from a task schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return First time.
 */
time_t
task_schedule_iterator_first_time (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (time_t) sqlite3_column_int64 (iterator->stmt, 6);
}

/**
 * @brief Get the duration from a task schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Duration.
 */
time_t
task_schedule_iterator_duration (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (time_t) sqlite3_column_int64 (iterator->stmt, 7);
}

/**
 * @brief Get the task owner uuid from a task schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Owner UUID, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (task_schedule_iterator_owner_uuid, 8);

/**
 * @brief Get the task owner name from a task schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Owner name, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (task_schedule_iterator_owner_name, 9);

/**
 * @brief Get the schedule owner from a task schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Owner name, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (task_schedule_iterator_owner, 10);

/**
 * @brief Get the timezone from a task schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Timezone, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (task_schedule_iterator_timezone, 11);

/**
 * @brief Get the initial offset from a task schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Initial offset.
 */
time_t
task_schedule_iterator_initial_offset (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (time_t) sqlite3_column_int64 (iterator->stmt, 12);
}

/**
 * @brief Get the start due state from a task schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Start due flag.
 */
gboolean
task_schedule_iterator_start_due (iterator_t* iterator)
{
  task_status_t run_status;
  time_t start_time;

  if (iterator->done) return FALSE;

  run_status = task_run_status (task_schedule_iterator_task (iterator));
  start_time = task_schedule_iterator_next_time (iterator)
                + task_schedule_iterator_initial_offset (iterator)
                - current_offset (task_schedule_iterator_timezone (iterator));

  if ((run_status == TASK_STATUS_DONE
       || run_status == TASK_STATUS_INTERNAL_ERROR
       || run_status == TASK_STATUS_NEW
       || run_status == TASK_STATUS_STOPPED)
      && (start_time > 0)
      && (start_time <= time (NULL)))
    return TRUE;

  return FALSE;
}

/**
 * @brief Get the stop due state from a task schedule iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Stop due flag.
 */
gboolean
task_schedule_iterator_stop_due (iterator_t* iterator)
{
  time_t period, period_months, duration;

  if (iterator->done) return FALSE;

  period = task_schedule_iterator_period (iterator);
  period_months = task_schedule_iterator_period_months (iterator);
  duration = task_schedule_iterator_duration (iterator);

  if (period && duration)
    {
      task_status_t run_status;

      run_status = task_run_status (task_schedule_iterator_task (iterator));

      if (run_status == TASK_STATUS_RUNNING
          || run_status == TASK_STATUS_REQUESTED)
        {
          time_t now, first, start;

          now = time (NULL);
          first = task_schedule_iterator_first_time (iterator)
                   + task_schedule_iterator_initial_offset (iterator)
                   - current_offset (task_schedule_iterator_timezone
                                      (iterator));
          start = first + (((now - first) / period) * period);
          if ((start + duration) < now)
            return TRUE;
        }
    }
  else if (period_months && duration)
    {
      task_status_t run_status;

      run_status = task_run_status (task_schedule_iterator_task (iterator));

      if (run_status == TASK_STATUS_RUNNING
          || run_status == TASK_STATUS_REQUESTED)
        {
          time_t now, first, start;

          now = time (NULL);
          first = task_schedule_iterator_first_time (iterator)
                   + task_schedule_iterator_initial_offset (iterator)
                   - current_offset (task_schedule_iterator_timezone
                                      (iterator));
          start = add_months (first, months_between (first, now));
          if ((start + duration) < now)
            return TRUE;
        }
    }
  else if (duration)
    {
      task_status_t run_status;

      run_status = task_run_status (task_schedule_iterator_task (iterator));

      if (run_status == TASK_STATUS_RUNNING
          || run_status == TASK_STATUS_REQUESTED)
        {
          time_t now, start;

          now = time (NULL);
          start = task_schedule_iterator_first_time (iterator)
                   + task_schedule_iterator_initial_offset (iterator)
                   - current_offset (task_schedule_iterator_timezone
                                      (iterator));
          if ((start + duration) < now)
            return TRUE;
        }
    }

  return FALSE;
}

/**
 * @brief Initialise a schedule task iterator.
 *
 * @param[in]  iterator  Iterator.
 * @param[in]  schedule  Schedule.
 */
void
init_schedule_task_iterator (iterator_t* iterator, schedule_t schedule)
{
  assert (current_credentials.uuid);

  init_iterator (iterator,
                 "SELECT ROWID, uuid, name FROM tasks"
                 " WHERE schedule = %llu AND hidden = 0"
                 " AND ((owner IS NULL) OR (owner ="
                 " (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                 " ORDER BY name ASC;",
                 schedule,
                 current_credentials.uuid);
}

/**
 * @brief Get the UUID from a schedule task iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return UUID, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (schedule_task_iterator_uuid, 1);

/**
 * @brief Get the name from a schedule task iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (schedule_task_iterator_name, 2);

/**
 * @brief Modify a schedule.
 *
 * @param[in]   schedule_id  UUID of schedule.
 * @param[in]   name         Name of schedule.
 * @param[in]   comment      Comment on schedule.
 * @param[in]   first_time   First time action will run.
 * @param[in]   period       How often the action will run in seconds.  0 means
 *                           once.
 * @param[in]   period_months  The months part of the period.
 * @param[in]   duration     The length of the time window the action will run
 *                           in.  0 means entire duration of action.
 * @param[in]   timezone     Timezone.
 *
 * @return 0 success, 1 failed to find schedule, 2 schedule with new name exists,
 *         3 error in type name, 4 schedule_id required, -1 internal error.
 */
int
modify_schedule (const char *schedule_id, const char *name, const char *comment,
                 time_t first_time, time_t period, time_t period_months,
                 time_t duration, const char *timezone)
{
  gchar *quoted_name, *quoted_comment, *quoted_timezone;
  gchar *first_time_string, *duration_string, *period_string;
  gchar *period_months_string, *offset_string;
  schedule_t schedule;

  if (schedule_id == NULL)
    return 4;

  sql ("BEGIN IMMEDIATE;");

  assert (current_credentials.uuid);

  schedule = 0;
  if (find_schedule (schedule_id, &schedule))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (schedule == 0)
    {
      sql ("ROLLBACK;");
      return 1;
    }

  /* Check whether a schedule with the same name exists already. */
  if (name)
    {
      quoted_name = sql_quote (name);
      if (sql_int (0, 0,
                   "SELECT COUNT(*) FROM schedules"
                   " WHERE name = '%s'"
                   " AND ROWID != %llu"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                   quoted_name,
                   schedule,
                   current_credentials.uuid))
        {
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return 2;
        }
    }
  else
    quoted_name = NULL;

  quoted_comment = comment ? sql_quote (comment) : NULL;

  if (duration == -1)
    duration_string = NULL;
  else
    duration_string = g_strdup_printf ("%li", duration);

  if (first_time == -1)
    first_time_string = NULL;
  else
    first_time_string = g_strdup_printf ("%li", first_time);

  if ((period_months == -1) || (period_months == 0))
    {
      if (period == -1)
        {
          period_months_string = NULL;
          period_string = NULL;
        }
      else
        {
          period_months_string = g_strdup ("0");
          period_string = g_strdup_printf ("%li", period);
        }
    }
  else
    {
      period_months_string = g_strdup_printf ("%li", period_months);
      period_string = g_strdup ("0");
    }

  if (first_time)
    {
      if (timezone)
        offset_string = g_strdup_printf ("%li", current_offset (timezone));
      else
        offset_string = NULL;
    }
  else
    offset_string = NULL;

  quoted_timezone = timezone ? sql_quote (timezone) : NULL;

  sql ("UPDATE schedules SET"
       " name = %s%s%s,"
       " comment = %s%s%s,"
       " timezone = %s%s%s,"
       " first_time = %s,"
       " period = %s,"
       " period_months = %s,"
       " duration = %s,"
       " initial_offset = %s,"
       " modification_time = now()"
       " WHERE ROWID = %llu;",
       quoted_name ? "'" : "",
       quoted_name ? quoted_name : "name",
       quoted_name ? "'" : "",
       quoted_comment ? "'" : "",
       quoted_comment ? quoted_comment : "comment",
       quoted_comment ? "'" : "",
       quoted_timezone ? "'" : "",
       quoted_timezone ? quoted_timezone : "timezone",
       quoted_timezone ? "'" : "",
       first_time ? first_time_string : "first_time",
       period_string ? period_string : "period",
       period_months_string ? period_months_string : "period_months",
       (duration >= 0) ? duration_string : "duration",
       offset_string ? offset_string : "initial_offset",
       schedule);

  sql ("UPDATE tasks SET schedule_next_time = "
       " (SELECT first_time FROM schedules WHERE ROWID = %llu)"
       " WHERE schedule = %llu;",
       schedule,
       schedule);

  g_free (duration_string);
  g_free (first_time_string);
  g_free (offset_string);
  g_free (period_string);
  g_free (quoted_comment);
  g_free (quoted_name);
  g_free (quoted_timezone);

  sql ("COMMIT;");

  return 0;
}


/* Report Formats. */

/**
 * @brief Possible port types.
 */
typedef enum
{
  REPORT_FORMAT_FLAG_ACTIVE = 1
} report_format_flag_t;

/**
 * @brief Find a report format given a UUID.
 *
 * @param[in]   uuid           UUID of report format.
 * @param[out]  report_format  Report format return, 0 if succesfully failed to
 *                             find report format.
 *
 * @return FALSE on success (including if failed to find report format), TRUE
 *         on error.
 */
gboolean
find_report_format (const char* uuid, report_format_t* report_format)
{
  gchar *quoted_uuid = sql_quote (uuid);
  if (user_owns_uuid ("report_format", quoted_uuid) == 0)
    {
      g_free (quoted_uuid);
      *report_format = 0;
      return FALSE;
    }
  assert (current_credentials.uuid);
  switch (sql_int64 (report_format, 0, 0,
                     "SELECT ROWID FROM report_formats WHERE uuid = '%s'"
                     " AND ((owner IS NULL) OR (owner ="
                     " (SELECT users.ROWID FROM users"
                     "  WHERE users.uuid = '%s')));",
                     quoted_uuid,
                     current_credentials.uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *report_format = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        g_free (quoted_uuid);
        return TRUE;
        break;
    }

  g_free (quoted_uuid);
  return FALSE;
}

/**
 * @brief Find a report format given a name.
 *
 * @param[in]   name           Name of report_format.
 * @param[out]  report_format  Report format return, 0 if succesfully failed to
 *                             find report_format.
 *
 * @return FALSE on success (including if failed to find report format), TRUE
 *         on error.
 */
gboolean
lookup_report_format (const char* name, report_format_t* report_format)
{
  gchar *quoted_name;

  assert (current_credentials.uuid);

  quoted_name = sql_quote (name);
  if (user_owns ("report_format", "name", quoted_name) == 0)
    {
      g_free (quoted_name);
      *report_format = 0;
      return FALSE;
    }
  switch (sql_int64 (report_format, 0, 0,
                     "SELECT ROWID FROM report_formats"
                     " WHERE name = '%s'"
                     " AND ((owner IS NULL) OR (owner ="
                     " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                     quoted_name,
                     current_credentials.uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *report_format = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        g_free (quoted_name);
        return TRUE;
        break;
    }

  g_free (quoted_name);
  return FALSE;
}

/**
 * @brief Compare files for create_report_format.
 *
 * @param[in]  one  First.
 * @param[in]  two  Second.
 */
static gint
compare_files (gconstpointer one, gconstpointer two)
{
  gchar *file_one, *file_two;
  file_one = *((gchar**) one);
  file_two = *((gchar**) two);
  if (file_one == NULL)
    {
      if (file_two == NULL)
        return 0;
      return 1;
    }
  else if (file_two == NULL)
    return -1;
  return strcoll (file_one, file_two);
}

/**
 * @brief Create a report format.
 *
 * @param[in]   uuid           UUID of format.
 * @param[in]   name           Name of format.
 * @param[in]   content_type   Content type of format.
 * @param[in]   extension      File extension of format.
 * @param[in]   summary        Summary of format.
 * @param[in]   description    Description of format.
 * @param[in]   global         Whether the report is global.
 * @param[in]   files          Array of memory.  Each item is a file name
 *                             string, a terminating NULL, the file contents
 *                             in base64 and a terminating NULL.
 * @param[in]   params         Array of params.
 * @param[in]   params_options Array.  Each item is an array corresponding to
 *                             params.  Each item of an inner array is a string,
 *                             the text of an option in a selection.
 * @param[in]   signature      Signature.
 * @param[out]  report_format  Created report format.
 *
 * @return 0 success, 1 report format exists, 2 empty file name, 3 param value
 *         validation failed, 4 param value validation failed, 5 param default
 *         missing, 6 param min or max out of range, 7 param type missing,
 *         8 duplicate param name, 9 bogus param type name, -1 error.
 */
int
create_report_format (const char *uuid, const char *name,
                      const char *content_type, const char *extension,
                      const char *summary, const char *description, int global,
                      array_t *files, array_t *params, array_t *params_options,
                      const char *signature, report_format_t *report_format)
{
  gchar *quoted_name, *quoted_summary, *quoted_description, *quoted_extension;
  gchar *quoted_content_type, *quoted_signature, *file_name, *dir;
  gchar *candidate_name;
  report_format_t report_format_rowid;
  int index, num;
  gchar *format_signature = NULL;
  gsize format_signature_size;
  int format_trust = TRUST_UNKNOWN;
  create_report_format_param_t *param;

  /* Verify the signature. */

  if (signature
      || (find_signature ("report_formats", uuid, &format_signature,
                          &format_signature_size)
          == 0))
    {
      char *locale;
      GString *format;

      format = g_string_new ("");

      g_string_append_printf (format,
                              "%s%s%s%i",
                              uuid,
                              extension,
                              content_type,
                              global & 1);

      index = 0;
      locale = setlocale (LC_ALL, "C");
      g_ptr_array_sort (files, compare_files);
      setlocale (LC_ALL, locale);
      while ((file_name = (gchar*) g_ptr_array_index (files, index++)))
        g_string_append_printf (format,
                                "%s%s",
                                file_name,
                                file_name + strlen (file_name) + 1);

      index = 0;
      while ((param
               = (create_report_format_param_t*) g_ptr_array_index (params,
                                                                    index++)))
        {
          g_string_append_printf (format,
                                  "%s%s",
                                  param->name,
                                  param->type);

          if (param->type_min)
            {
              long long int min;
              min = strtoll (param->type_min, NULL, 0);
              if (min == LLONG_MIN)
                return 6;
              g_string_append_printf (format, "%lli", min);
            }

          if (param->type_max)
            {
              long long int max;
              max = strtoll (param->type_max, NULL, 0);
              if (max == LLONG_MAX)
                return 6;
              g_string_append_printf (format, "%lli", max);
            }

          g_string_append_printf (format,
                                  "%s",
                                  param->fallback);

          {
            array_t *options;
            int option_index;
            gchar *option_value;

            options = (array_t*) g_ptr_array_index (params_options, index - 1);
            if (options == NULL)
              return -1;
            option_index = 0;
            while ((option_value = (gchar*) g_ptr_array_index (options,
                                                               option_index++)))
              g_string_append_printf (format, "%s", option_value);
          }
        }

      g_string_append_printf (format, "\n");

      if (signature == NULL)
        signature = (const char*) format_signature;

      if (verify_signature (format->str, format->len, signature,
                            strlen (signature), &format_trust))
        {
          g_free (format_signature);
          g_string_free (format, TRUE);
          return -1;
        }
      g_string_free (format, TRUE);
    }

  sql ("BEGIN IMMEDIATE;");

  assert (current_credentials.uuid);
  assert (uuid);
  assert (name);
  assert (files);
  assert (params);

  if (sql_int (0, 0,
               "SELECT COUNT(*) FROM report_formats"
               " WHERE uuid = '%s'"
               " AND ((owner IS NULL) OR (owner ="
               " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
               uuid,
               current_credentials.uuid))
    {
      sql ("ROLLBACK;");
      return 1;
    }

  candidate_name = g_strdup (name);
  quoted_name = sql_quote (candidate_name);

  num = 1;
  while (1)
    {
      if (sql_int (0, 0,
                   "SELECT COUNT(*) FROM report_formats WHERE name = '%s'"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT users.ROWID FROM users"
                   "  WHERE users.uuid = '%s')));",
                   quoted_name,
                   current_credentials.uuid)
          == 0)
        break;
      g_free (candidate_name);
      g_free (quoted_name);
      candidate_name = g_strdup_printf ("%s %u", name, ++num);
      quoted_name = sql_quote (candidate_name);
    }
  g_free (candidate_name);

  /* Write files to disk. */

  if (global)
    dir = g_build_filename (OPENVAS_DATA_DIR,
                            "openvasmd",
                            "global_report_formats",
                            uuid,
                            NULL);
  else
    {
      assert (current_credentials.uuid);
      dir = g_build_filename (OPENVAS_STATE_DIR,
                              "openvasmd",
                              "report_formats",
                              current_credentials.uuid,
                              uuid,
                              NULL);
    }

  if (g_file_test (dir, G_FILE_TEST_EXISTS) && openvas_file_remove_recurse (dir))
    {
      g_warning ("%s: failed to remove dir %s", __FUNCTION__, dir);
      g_free (dir);
      g_free (quoted_name);
      sql ("ROLLBACK;");
      return -1;
    }

  if (g_mkdir_with_parents (dir, 0755 /* "rwxr-xr-x" */))
    {
      g_warning ("%s: failed to create dir %s", __FUNCTION__, dir);
      g_free (dir);
      g_free (quoted_name);
      sql ("ROLLBACK;");
      return -1;
    }

  if (global == 0)
    {
      gchar *report_dir;

      /* glib seems to apply the mode to the first dir only. */

      report_dir = g_build_filename (OPENVAS_STATE_DIR,
                                     "openvasmd",
                                     "report_formats",
                                     current_credentials.uuid,
                                     NULL);

      if (chmod (report_dir, 0755 /* rwxr-xr-x */))
        {
          g_warning ("%s: chmod failed: %s\n",
                     __FUNCTION__,
                     strerror (errno));
          g_free (dir);
          g_free (report_dir);
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return -1;
        }

      g_free (report_dir);
    }

  /* glib seems to apply the mode to the first dir only. */
  if (chmod (dir, 0755 /* rwxr-xr-x */))
    {
      g_warning ("%s: chmod failed: %s\n",
                 __FUNCTION__,
                 strerror (errno));
      g_free (dir);
      g_free (quoted_name);
      sql ("ROLLBACK;");
      return -1;
    }

  index = 0;
  while ((file_name = (gchar*) g_ptr_array_index (files, index++)))
    {
      gchar *contents, *file, *full_file_name;
      gsize contents_size;
      GError *error;

      if (strlen (file_name) == 0)
        {
          openvas_file_remove_recurse (dir);
          g_free (dir);
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return 2;
        }

      file = file_name + strlen (file_name) + 1;
      if (strlen (file))
        contents = (gchar*) g_base64_decode (file, &contents_size);
      else
        {
          contents = g_strdup ("");
          contents_size = 0;
        }

      full_file_name = g_build_filename (dir, file_name, NULL);

      error = NULL;
      g_file_set_contents (full_file_name, contents, contents_size, &error);
      g_free (contents);
      if (error)
        {
          g_warning ("%s: %s", __FUNCTION__, error->message);
          g_error_free (error);
          openvas_file_remove_recurse (dir);
          g_free (full_file_name);
          g_free (dir);
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return -1;
        }

      if (chmod (full_file_name, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH))
        {
          g_warning ("%s: chmod failed: %s\n",
                     __FUNCTION__,
                     strerror (errno));
          openvas_file_remove_recurse (dir);
          g_free (full_file_name);
          g_free (dir);
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return -1;
        }

      g_free (full_file_name);
    }

  /* Add format to database. */

  quoted_summary = summary ? sql_quote (summary) : NULL;
  quoted_description = description ? sql_quote (description) : NULL;
  quoted_extension = extension ? sql_quote (extension) : NULL;
  quoted_content_type = content_type ? sql_quote (content_type) : NULL;
  quoted_signature = signature ? sql_quote (signature) : NULL;
  g_free (format_signature);

  if (global)
    sql ("INSERT INTO report_formats"
         " (uuid, name, owner, summary, description, extension, content_type,"
         "  signature, trust, trust_time, flags, creation_time,"
         "  modification_time)"
         " VALUES ('%s', '%s', NULL, '%s', '%s', '%s', '%s', '%s', %i, %i, 0,"
         "         now (), now ());",
         uuid,
         quoted_name,
         quoted_summary ? quoted_summary : "",
         quoted_description ? quoted_description : "",
         quoted_extension ? quoted_extension : "",
         quoted_content_type ? quoted_content_type : "",
         quoted_signature ? quoted_signature : "",
         format_trust,
         time (NULL));
  else
    sql ("INSERT INTO report_formats"
         " (uuid, name, owner, summary, description, extension, content_type,"
         "  signature, trust, trust_time, flags, creation_time,"
         "  modification_time)"
         " VALUES ('%s', '%s',"
         " (SELECT ROWID FROM users WHERE users.uuid = '%s'),"
         " '%s', '%s', '%s', '%s', '%s', %i, %i, 0, now (), now ());",
         uuid,
         quoted_name,
         current_credentials.uuid,
         quoted_summary ? quoted_summary : "",
         quoted_description ? quoted_description : "",
         quoted_extension ? quoted_extension : "",
         quoted_content_type ? quoted_content_type : "",
         quoted_signature ? quoted_signature : "",
         format_trust,
         time (NULL));

  g_free (quoted_summary);
  g_free (quoted_description);
  g_free (quoted_extension);
  g_free (quoted_content_type);
  g_free (quoted_signature);
  g_free (quoted_name);

  /* Add params to database. */

  report_format_rowid = sqlite3_last_insert_rowid (task_db);
  index = 0;
  while ((param = (create_report_format_param_t*) g_ptr_array_index (params,
                                                                     index++)))
    {
      gchar *quoted_param_name, *quoted_param_value, *quoted_param_fallback;
      rowid_t param_rowid;
      long long int min, max;

      if (param->type == NULL)
        {
          openvas_file_remove_recurse (dir);
          g_free (dir);
          sql ("ROLLBACK;");
          return 7;
        }

      if (report_format_param_type_from_name (param->type)
          == REPORT_FORMAT_PARAM_TYPE_ERROR)
        {
          openvas_file_remove_recurse (dir);
          g_free (dir);
          sql ("ROLLBACK;");
          return 9;
        }

      /* Param min and max are optional.  LLONG_MIN and LLONG_MAX mark in the db
       * that they were missing, so if the user gives LLONG_MIN or LLONG_MAX it
       * is an error.  This ensures that GPG verification works, because the
       * verification knows when to leave out min and max. */

      if (param->type_min)
        {
          min = strtoll (param->type_min, NULL, 0);
          if (min == LLONG_MIN)
            {
              openvas_file_remove_recurse (dir);
              g_free (dir);
              sql ("ROLLBACK;");
              return 6;
            }
        }
      else
        min = LLONG_MIN;

      if (param->type_max)
        {
          max = strtoll (param->type_max, NULL, 0);
          if (max == LLONG_MAX)
            {
              openvas_file_remove_recurse (dir);
              g_free (dir);
              sql ("ROLLBACK;");
              return 6;
            }
        }
      else
        max = LLONG_MAX;

      if (param->fallback == NULL)
        {
          openvas_file_remove_recurse (dir);
          g_free (dir);
          sql ("ROLLBACK;");
          return 5;
        }

      quoted_param_name = sql_quote (param->name);

      if (sql_int (0, 0,
                   "SELECT count(*) FROM report_format_params"
                   " WHERE name = '%s' AND report_format = %llu;",
                   quoted_param_name,
                   report_format_rowid))
        {
          g_free (quoted_param_name);
          openvas_file_remove_recurse (dir);
          g_free (dir);
          sql ("ROLLBACK;");
          return 8;
        }

      quoted_param_value = sql_quote (param->value);
      quoted_param_fallback = sql_quote (param->fallback);

      sql ("INSERT INTO report_format_params"
           " (report_format, name, type, value, type_min, type_max, type_regex,"
           "  fallback)"
           " VALUES (%llu, '%s', %u, '%s', %lli, %lli, '', '%s');",
           report_format_rowid,
           quoted_param_name,
           report_format_param_type_from_name (param->type),
           quoted_param_value,
           min,
           max,
           quoted_param_fallback);

      g_free (quoted_param_name);
      g_free (quoted_param_value);
      g_free (quoted_param_fallback);

      param_rowid = sqlite3_last_insert_rowid (task_db);

      {
        array_t *options;
        int option_index;
        gchar *option_value;

        options = (array_t*) g_ptr_array_index (params_options, index - 1);
        if (options == NULL)
          {
            openvas_file_remove_recurse (dir);
            g_free (dir);
            sql ("ROLLBACK;");
            return -1;
          }
        option_index = 0;
        while ((option_value = (gchar*) g_ptr_array_index (options,
                                                           option_index++)))
          {
            gchar *quoted_option_value = sql_quote (option_value);
            sql ("INSERT INTO report_format_param_options"
                 " (report_format_param, value)"
                 " VALUES (%llu, '%s');",
                 param_rowid,
                 quoted_option_value);
            g_free (quoted_option_value);
          }
      }

      if (validate_param_value (report_format_rowid, param_rowid, param->name,
                                param->value))
        {
          openvas_file_remove_recurse (dir);
          g_free (dir);
          sql ("ROLLBACK;");
          return 3;
        }

      if (validate_param_value (report_format_rowid, param_rowid, param->name,
                                param->fallback))
        {
          openvas_file_remove_recurse (dir);
          g_free (dir);
          sql ("ROLLBACK;");
          return 4;
        }
    }

  if (report_format)
    *report_format = report_format_rowid;

  g_free (dir);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Create Report Format from an existing Report Format.
 *
 * @param[in]  name                 Name of new Report Format. NULL to copy
 *                                  from existing.
 * @param[in]  source_uuid          UUID of existing Report Format.
 * @param[out] new_report_format    New Report Format.
 *
 * @return 0 success, 1 Report Format exists already, 2 failed to find existing
 *         Report Format, -1 error.
 */
int
copy_report_format (const char* name, const char* source_uuid,
                    report_format_t* new_report_format)
{
  report_format_t copy_report_format, source_report_format;
  gchar *quoted_name, *quoted_uuid, *copy_uuid, *source_dir, *copy_dir;
  gchar *tmp_dir;
  int global;
  user_t owner;
  gchar *uniquify;

  assert (current_credentials.uuid);

  if (source_uuid == NULL)
    return -1;

  sql ("BEGIN IMMEDIATE");

  if (find_user (current_credentials.username, &owner)
      || owner == 0)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  copy_uuid = openvas_uuid_make ();
  if (copy_uuid == NULL)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Check that provided name doesn't exist already */
  if (name && strlen (name))
    {
      quoted_name = sql_quote (name);
      if (sql_int (0, 0,
                   "SELECT COUNT (*) from report_formats WHERE name = '%s'"
                   " AND ((owner IS NULL) OR (owner = %llu));",
                   quoted_name,
                   owner))
        {
          sql ("ROLLBACK");
          g_free (quoted_name);
          g_free (copy_uuid);
          return 1;
        }
    }
  else
    quoted_name = NULL;

  /* Check that Report Format to copy exists */
  quoted_uuid = sql_quote (source_uuid);
  if (sql_int (0, 0,
               "SELECT COUNT (*) from report_formats WHERE uuid = '%s'"
               " AND ((owner IS NULL) OR (owner = %llu));",
               quoted_uuid,
               owner)
      == 0)
    {
      sql ("ROLLBACK");
      g_free (quoted_name);
      g_free (quoted_uuid);
      g_free (copy_uuid);
      return 2;
    }

  uniquify = g_strdup_printf("uniquify ('report_format', name,"
                             "%llu, ' Clone')",
                             owner);

  /* Copy Report Format in DB */
  sql ("INSERT INTO report_formats (uuid, owner, name, extension,"
       " content_type, summary, description, signature, trust, trust_time,"
       " flags, creation_time, modification_time)"
       " SELECT '%s', %llu, %s%s%s, extension, content_type, summary,"
       "  description, signature, trust, trust_time, flags, now (), now ()"
       "  FROM report_formats WHERE uuid = '%s';",
       copy_uuid,
       owner,
       quoted_name ? "'" : "",
       quoted_name
        ? quoted_name
        : uniquify,
       quoted_name ? "'" : "",
       quoted_uuid);

  g_free (uniquify);
  copy_report_format = sqlite3_last_insert_rowid (task_db);

  /* Copy Report Format Parameters */
  sql ("INSERT INTO report_format_params "
       " (report_format, name, type, value, type_min, type_max,"
       "  type_regex, fallback)"
       " SELECT %llu, name, type, value, type_min, type_max,"
       "  type_regex, fallback"
       "  FROM report_format_params WHERE report_format = "
       "   (SELECT report_formats.ROWID FROM report_formats"
       "    WHERE report_formats.uuid = '%s');",
       copy_report_format,
       quoted_uuid);
  find_report_format (quoted_uuid, &source_report_format);

  g_free (quoted_name);
  g_free (quoted_uuid);

  /* Copy files on disk */
  global = report_format_global (source_report_format);
  if (global)
    source_dir = g_build_filename (OPENVAS_DATA_DIR,
                                   "openvasmd",
                                   "global_report_formats",
                                   source_uuid,
                                   NULL);
  else
    {
      assert (current_credentials.uuid);
      source_dir = g_build_filename (OPENVAS_STATE_DIR,
                                     "openvasmd",
                                     "report_formats",
                                     current_credentials.uuid,
                                     source_uuid,
                                     NULL);
    }

  /* Check that the directory exists. */
  if (!g_file_test (source_dir, G_FILE_TEST_EXISTS))
    {
      g_warning ("%s: report format directory %s not found",
                 __FUNCTION__, source_dir);
      g_free (source_dir);
      g_free (copy_uuid);
      sql ("ROLLBACK;");
      return -1;
    }

  /* Directory to copy into */
  copy_dir = g_build_filename (OPENVAS_STATE_DIR,
                               "openvasmd",
                               "report_formats",
                               current_credentials.uuid,
                               copy_uuid,
                               NULL);

  if (g_file_test (copy_dir, G_FILE_TEST_EXISTS)
      && openvas_file_remove_recurse (copy_dir))
    {
      g_warning ("%s: failed to remove dir %s", __FUNCTION__, copy_dir);
      g_free (source_dir);
      g_free (copy_dir);
      g_free (copy_uuid);
      sql ("ROLLBACK;");
      return -1;
    }

  if (g_mkdir_with_parents (copy_dir, 0755 /* "rwxr-xr-x" */))
    {
      g_warning ("%s: failed to create dir %s", __FUNCTION__, copy_dir);
      g_free (source_dir);
      g_free (copy_dir);
      g_free (copy_uuid);
      sql ("ROLLBACK;");
      return -1;
    }

  /* Correct permissions as glib doesn't seem to do so. */
  tmp_dir = g_build_filename (OPENVAS_STATE_DIR,
                              "openvasmd",
                              "report_formats",
                              current_credentials.uuid,
                              NULL);

  if (chmod (tmp_dir, 0755 /* rwxr-xr-x */))
    {
      g_warning ("%s: chmod %s failed: %s\n",
                 __FUNCTION__,
                 tmp_dir,
                 strerror (errno));
      g_free (source_dir);
      g_free (copy_dir);
      g_free (copy_uuid);
      g_free (tmp_dir);
      sql ("ROLLBACK;");
      return -1;
    }
  g_free (tmp_dir);

  tmp_dir = g_build_filename (OPENVAS_STATE_DIR,
                              "openvasmd",
                              "report_formats",
                              current_credentials.uuid,
                              copy_uuid,
                              NULL);

  if (chmod (tmp_dir, 0755 /* rwxr-xr-x */))
    {
      g_warning ("%s: chmod %s failed: %s\n",
                 __FUNCTION__,
                 tmp_dir,
                 strerror (errno));
      g_free (source_dir);
      g_free (copy_dir);
      g_free (copy_uuid);
      g_free (tmp_dir);
      sql ("ROLLBACK;");
      return -1;
    }
  g_free (tmp_dir);
  g_free (copy_uuid);

  /* Copy files in directory */
  {
    GDir *directory;
    GError *error;

    error = NULL;
    directory = g_dir_open (source_dir, 0, &error);
    if (directory == NULL)
      {
        if (error)
          {
            g_warning ("g_dir_open(%s) failed - %s\n",
                       source_dir, error->message);
            g_error_free (error);
          }
        g_free (source_dir);
        g_free (copy_dir);
        sql ("ROLLBACK;");
        return -1;
      }
    else
      {
        gchar *source_file, *copy_file;
        const gchar *filename;

        filename = g_dir_read_name (directory);
        while (filename)
          {
            source_file = g_build_filename (source_dir, filename, NULL);
            copy_file = g_build_filename (copy_dir, filename, NULL);

            if (openvas_file_copy (source_file, copy_file) == FALSE)
            {
              g_warning ("%s: copy of %s to %s failed.\n",
                         "copy_report_format", source_file, copy_file);
              g_free (source_file);
              g_free (copy_file);
              g_free (source_dir);
              g_free (copy_dir);
              sql ("ROLLBACK");
              return -1;
            }
            g_free (source_file);
            g_free (copy_file);
            filename = g_dir_read_name (directory);
          }
      }
  }

  sql ("COMMIT");
  g_free (source_dir);
  g_free (copy_dir);
  if (new_report_format) *new_report_format = copy_report_format;
  return 0;
}

/**
 * @brief Delete a report format.
 *
 * @param[in]  report_format_id  UUID of Report format.
 * @param[in]  ultimate          Whether to remove entirely, or to trashcan.
 *
 * @return 0 success, 2 failed to find report format, 3 predefined report
 *         format, -1 error.
 */
int
delete_report_format (const char *report_format_id, int ultimate)
{
  gchar *dir;
  report_format_t report_format, trash_report_format;

  /* This is complicated in two ways
   *
   *   - the UUID of a report format is the same every time it is
   *     imported, so to prevent multiple deletes from producing
   *     duplicate UUIDs in the trashcan, each report format in the
   *     trashcan gets a new UUID,
   *
   *   - the report format has information on disk on top of the
   *     info in the db, so the disk information has to be held
   *     in a special trashcan directory. */

  sql ("BEGIN IMMEDIATE;");

  /* Look in the "real" table. */

  if (find_report_format (report_format_id, &report_format))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (report_format == 0)
    {
      gchar *report_format_string;

      /* Look in the trashcan. */

      if (find_trash ("report_format", report_format_id, &report_format))
        {
          sql ("ROLLBACK;");
          return -1;
        }
      if (report_format == 0)
        {
          sql ("ROLLBACK;");
          return 2;
        }
      if (ultimate == 0)
        {
          /* It's already in the trashcan. */
          sql ("COMMIT;");
          return 0;
        }

      /* Remove entirely. */

      sql ("DELETE FROM report_formats_trash WHERE ROWID = %llu;",
           report_format);
      sql ("DELETE FROM report_format_param_options_trash"
           " WHERE report_format_param"
           " IN (SELECT ROWID from report_format_params_trash"
           "     WHERE report_format = %llu);",
           report_format);
      sql ("DELETE FROM report_format_params_trash WHERE report_format = %llu;",
           report_format);

      /* Remove the dir last, in case any SQL rolls back. */
      report_format_string = g_strdup_printf ("%llu", report_format);
      dir = g_build_filename (OPENVAS_DATA_DIR,
                              "openvasmd",
                              "report_formats_trash",
                              report_format_string,
                              NULL);
      g_free (report_format_string);
      if (g_file_test (dir, G_FILE_TEST_EXISTS) && openvas_file_remove_recurse (dir))
        {
          g_free (dir);
          sql ("ROLLBACK;");
          return -1;
        }
      g_free (dir);

      sql ("COMMIT;");

      return 0;
    }

  if (report_format_predefined (report_format))
    {
      sql ("ROLLBACK;");
      return 3;
    }

  if (report_format_global (report_format))
    dir = g_build_filename (OPENVAS_DATA_DIR,
                            "openvasmd",
                            "global_report_formats",
                            report_format_id,
                            NULL);
  else
    dir = g_build_filename (OPENVAS_STATE_DIR,
                            "openvasmd",
                            "report_formats",
                            current_credentials.uuid,
                            report_format_id,
                            NULL);

  if (ultimate)
    {
      /* Remove directory. */

      if (g_file_test (dir, G_FILE_TEST_EXISTS) && openvas_file_remove_recurse (dir))
        {
          g_free (dir);
          sql ("ROLLBACK;");
          return -1;
        }
    }
  else
    {
      iterator_t params;
      gchar *trash_dir;

      /* Move to trash. */

      trash_dir = g_build_filename (OPENVAS_DATA_DIR,
                                    "openvasmd",
                                    "report_formats_trash",
                                    NULL);
      if (g_mkdir_with_parents (trash_dir, 0755 /* "rwxr-xr-x" */))
        {
          g_warning ("%s: failed to create dir %s", __FUNCTION__, trash_dir);
          g_free (trash_dir);
          sql ("ROLLBACK;");
          return -1;
        }
      g_free (trash_dir);

      sql ("INSERT INTO report_formats_trash"
           " (uuid, owner, name, extension, content_type, summary,"
           "  description, signature, trust, trust_time, flags, original_uuid,"
           "  creation_time, modification_time)"
           " SELECT"
           "  make_uuid (), owner, name, extension, content_type, summary,"
           "  description, signature, trust, trust_time, flags, uuid,"
           "  creation_time, modification_time"
           " FROM report_formats"
           " WHERE ROWID = %llu;",
           report_format);

      trash_report_format = sqlite3_last_insert_rowid (task_db);

      init_report_format_param_iterator (&params, report_format, 0, 1, NULL);
      while (next (&params))
        {
          report_format_param_t param, trash_param;

          param = report_format_param_iterator_param (&params);

          sql ("INSERT INTO report_format_params_trash"
               " (report_format, name, type, value, type_min, type_max,"
               "  type_regex, fallback)"
               " SELECT"
               "  %llu, name, type, value, type_min, type_max,"
               "  type_regex, fallback"
               " FROM report_format_params"
               " WHERE ROWID = %llu;",
               trash_report_format,
               param);

          trash_param = sqlite3_last_insert_rowid (task_db);

          sql ("INSERT INTO report_format_param_options_trash"
               " (report_format_param, value)"
               " SELECT %llu, value"
               " FROM report_format_param_options"
               " WHERE report_format_param = %llu;",
               trash_param,
               param);
        }
      cleanup_iterator (&params);
    }

  /* Remove from "real" tables. */

  sql ("DELETE FROM report_formats WHERE ROWID = %llu;", report_format);
  sql ("DELETE FROM report_format_param_options WHERE report_format_param"
       " IN (SELECT ROWID from report_format_params WHERE report_format = %llu);",
       report_format);
  sql ("DELETE FROM report_format_params WHERE report_format = %llu;",
       report_format);

  /* Move the dir last, in case any SQL rolls back. */

  if (ultimate == 0)
    {
      gchar *new_dir, *report_format_string;

      report_format_string = g_strdup_printf ("%llu", trash_report_format);
      new_dir = g_build_filename (OPENVAS_DATA_DIR,
                                  "openvasmd",
                                  "report_formats_trash",
                                  report_format_string,
                                  NULL);
      g_free (report_format_string);
      if (g_file_test (dir, G_FILE_TEST_EXISTS))
        {
          if (rename (dir, new_dir))
            {
              g_warning ("%s: rename %s to %s: %s\n",
                         __FUNCTION__, dir, new_dir, strerror (errno));
              g_free (dir);
              g_free (new_dir);
              sql ("ROLLBACK;");
              return -1;
            }
        }
      else
        {
          g_warning ("%s: report dir missing: %s\n",
                     __FUNCTION__, dir);
          g_free (dir);
          g_free (new_dir);
          sql ("ROLLBACK;");
          return -1;
        }
      g_free (new_dir);
    }
  g_free (dir);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Verify a report format.
 *
 * @param[in]  report_format  Report format.
 *
 * @return 0 success, -1 error.
 */
int
verify_report_format (report_format_t report_format)
{
  int format_trust = TRUST_UNKNOWN;
  iterator_t formats;
  get_data_t get;

  sql ("BEGIN IMMEDIATE;");

  memset(&get, '\0', sizeof (get));
  get.id = report_format_uuid (report_format);
  init_report_format_iterator (&formats, &get);
  if (next (&formats))
    {
      const char *signature;
      gchar *format_signature = NULL;
      gsize format_signature_size;

      signature = report_format_iterator_signature (&formats);

      find_signature ("report_formats",
                      report_format_iterator_uuid (&formats),
                      &format_signature,
                      &format_signature_size);

      if ((signature && strlen (signature))
          || format_signature)
        {
          GString *format;
          file_iterator_t files;
          iterator_t params;
          report_format_t report_format;

          format = g_string_new ("");

          g_string_append_printf
           (format,
            "%s%s%s%i",
            report_format_iterator_uuid (&formats),
            report_format_iterator_extension (&formats),
            report_format_iterator_content_type (&formats),
            report_format_global
             (report_format_iterator_report_format
              (&formats)) & 1);

          report_format = report_format_iterator_report_format (&formats);

          init_report_format_file_iterator (&files, report_format);
          while (next_file (&files))
            {
              gchar *content = file_iterator_content_64 (&files);
              g_string_append_printf (format,
                                      "%s%s",
                                      file_iterator_name (&files),
                                      content);
              g_free (content);
            }
          cleanup_file_iterator (&files);

          init_report_format_param_iterator (&params,
                                             report_format,
                                             0,
                                             1,
                                             NULL);
          while (next (&params))
            {
              g_string_append_printf
               (format,
                "%s%s",
                report_format_param_iterator_name (&params),
                report_format_param_iterator_type_name (&params));

              if (report_format_param_iterator_type_min (&params) > LLONG_MIN)
                g_string_append_printf
                 (format,
                  "%lli",
                  report_format_param_iterator_type_min (&params));

              if (report_format_param_iterator_type_max (&params) < LLONG_MAX)
                g_string_append_printf
                 (format,
                  "%lli",
                  report_format_param_iterator_type_max (&params));

              g_string_append_printf
               (format,
                "%s%s",
                report_format_param_iterator_type_regex (&params),
                report_format_param_iterator_fallback (&params));

              {
                iterator_t options;
                init_param_option_iterator
                 (&options,
                  report_format_param_iterator_param (&params),
                  1,
                  NULL);
                while (next (&options))
                  if (param_option_iterator_value (&options))
                    g_string_append_printf
                     (format,
                      "%s",
                      param_option_iterator_value (&options));
              }
            }
          cleanup_iterator (&params);

          g_string_append_printf (format, "\n");

          if (format_signature)
            {
              /* Try the feed signature. */
              if (verify_signature (format->str, format->len, format_signature,
                                    strlen (format_signature), &format_trust))
                {
                  cleanup_iterator (&formats);
                  g_free (format_signature);
                  sql ("ROLLBACK;");
                  g_string_free (format, TRUE);
                  return -1;
                }
            }
          else if (signature && strlen (signature))
            {
              /* Try the signature from the database. */
              if (verify_signature (format->str, format->len, signature,
                                    strlen (signature), &format_trust))
                {
                  cleanup_iterator (&formats);
                  g_free (format_signature);
                  sql ("ROLLBACK;");
                  g_string_free (format, TRUE);
                  return -1;
                }
            }

          g_free (format_signature);
          g_string_free (format, TRUE);
        }
    }
  else
    {
      sql ("ROLLBACK;");
      return -1;
    }
  cleanup_iterator (&formats);

  sql ("UPDATE report_formats SET trust = %i, trust_time = %i,"
       "                          modification_time = now ()"
       " WHERE ROWID = %llu;",
       format_trust,
       time (NULL),
       report_format);
  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Return the UUID of a report format.
 *
 * @param[in]  report_format  Report format.
 *
 * @return Newly allocated UUID.
 */
char *
report_format_uuid (report_format_t report_format)
{
  return sql_string (0, 0,
                     "SELECT uuid FROM report_formats WHERE ROWID = %llu;",
                     report_format);
}

/**
 * @brief Set the active flag of a report format.
 *
 * @param[in]  report_format  The report format.
 * @param[in]  active         Active flag.
 */
void
set_report_format_active (report_format_t report_format, int active)
{
  if (active)
    sql ("UPDATE report_formats SET flags = (flags | %llu), "
         "                          modification_time = now ()"
         " WHERE ROWID = %llu;",
         (long long int) REPORT_FORMAT_FLAG_ACTIVE,
         report_format);
  else
    sql ("UPDATE report_formats SET flags = (flags & ~ %llu), "
         "                          modification_time = now ()"
         " WHERE ROWID = %llu;",
         (long long int) REPORT_FORMAT_FLAG_ACTIVE,
         report_format);
}

/**
 * @brief Return the name of a report format.
 *
 * @param[in]  report_format  Report format.
 *
 * @return Newly allocated name.
 */
char *
report_format_name (report_format_t report_format)
{
  return sql_string (0, 0,
                     "SELECT name FROM report_formats WHERE ROWID = %llu;",
                     report_format);
}

/**
 * @brief Return the content type of a report format.
 *
 * @param[in]  report_format  Report format.
 *
 * @return Newly allocated content type.
 */
char *
report_format_content_type (report_format_t report_format)
{
  return sql_string (0, 0,
                     "SELECT content_type FROM report_formats WHERE ROWID = %llu;",
                     report_format);
}

/**
 * @brief Return whether a report format is referenced by an alert
 *
 * @param[in]  report format  Report Format.
 *
 * @return 1 if in use, else 0.
 */
int
report_format_in_use (report_format_t report_format)
{
  return !!sql_int (0, 0,
                    "SELECT count(*) FROM alert_method_data WHERE data = "
                    " ( SELECT uuid FROM report_formats WHERE ROWID = %llu)"
                    " AND (name = 'notice_attach_format' OR "
                    "      name = 'notice_report_format');",
                    report_format);
}

/**
 * @brief Return whether a report_format in trash is referenced by an alert
 *
 * @param[in]  report_format  Report Format.
 *
 * @return 1 if in use, else 0.
 */
int
trash_report_format_in_use (report_format_t report_format)
{
  return !!sql_int (0, 0,
                    "SELECT count(*) FROM alert_method_data WHERE data = "
                    " (SELECT uuid FROM report_formats_trash"
                    "  WHERE ROWID = %llu)"
                    " AND (name = 'notice_attach_format' OR "
                    "      name = 'notice_report_format');",
                    report_format);
}

/**
 * @brief Return whether a report format is writable.
 *
 * @param[in]  report_format Report Format.
 *
 * @return 1 if writable, else 0.
 */
int
report_format_writable (report_format_t report_format)
{
  return (report_format_in_use (report_format) == 0
          && report_format_global (report_format) == 0);
}

/**
 * @brief Return whether a trashcan report_format is writable.
 *
 * @param[in]  report_format  Report Format.
 *
 * @return 1 if writable, else 0.
 */
int
trash_report_format_writable (report_format_t report_format)
{
  return (trash_report_format_in_use (report_format) == 0
          && report_format_global (report_format) == 0);
}

/**
 * @brief Return the extension of a report format.
 *
 * @param[in]  report_format  Report format.
 *
 * @return Newly allocated extension.
 */
char *
report_format_extension (report_format_t report_format)
{
  return sql_string (0, 0,
                     "SELECT extension FROM report_formats WHERE ROWID = %llu;",
                     report_format);
}

/**
 * @brief Set the name of the report format.
 *
 * @param[in]  report_format  The report format.
 * @param[in]  name           Name.
 */
void
set_report_format_name (report_format_t report_format, const char *name)
{
  gchar *quoted_name = sql_quote (name);
  sql ("UPDATE report_formats SET name = '%s', modification_time = now ()"
       " WHERE ROWID = %llu;",
       quoted_name,
       report_format);
  g_free (quoted_name);
}

/**
 * @brief Return whether a report format is global.
 *
 * @param[in]  report_format  Report format.
 *
 * @return 1 if global, else 0.
 */
int
report_format_global (report_format_t report_format)
{
  return sql_int (0, 0,
                  "SELECT owner is NULL FROM report_formats"
                  " WHERE ROWID = %llu;",
                  report_format);
}

/**
 * @brief Return whether a report format is predefined.
 *
 * @param[in]  report_format  Report format.
 *
 * @return 1 if predefined, else 0.
 */
int
report_format_predefined (report_format_t report_format)
{
  return sql_int (0, 0,
                  "SELECT uuid = '910200ca-dc05-11e1-954f-406186ea4fc5'"
                  " OR uuid = '5ceff8ba-1f62-11e1-ab9f-406186ea4fc5'"
                  " OR uuid = '6c248850-1f62-11e1-b082-406186ea4fc5'"
                  " OR uuid = '77bd6c4a-1f62-11e1-abf0-406186ea4fc5'"
                  " OR uuid = 'a684c02c-b531-11e1-bdc2-406186ea4fc5'"
                  " OR uuid = '9ca6fe72-1f62-11e1-9e7c-406186ea4fc5'"
                  " OR uuid = 'c402cc3e-b531-11e1-9163-406186ea4fc5'"
                  " OR uuid = 'a3810a62-1f62-11e1-9219-406186ea4fc5'"
                  " OR uuid = 'a994b278-1f62-11e1-96ac-406186ea4fc5'"
                  " FROM report_formats"
                  " WHERE ROWID = %llu;",
                  report_format);
}

/**
 * @brief Return whether a report format is global.
 *
 * @param[in]  report_format  Report format.
 *
 * @return 1 if global, else 0.
 */
static int
report_format_trash_global (report_format_t report_format)
{
  return sql_int (0, 0,
                  "SELECT owner is NULL FROM report_formats_trash"
                  " WHERE ROWID = %llu;",
                  report_format);
}

/**
 * @brief Return whether a report format is active.
 *
 * @param[in]  report_format  Report format.
 *
 * @return -1 on error, 1 if active, else 0.
 */
int
report_format_active (report_format_t report_format)
{
  long long int flag;
  switch (sql_int64 (&flag, 0, 0,
                     "SELECT flags & %llu FROM report_formats"
                     " WHERE ROWID = %llu;",
                     (long long int) REPORT_FORMAT_FLAG_ACTIVE,
                     report_format))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        return 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        return -1;
        break;
    }
  return flag ? 1 : 0;
}

/**
 * @brief Set the summary of the report format.
 *
 * @param[in]  report_format  The report format.
 * @param[in]  summary        Summary.
 */
void
set_report_format_summary (report_format_t report_format, const char *summary)
{
  gchar *quoted_summary = sql_quote (summary);
  sql ("UPDATE report_formats SET summary = '%s', modification_time = now ()"
       " WHERE ROWID = %llu;",
       quoted_summary,
       report_format);
  g_free (quoted_summary);
}

/**
 * @brief Return the type max of a report format param.
 *
 * @param[in]  report_format  Report format.
 * @param[in]  name           Name of param.
 *
 * @return Param type.
 */
static report_format_param_type_t
report_format_param_type (report_format_t report_format, const char *name)
{
  report_format_param_type_t type;
  gchar *quoted_name = sql_quote (name);
  type = (report_format_param_type_t)
         sql_int (0, 0,
                  "SELECT type FROM report_format_params"
                  " WHERE report_format = %llu AND name = '%s';",
                  report_format,
                  quoted_name);
  g_free (quoted_name);
  return type;
}

/**
 * @brief Return the type max of a report format param.
 *
 * @param[in]  report_format  Report format.
 * @param[in]  name           Name of param.
 *
 * @return Max.
 */
static long long int
report_format_param_type_max (report_format_t report_format, const char *name)
{
  long long int max = 0;
  gchar *quoted_name = sql_quote (name);
  /* Assume it's there. */
  sql_int64 (&max, 0, 0,
             "SELECT type_max FROM report_format_params"
             " WHERE report_format = %llu AND name = '%s';",
             report_format,
             quoted_name);
  g_free (quoted_name);
  return max;
}

/**
 * @brief Return the type min of a report format param.
 *
 * @param[in]  report_format  Report format.
 * @param[in]  name           Name of param.
 *
 * @return Min.
 */
static long long int
report_format_param_type_min (report_format_t report_format, const char *name)
{
  long long int min = 0;
  gchar *quoted_name = sql_quote (name);
  /* Assume it's there. */
  sql_int64 (&min, 0, 0,
             "SELECT type_min FROM report_format_params"
             " WHERE report_format = %llu AND name = '%s';",
             report_format,
             quoted_name);
  g_free (quoted_name);
  return min;
}


/**
 * @brief Validate a value for a report format param.
 *
 * @param[in]  report_format  Report format.
 * @param[in]  param          Param.
 * @param[in]  name           Name of param.
 * @param[in]  value          Potential value of param.
 *
 * @return 0 success, 1 fail.
 */
static int
validate_param_value (report_format_t report_format,
                      report_format_param_t param, const char *name,
                      const char *value)
{
  switch (report_format_param_type (report_format, name))
    {
      case REPORT_FORMAT_PARAM_TYPE_INTEGER:
        {
          long long int min, max, actual;
          min = report_format_param_type_min (report_format, name);
          /* Simply truncate out of range values. */
          actual = strtoll (value, NULL, 0);
          if (actual < min)
            return 1;
          max = report_format_param_type_max (report_format, name);
          if (actual > max)
            return 1;
        }
        break;
      case REPORT_FORMAT_PARAM_TYPE_SELECTION:
        {
          iterator_t options;
          int found = 0;

          init_param_option_iterator (&options, param, 1, NULL);
          while (next (&options))
            if (param_option_iterator_value (&options)
                && (strcmp (param_option_iterator_value (&options), value)
                    == 0))
              {
                found = 1;
                break;
              }
          cleanup_iterator (&options);
          if (found)
            break;
          return 1;
        }
      case REPORT_FORMAT_PARAM_TYPE_STRING:
      case REPORT_FORMAT_PARAM_TYPE_TEXT:
        {
          long long int min, max, actual;
          min = report_format_param_type_min (report_format, name);
          actual = strlen (value);
          if (actual < min)
            return 1;
          max = report_format_param_type_max (report_format, name);
          if (actual > max)
            return 1;
        }
        break;
      default:
        break;
    }
  return 0;
}

/**
 * @brief Set the value of the report format param.
 *
 * @param[in]  report_format  The report format.
 * @param[in]  name           Param name.
 * @param[in]  value_64       Param value in base64.
 *
 * @return 0 success, 1 failed to find param, 2 validation of value failed,
 *         -1 error.
 */
int
set_report_format_param (report_format_t report_format, const char *name,
                         const char *value_64)
{
  gchar *quoted_name, *quoted_value, *value;
  gsize value_size;
  report_format_param_t param;

  quoted_name = sql_quote (name);

  sql ("BEGIN IMMEDIATE;");

  /* Ensure the param exists. */

  switch (sql_int64 (&param, 0, 0,
                     "SELECT ROWID FROM report_format_params"
                     " WHERE name = '%s';",
                     quoted_name))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        g_free (quoted_name);
        sql ("ROLLBACK;");
        return 1;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        g_free (quoted_name);
        sql ("ROLLBACK;");
        return -1;
        break;
    }

  /* Translate the value. */

  if (value_64 && strlen (value_64))
    value = (gchar*) g_base64_decode (value_64, &value_size);
  else
    {
      value = g_strdup ("");
      value_size = 0;
    }

  /* Validate the value. */

  if (validate_param_value (report_format, param, name, value))
    {
      sql ("ROLLBACK;");
      g_free (quoted_name);
      return 2;
    }

  quoted_value = sql_quote (value);
  g_free (value);

  /* Update the database. */

  sql ("UPDATE report_format_params SET value = '%s'"
       " WHERE report_format = %llu AND name = '%s';",
       quoted_value,
       report_format,
       quoted_name);

  g_free (quoted_name);
  g_free (quoted_value);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Return the trust of a report format.
 *
 * @param[in]  report_format  Report format.
 *
 * @return Trust: 1 yes, 2 no, 2 unknown.
 */
int
report_format_trust (report_format_t report_format)
{
  return sql_int (0, 0,
                  "SELECT trust FROM report_formats WHERE ROWID = %llu;",
                  report_format);
}

/**
 * @brief Filter columns for Report Format iterator.
 */
#define REPORT_FORMAT_ITERATOR_FILTER_COLUMNS                                 \
 { ANON_GET_ITERATOR_FILTER_COLUMNS, "name", "extension", "content_type",     \
   "summary", "description", "trust", "trust_time", "active"                  \
   , NULL }

/**
 * @brief Report Format iterator columns.
 */
#define REPORT_FORMAT_ITERATOR_COLUMNS                                        \
    /* ANON doesn't have name column */                                       \
  "ROWID, uuid, name, '', iso_time (creation_time),"                          \
  " iso_time (modification_time), creation_time AS created,"                  \
  " modification_time AS modified, extension, content_type, summary, "        \
  " description, signature, trust, trust_time, flags & 1 AS active"

/**
 * @brief Report Format iterator columns for trash case.
 */
#define REPORT_FORMAT_ITERATOR_TRASH_COLUMNS                                  \
    /* ANON doesn't have name column */                                       \
  "ROWID, uuid, name, '', iso_time (creation_time),"                          \
  " iso_time (modification_time), creation_time AS created,"                  \
  " modification_time AS modified, extension, content_type, summary, "        \
  " description, signature, trust, trust_time, flags"

/**
 * @brief Count the number of Report Formats.
 *
 * @param[in]  get  GET params.
 *
 * @return Total number of Report Formats filtered set.
 */
int
report_format_count (const get_data_t *get)
{
  static const char *extra_columns[] = REPORT_FORMAT_ITERATOR_FILTER_COLUMNS;
  return count ("report_format", get, REPORT_FORMAT_ITERATOR_COLUMNS,
                extra_columns, 0, 0, 0, TRUE);
}

/**
 * @brief Initialise a Report Format iterator, including observed Report
 *        Formats.
 *
 * @param[in]  iterator    Iterator.
 * @param[in]  get         GET data.
 *
 * @return 0 success, 1 failed to find Report Format, 2 failed to find filter,
 *         -1 error.
 */
int
init_report_format_iterator (iterator_t* iterator, const get_data_t *get)
{
  static const char *filter_columns[] = REPORT_FORMAT_ITERATOR_FILTER_COLUMNS;

  return init_get_iterator (iterator,
                            "report_format",
                            get,
                            /* Columns. */
                            REPORT_FORMAT_ITERATOR_COLUMNS,
                            /* Columns for trashcan. */
                            REPORT_FORMAT_ITERATOR_TRASH_COLUMNS,
                            filter_columns,
                            NULL,
                            0,
                            NULL,
                            NULL,
                            TRUE);
}

/**
 * @brief Get the report format from a report format iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Report_Format.
 */
report_format_t
report_format_iterator_report_format (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (report_format_t) sqlite3_column_int64 (iterator->stmt, 0);
}

/**
 * @brief Get the UUID from a report format iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return UUID, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (report_format_iterator_uuid, 1);

/**
 * @brief Get the name from a report format iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (report_format_iterator_name, 2);

/**
 * @brief Get the extension from a report format iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Extension, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (report_format_iterator_extension, GET_ITERATOR_COLUMN_COUNT);

/**
 * @brief Get the content type from a report format iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Content type, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (report_format_iterator_content_type, GET_ITERATOR_COLUMN_COUNT + 1);

/**
 * @brief Get the summary from a report format iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Summary, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (report_format_iterator_summary, GET_ITERATOR_COLUMN_COUNT + 2);

/**
 * @brief Get the description from a report format iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Description, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (report_format_iterator_description, GET_ITERATOR_COLUMN_COUNT + 3);

/**
 * @brief Get the signature from a report format iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Signature, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (report_format_iterator_signature, GET_ITERATOR_COLUMN_COUNT + 4);

/**
 * @brief Get the trust value from a report format iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Trust value.
 */
const char*
report_format_iterator_trust (iterator_t* iterator)
{
  if (iterator->done) return NULL;
  switch (sqlite3_column_int (iterator->stmt, GET_ITERATOR_COLUMN_COUNT + 5))
    {
      case 1:  return "yes";
      case 2:  return "no";
      case 3:  return "unknown";
      default: return NULL;
    }
}

/**
 * @brief Get the trust time from a report format iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Time report format was verified.
 */
time_t
report_format_iterator_trust_time (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (time_t) sqlite3_column_int (iterator->stmt,
                                     GET_ITERATOR_COLUMN_COUNT + 6);
  return ret;
}

/**
 * @brief Get the active flag from a report format iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Active flag, or -1 if iteration is complete.
 */
int
report_format_iterator_active (iterator_t* iterator)
{
  if (iterator->done) return -1;
  return (sqlite3_column_int64 (iterator->stmt, GET_ITERATOR_COLUMN_COUNT + 7)
          & REPORT_FORMAT_FLAG_ACTIVE) ? 1 : 0;
}

/**
 * @brief Initialise a Report Format alert iterator.
 *
 * Iterates over all alerts that use the Report Format.
 *
 * @param[in]  iterator          Iterator.
 * @param[in]  report_format     Report Format.
 */
void
init_report_format_alert_iterator (iterator_t* iterator,
                                   report_format_t report_format)
{
  assert (current_credentials.uuid);

  init_iterator (iterator,
                 "SELECT DISTINCT alerts.name, alerts.uuid"
                 " FROM alerts, alert_method_data"
                 " WHERE alert_method_data.data = '%s'"
                 " AND alert_method_data.alert = alerts.ROWID"
                 " AND ((owner IS NULL) OR (owner ="
                 " (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                 " ORDER BY alerts.name ASC;",
                 report_format_uuid(report_format),
                 current_credentials.uuid);
}

/**
 * @brief Get the name from a report_format_alert iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The name of the Report Format, or NULL if iteration is complete.
 *         Freed by cleanup_iterator.
 */
DEF_ACCESS (report_format_alert_iterator_name, 0);

/**
 * @brief Get the UUID from a report_format_alert iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The UUID of the Report Format, or NULL if iteration is complete.
 *         Freed by cleanup_iterator.
 */
DEF_ACCESS (report_format_alert_iterator_uuid, 1);

/**
 * @brief Initialise a report format iterator.
 *
 * @param[in]  iterator       Iterator.
 * @param[in]  report_format  Single report_format to iterate over, or 0 for all.
 * @param[in]  trash          Whether to iterate over trashcan report formats.
 * @param[in]  ascending      Whether to sort ascending or descending.
 * @param[in]  sort_field     Field to sort on, or NULL for "ROWID".
 */
void
init_report_format_param_iterator (iterator_t* iterator,
                                   report_format_t report_format,
                                   int trash,
                                   int ascending,
                                   const char* sort_field)
{
  if (report_format)
    init_iterator (iterator,
                   "SELECT ROWID, name, value, type, type_min, type_max,"
                   " type_regex, fallback"
                   " FROM report_format_params%s"
                   " WHERE report_format = %llu"
                   " ORDER BY %s %s;",
                   trash ? "_trash" : "",
                   report_format,
                   sort_field ? sort_field : "ROWID",
                   ascending ? "ASC" : "DESC");
  else
    init_iterator (iterator,
                   "SELECT ROWID, name, value, type, type_min, type_max,"
                   " type_regex, fallback"
                   " FROM report_format_params%s"
                   " ORDER BY %s %s;",
                   trash ? "_trash" : "",
                   sort_field ? sort_field : "ROWID",
                   ascending ? "ASC" : "DESC");
}

/**
 * @brief Get the report format param from a report format param iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Report format param.
 */
report_format_param_t
report_format_param_iterator_param (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (report_format_param_t) sqlite3_column_int64 (iterator->stmt, 0);
}

/**
 * @brief Get the name from a report format param iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (report_format_param_iterator_name, 1);

/**
 * @brief Get the value from a report format param iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Value, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (report_format_param_iterator_value, 2);

/**
 * @brief Get the name of the type of a report format param iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Static string naming type, or NULL if iteration is complete.
 */
const char *
report_format_param_iterator_type_name (iterator_t* iterator)
{
  if (iterator->done) return NULL;
  return report_format_param_type_name (sqlite3_column_int (iterator->stmt, 3));
}

/**
 * @brief Get the type from a report format param iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Type.
 */
report_format_param_type_t
report_format_param_iterator_type (iterator_t* iterator)
{
  if (iterator->done) return -1;
  return sqlite3_column_int (iterator->stmt, 3);
}

/**
 * @brief Get the type min from a report format param iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Type min.
 */
long long int
report_format_param_iterator_type_min (iterator_t* iterator)
{
  if (iterator->done) return -1;
  return sqlite3_column_int64 (iterator->stmt, 4);
}

/**
 * @brief Get the type max from a report format param iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Type max.
 */
long long int
report_format_param_iterator_type_max (iterator_t* iterator)
{
  if (iterator->done) return -1;
  return sqlite3_column_int64 (iterator->stmt, 5);
}

/**
 * @brief Get the type regex from a report format param iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Type regex, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (report_format_param_iterator_type_regex, 6);

/**
 * @brief Get the default from a report format param iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Default, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (report_format_param_iterator_fallback, 7);

/**
 * @brief Initialise a report format param option iterator.
 *
 * @param[in]  iterator             Iterator.
 * @param[in]  report_format_param  Param whose options to iterate over.
 * @param[in]  ascending            Whether to sort ascending or descending.
 * @param[in]  sort_field           Field to sort on, or NULL for "ROWID".
 */
void
init_param_option_iterator (iterator_t* iterator,
                            report_format_param_t report_format_param,
                            int ascending, const char *sort_field)
{
  init_iterator (iterator,
                 "SELECT ROWID, value"
                 " FROM report_format_param_options"
                 " WHERE report_format_param = %llu"
                 " ORDER BY %s %s;",
                 report_format_param,
                 sort_field ? sort_field : "ROWID",
                 ascending ? "ASC" : "DESC");
}

/**
 * @brief Get the value from a report format param option iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Value, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (param_option_iterator_value, 1);


/* Slaves. */

/**
 * @brief Find a slave given a UUID.
 *
 * @param[in]   uuid   UUID of slave.
 * @param[out]  slave  Slave return, 0 if succesfully failed to find slave.
 *
 * @return FALSE on success (including if failed to find slave), TRUE on error.
 */
gboolean
find_slave (const char* uuid, slave_t* slave)
{
  return find_resource ("slave", uuid, slave);
}

/**
 * @brief Create a slave.
 *
 * @param[in]   name            Name of slave.
 * @param[in]   comment         Comment on slave.
 * @param[in]   host            Host of slave.
 * @param[in]   port            Port on host.
 * @param[in]   login           Host login name.
 * @param[in]   password        Password for \p login.
 * @param[out]  slave           NULL, or address for created slave.
 *
 * @return 0 success, 1 slave exists already, -1 error.
 */
int
create_slave (const char* name, const char* comment, const char* host,
              const char* port, const char* login, const char* password,
              slave_t* slave)
{
  gchar *quoted_name, *quoted_host, *quoted_port, *quoted_login;
  gchar *quoted_password;

  assert (name);
  assert (host);
  assert (port);
  assert (login);
  assert (password);

  quoted_name = sql_quote (name);

  sql ("BEGIN IMMEDIATE;");

  assert (current_credentials.uuid);

  /* Check whether a slave with the same name exists already. */
  if (sql_int (0, 0,
               "SELECT COUNT(*) FROM slaves"
               " WHERE name = '%s'"
               " AND ((owner IS NULL) OR (owner ="
               " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
               quoted_name,
               current_credentials.uuid))
    {
      g_free (quoted_name);
      sql ("ROLLBACK;");
      return 1;
    }

  quoted_host = sql_quote (host);
  quoted_port = sql_quote (port);
  quoted_login = sql_quote (login);
  quoted_password = sql_quote (password);

  if (comment)
    {
      gchar *quoted_comment = sql_quote (comment);
      sql ("INSERT INTO slaves"
           " (uuid, name, owner, comment, host, port, login, password,"
           "  creation_time, modification_time)"
           " VALUES (make_uuid (), '%s',"
           " (SELECT ROWID FROM users WHERE users.uuid = '%s'),"
           " '%s', '%s', '%s', '%s', '%s', now (), now ());",
           quoted_name, current_credentials.uuid, quoted_comment, quoted_host,
           quoted_port, quoted_login, quoted_password);
      g_free (quoted_comment);
    }
  else
    sql ("INSERT INTO slaves"
         " (uuid, name, owner, comment, host, port, login, password,"
         " creation_time, modification_time)"
         " VALUES (make_uuid (), '%s',"
         " (SELECT ROWID FROM users WHERE users.uuid = '%s'),"
         " '%s', '', '%s', '%s', '%s', now (), now ());",
         quoted_name, current_credentials.uuid, quoted_host, quoted_port,
         quoted_login, quoted_password);

  if (slave)
    *slave = sqlite3_last_insert_rowid (task_db);

  g_free (quoted_name);
  g_free (quoted_host);
  g_free (quoted_port);
  g_free (quoted_login);
  g_free (quoted_password);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Create a slave from an existing slave.
 *
 * @param[in]  name          Name of new slave. NULL to copy from existing.
 * @param[in]  comment       Comment on new slave. NULL to copy from
 *                           existing.
 * @param[in]  slave_id      UUID of existing slave.
 * @param[out] new_slave     New slave.
 *
 * @return 0 success, 1 slave exists already, 2 failed to find existing slave,
 *         -1 error.
 */
int
copy_slave (const char* name, const char* comment, const char *slave_id,
             slave_t* new_slave)
{
  return copy_resource ("slave", name, comment, slave_id,
                        "host, port, login, password",
                        new_slave);
}

/**
 * @brief Modify a slave.
 *
 * @param[in]   slave_id        UUID of slave.
 * @param[in]   name            Name of slave.
 * @param[in]   comment         Comment on slave.
 * @param[in]   host            Host of slave.
 * @param[in]   port            Port on host.
 * @param[in]   login           Host login name.
 * @param[in]   password        Password for \p login.
 *
 * @return 0 success, 1 failed to find slave, 2 slave with new name exists,
 *         3 slave_id required, -1 internal error.
 */
int
modify_slave (const char *slave_id, const char *name, const char *comment,
              const char *host, const char *port, const char *login,
              const char *password)
{
  gchar *quoted_name, *quoted_comment, *quoted_host, *quoted_port;
  gchar *quoted_login, *quoted_password;
  slave_t slave;

  if (slave_id == NULL)
    return 3;

  sql ("BEGIN IMMEDIATE;");

  assert (current_credentials.uuid);

  slave = 0;
  if (find_slave (slave_id, &slave))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (slave == 0)
    {
      sql ("ROLLBACK;");
      return 1;
    }

  /* Check whether a slave with the same name exists already. */
  if (name)
    {
      quoted_name = sql_quote (name);
      if (sql_int (0, 0,
                   "SELECT COUNT(*) FROM slaves"
                   " WHERE name = '%s'"
                   " AND ROWID != %llu"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                   quoted_name,
                   slave,
                   current_credentials.uuid))
        {
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return 2;
        }
    }
  else
    quoted_name = sql_quote("");

  quoted_comment = sql_quote (comment ? comment : "");
  quoted_host = sql_quote (host ? host : "");
  quoted_port = sql_quote (port ? port : "");
  quoted_login = sql_quote (login ? login : "");
  quoted_password = sql_quote (password ? password : "");

  sql ("UPDATE slaves SET"
       " name = '%s',"
       " comment = '%s',"
       " host = '%s',"
       " port = '%s',"
       " login = '%s',"
       " password = '%s',"
       " modification_time = now ()"
       " WHERE ROWID = %llu;",
       quoted_name,
       quoted_comment,
       quoted_host,
       quoted_port,
       quoted_login,
       quoted_password,
       slave);

  g_free (quoted_comment);
  g_free (quoted_name);
  g_free (quoted_host);
  g_free (quoted_port);
  g_free (quoted_login);
  g_free (quoted_password);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Delete a slave.
 *
 * @param[in]  slave_id  UUID of slave.
 * @param[in]  ultimate  Whether to remove entirely, or to trashcan.
 *
 * @return 0 success, 1 fail because a task refers to the slave, 2 failed to
 *         find agent, -1 error.
 */
int
delete_slave (const char *slave_id, int ultimate)
{
  slave_t slave = 0;

  sql ("BEGIN IMMEDIATE;");

  if (find_slave (slave_id, &slave))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (slave == 0)
    {
      if (find_trash ("slave", slave_id, &slave))
        {
          sql ("ROLLBACK;");
          return -1;
        }
      if (slave == 0)
        {
          sql ("ROLLBACK;");
          return 2;
        }
      if (ultimate == 0)
        {
          /* It's already in the trashcan. */
          sql ("COMMIT;");
          return 0;
        }

      /* Check if it's in use by a task in the trashcan. */
      if (sql_int (0, 0,
                   "SELECT count(*) FROM tasks"
                   " WHERE slave = %llu"
                   " AND slave_location = " G_STRINGIFY (LOCATION_TRASH) ";",
                   slave))
        {
          sql ("ROLLBACK;");
          return 1;
        }

      sql ("DELETE FROM slaves_trash WHERE ROWID = %llu;", slave);
      sql ("COMMIT;");
      return 0;
    }

  if (ultimate == 0)
    {
      if (sql_int (0, 0,
                   "SELECT count(*) FROM tasks"
                   " WHERE slave = %llu"
                   " AND slave_location = " G_STRINGIFY (LOCATION_TABLE)
                   " AND (hidden = 0 OR hidden = 1);",
                   slave))
        {
          sql ("ROLLBACK;");
          return 1;
        }

      sql ("INSERT INTO slaves_trash"
           "  (uuid, owner, name, comment, host, port, login, password,"
           "   creation_time, modification_time)"
           " SELECT"
           "  uuid, owner, name, comment, host, port, login, password,"
           "  creation_time, modification_time"
           " FROM slaves WHERE ROWID = %llu;",
           slave);

      /* Update the location of the slave in any trashcan tasks. */
      sql ("UPDATE tasks"
           " SET slave = %llu,"
           "     slave_location = " G_STRINGIFY (LOCATION_TRASH)
           " WHERE slave = %llu"
           " AND slave_location = " G_STRINGIFY (LOCATION_TABLE) ";",
           sqlite3_last_insert_rowid (task_db),
           slave);
    }
  else if (sql_int (0, 0,
           "SELECT count(*) FROM tasks"
           " WHERE slave = %llu"
           " AND slave_location = " G_STRINGIFY (LOCATION_TABLE),
           slave))
    {
      sql ("ROLLBACK;");
      return 1;
    }

  sql ("DELETE FROM slaves WHERE ROWID = %llu;", slave);
  sql ("COMMIT;");
  return 0;
}

/**
 * @brief Return whether a slave is writable.
 *
 * @param[in]  slave  Slave.
 *
 * @return 1 if writable, else 0.
 */
int
slave_writable (slave_t slave)
{
  return 1;
}

/**
 * @brief Return whether a trashcan slave is writable.
 *
 * @param[in]  slave  Slave.
 *
 * @return 1 if writable, else 0.
 */
int
trash_slave_writable (slave_t slave)
{
  return 1;
}

/**
 * @brief Filter columns for slave iterator.
 */
#define SLAVE_ITERATOR_FILTER_COLUMNS                                         \
 { GET_ITERATOR_FILTER_COLUMNS, "host", "port", "login", NULL }

/**
 * @brief Slave iterator columns.
 */
#define SLAVE_ITERATOR_COLUMNS                                                \
  GET_ITERATOR_COLUMNS ", host, port, login, password"

/**
 * @brief Slave iterator columns for trash case.
 */
#define SLAVE_ITERATOR_TRASH_COLUMNS                                          \
  GET_ITERATOR_COLUMNS ", host, port, login, password"

/**
 * @brief Count the number of slaves.
 *
 * @param[in]  get  GET params.
 *
 * @return Total number of slaves filtered set.
 */
int
slave_count (const get_data_t *get)
{
  static const char *extra_columns[] = SLAVE_ITERATOR_FILTER_COLUMNS;
  return count ("slave", get, SLAVE_ITERATOR_COLUMNS, extra_columns, 0, 0,
                0, TRUE);
}

/**
 * @brief Initialise a slave iterator.
 *
 * @param[in]  iterator    Iterator.
 * @param[in]  get         GET data.
 *
 * @return 0 success, 1 failed to find slave, failed to find filter,
 *         -1 error.
 */
int
init_slave_iterator (iterator_t* iterator, const get_data_t *get)
{
  static const char *filter_columns[] = SLAVE_ITERATOR_FILTER_COLUMNS;

  return init_get_iterator (iterator,
                            "slave",
                            get,
                            /* Columns. */
                            SLAVE_ITERATOR_COLUMNS,
                            /* Columns for trashcan. */
                            SLAVE_ITERATOR_TRASH_COLUMNS,
                            filter_columns,
                            "task",
                            0,
                            NULL,
                            NULL,
                            TRUE);
}

/**
 * @brief Get the slave from a slave iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Slave.
 */
slave_t
slave_iterator_slave (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (slave_t) sqlite3_column_int64 (iterator->stmt, 0);
}

/**
 * @brief Get the UUID of the slave from a slave iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return UUID of the slave or NULL if iteration is complete.
 */
DEF_ACCESS (slave_iterator_uuid, 1);

/**
 * @brief Get the name of the slave from a slave iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name of the slave or NULL if iteration is complete.
 */
DEF_ACCESS (slave_iterator_name, 2);

/**
 * @brief Get the comment from a slave iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Comment.
 */
const char*
slave_iterator_comment (iterator_t* iterator)
{
  const char *ret;
  if (iterator->done) return "";
  ret = (const char*) sqlite3_column_text (iterator->stmt, 3);
  return ret ? ret : "";
}

/**
 * @brief Get the host of the slave from a slave iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Host of the slave or NULL if iteration is complete.
 */
DEF_ACCESS (slave_iterator_host, GET_ITERATOR_COLUMN_COUNT);

/**
 * @brief Get the port of the slave from a slave iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Port of the slave or NULL if iteration is complete.
 */
DEF_ACCESS (slave_iterator_port, GET_ITERATOR_COLUMN_COUNT + 1);

/**
 * @brief Get the login of the slave from a slave iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Login of the slave or NULL if iteration is complete.
 */
DEF_ACCESS (slave_iterator_login, GET_ITERATOR_COLUMN_COUNT + 2);

/**
 * @brief Get the password of the slave from a slave iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Password of the slave or NULL if iteration is complete.
 */
DEF_ACCESS (slave_iterator_password, GET_ITERATOR_COLUMN_COUNT + 3);

/**
 * @brief Return the UUID of a slave.
 *
 * @param[in]  slave  Slave.
 *
 * @return Newly allocated UUID if available, else NULL.
 */
char*
slave_uuid (slave_t slave)
{
  return sql_string (0, 0,
                     "SELECT uuid FROM slaves WHERE ROWID = %llu;",
                     slave);
}

/**
 * @brief Return the UUID of a slave in the trashcan.
 *
 * @param[in]  slave  Slave.
 *
 * @return Newly allocated UUID if available, else NULL.
 */
char*
trash_slave_uuid (slave_t slave)
{
  return sql_string (0, 0,
                     "SELECT uuid FROM slaves_trash WHERE ROWID = %llu;",
                     slave);
}

/**
 * @brief Return the name of a slave.
 *
 * @param[in]  slave  Slave.
 *
 * @return Newly allocated name if available, else NULL.
 */
char*
slave_name (slave_t slave)
{
  return sql_string (0, 0,
                     "SELECT name FROM slaves WHERE ROWID = %llu;",
                     slave);
}

/**
 * @brief Return the name of a slave in the trashcan.
 *
 * @param[in]  slave  Slave.
 *
 * @return Newly allocated name if available, else NULL.
 */
char*
trash_slave_name (slave_t slave)
{
  return sql_string (0, 0,
                     "SELECT name FROM slaves_trash WHERE ROWID = %llu;",
                     slave);
}

/**
 * @brief Return the host associated with a slave.
 *
 * @param[in]  slave  Slave.
 *
 * @return Newly allocated host if available, else NULL.
 */
char*
slave_host (slave_t slave)
{
  return sql_string (0, 0,
                     "SELECT host FROM slaves WHERE ROWID = %llu;",
                     slave);
}

/**
 * @brief Return the login associated with a slave.
 *
 * @param[in]  slave  Slave.
 *
 * @return Newly allocated login if available, else NULL.
 */
char*
slave_login (slave_t slave)
{
  return sql_string (0, 0,
                     "SELECT login FROM slaves WHERE ROWID = %llu;",
                     slave);
}

/**
 * @brief Return the password associated with a slave.
 *
 * @param[in]  slave  Slave.
 *
 * @return Newly allocated password if available, else NULL.
 */
char*
slave_password (slave_t slave)
{
  return sql_string (0, 0,
                     "SELECT password FROM slaves WHERE ROWID = %llu;",
                     slave);
}

/**
 * @brief Return the port associated with a slave.
 *
 * @param[in]  slave  Slave.
 *
 * @return Port number on success; -1 on error.
 */
int
slave_port (slave_t slave)
{
  int ret;
  char *port = sql_string (0, 0,
                           "SELECT port FROM slaves WHERE ROWID = %llu;",
                           slave);
  if (port == NULL)
    return -1;
  ret = atoi (port);
  free (port);
  return ret;
}

/**
 * @brief Set the host associated with a slave.
 *
 * @param[in]  slave  Slave.
 * @param[in]  host   New value for host.
 */
void
set_slave_host (slave_t slave, const char *host)
{
  gchar* quoted_host;

  assert (host);

  quoted_host = sql_quote (host);
  sql ("UPDATE slaves SET host = '%s' WHERE ROWID = %llu;",
       quoted_host, slave);
  g_free (quoted_host);
}

/**
 * @brief Return whether a slave is referenced by a task
 *
 * @param[in]  slave  Slave.
 *
 * @return 1 if in use, else 0.
 */
int
slave_in_use (slave_t slave)
{
  return !!sql_int (0, 0,
                    "SELECT count(*) FROM tasks"
                    " WHERE slave = %llu AND hidden = 0;",
                    slave);
}

/**
 * @brief Return whether a slave is referenced by a task
 *
 * @param[in]  slave  Slave.
 *
 * @return 1 if in use, else 0.
 */
int
trash_slave_in_use (slave_t slave)
{
  return !!sql_int (0, 0,
                    "SELECT count(*) FROM tasks"
                    " WHERE slave = %llu"
                    " AND slave_location = " G_STRINGIFY (LOCATION_TRASH),
                    slave);
}

/**
 * @brief Initialise a slave task iterator.
 *
 * Iterates over all tasks that use the slave.
 *
 * @param[in]  iterator   Iterator.
 * @param[in]  slave      Slave.
 */
void
init_slave_task_iterator (iterator_t* iterator, slave_t slave)
{
  assert (current_credentials.uuid);

  init_iterator (iterator,
                 "SELECT ROWID, uuid, name FROM tasks"
                 " WHERE slave = %llu AND hidden = 0"
                 " AND ((owner IS NULL) OR (owner ="
                 " (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                 " ORDER BY name ASC;",
                 slave,
                 current_credentials.uuid);
}

/**
 * @brief Get the name from a slave task iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The name of the host, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (slave_task_iterator_name, 2);

/**
 * @brief Get the uuid from a slave task iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The uuid of the host, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (slave_task_iterator_uuid, 1);


/* Port lists. */

/**
 * @brief Find a port list given a UUID.
 *
 * @param[in]   uuid       UUID of port_list.
 * @param[out]  port_list  Port_List return, 0 if succesfully failed to find
 *                         port_list.
 *
 * @return FALSE on success (including if failed to find port_list), TRUE on error.
 */
gboolean
find_port_list (const char* uuid, port_list_t* port_list)
{
  gchar *quoted_uuid = sql_quote (uuid);
  if (user_owns_uuid ("port_list", quoted_uuid) == 0)
    {
      g_free (quoted_uuid);
      *port_list = 0;
      return FALSE;
    }
  switch (sql_int64 (port_list, 0, 0,
                     "SELECT ROWID FROM port_lists WHERE uuid = '%s';",
                     quoted_uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *port_list = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        g_free (quoted_uuid);
        return TRUE;
        break;
    }

  g_free (quoted_uuid);
  return FALSE;
}

/**
 * @brief Find a port range given a UUID.
 *
 * @param[in]   uuid        UUID of port_range.
 * @param[out]  port_range  Port range return, 0 if succesfully failed to find
 *                          port range.
 *
 * @return FALSE on success (including if failed to find port range), TRUE on
 *         error.
 */
gboolean
find_port_range (const char* uuid, port_range_t* port_range)
{
  gchar *quoted_uuid;

  assert (current_credentials.uuid);

  quoted_uuid = sql_quote (uuid);

  if (sql_int (0, 0,
               "SELECT count(*) FROM port_ranges, port_lists"
               " WHERE port_ranges.uuid = '%s'"
               " AND port_ranges.port_list = port_lists.ROWID"
               /* The owner of the port list owns the range. */
               " AND ((port_lists.owner IS NULL) OR (port_lists.owner ="
               " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
               quoted_uuid,
               current_credentials.uuid)
      == 0)
    {
      g_free (quoted_uuid);
      *port_range = 0;
      return FALSE;
    }
  switch (sql_int64 (port_range, 0, 0,
                     "SELECT ROWID FROM port_ranges WHERE uuid = '%s';",
                     quoted_uuid))
    {
      case 0:
        break;
      case 1:        /* Too few rows in result of query. */
        *port_range = 0;
        break;
      default:       /* Programming error. */
        assert (0);
      case -1:
        g_free (quoted_uuid);
        return TRUE;
        break;
    }

  g_free (quoted_uuid);
  return FALSE;
}

/**
 * @brief Compare two ranges by type then start.
 *
 * @param[in]  one  First range.
 * @param[in]  two  Second range.
 */
static int
range_compare (gconstpointer one, gconstpointer two)
{
  range_t *range_one, *range_two;

  range_one = *((range_t**) one);
  range_two = *((range_t**) two);

  if (range_one->type > range_two->type)
    return 1;

  if (range_one->type < range_two->type)
    return -1;

  if (range_one->start > range_two->start)
    return 1;

  if (range_one->start < range_two->start)
    return -1;

  return 0;
}

/**
 * @brief Sort and merge ranges.
 *
 * @param[in]  ranges  Array of port ranges of type range_t.
 */
static void
ranges_sort_merge (array_t *ranges)
{
  if (ranges->len > 1)
    {
      int index;
      range_t *last_range;

      /* Sort by type then start. */

      g_ptr_array_sort (ranges, range_compare);

      /* Merge overlaps. */

      last_range = (range_t*) g_ptr_array_index (ranges, 0);
      for (index = 1; index < ranges->len; )
        {
          range_t *range;

          range = (range_t*) g_ptr_array_index (ranges, index);
          if (range == NULL)
            break;

          if (range->type == last_range->type
              && range->start <= last_range->end)
            {
              if (range->end > last_range->end)
                last_range->end = range->end;
              /* This moves everything else up into the space. */
              g_ptr_array_remove_index (ranges, index);
            }
          else
            {
              index++;
              last_range = range;
            }
        }
    }
}

/**
 * @brief Create a port list, with database locked.
 *
 * Caller must lock the database.
 *
 * @param[in]   quoted_id       SQL quoted UUID, or NULL.
 * @param[in]   quoted_name     SQL quoted name of port list.
 * @param[in]   comment         Comment on port list.
 * @param[in]   ranges          Port ranges of port list.
 * @param[out]  port_list       Created port list.
 *
 * @return 0 success.
 */
int
create_port_list_lock (const char *quoted_id, const char *quoted_name,
                       const char *comment, array_t *ranges,
                       port_list_t* port_list)
{
  gchar *quoted_comment;
  range_t *range;
  int index;

  assert (comment);

  quoted_comment = sql_quote (comment);
  if (quoted_id)
    sql ("INSERT INTO port_lists"
         " (uuid, owner, name, comment, creation_time, modification_time)"
         " VALUES"
         " ('%s', (SELECT ROWID FROM users WHERE uuid = '%s'), '%s',"
         "  '%s', now (), now ());",
         quoted_id,
         current_credentials.uuid,
         quoted_name,
         quoted_comment);
  else
    sql ("INSERT INTO port_lists"
         " (uuid, owner, name, comment, creation_time, modification_time)"
         " VALUES"
         " (make_uuid (), (SELECT ROWID FROM users WHERE uuid = '%s'), '%s',"
         "  '%s', now (), now ());",
         current_credentials.uuid,
         quoted_name,
         quoted_comment);
  g_free (quoted_comment);

  *port_list = sqlite3_last_insert_rowid (task_db);

  ranges_sort_merge (ranges);
  array_terminate (ranges);
  index = 0;
  while ((range = (range_t*) g_ptr_array_index (ranges, index++)))
    sql ("INSERT INTO port_ranges"
         " (uuid, port_list, type, start, end, comment, exclude)"
         " VALUES"
         " (make_uuid (), %llu, %i, %i, %i, '', %i);",
         *port_list,
         range->type,
         range->start,
         range->end,
         range->exclude);
  return 0;
}

/**
 * @brief Create a range array from an OMP port range string.
 *
 * @param[out]  port_range  Valid OMP port range string.
 *
 * @return Range array.
 */
static array_t*
port_range_ranges (const char *port_range)
{
  gchar **split, **point, *range_start, *current;
  array_t *ranges;
  int tcp;

  ranges = make_array ();

  while (*port_range && isblank (*port_range)) port_range++;

  /* Scanner accepts only 1-6,9 or T:1-3,5,U:1-5,9.  Manager accepts T: and
   * U: before any of the ranges.  This toggles the remaining ranges, as in
   * nmap.  Manager treats a leading naked range as TCP, whereas nmap treats
   * it as TCP and UDP.  Manager sends to the Scanner in the format Scanner
   * accepts. */

  /* Treat newlines like commas. */
  range_start = current = g_strdup (port_range);
  while (*current)
    {
      if (*current == '\n') *current = ',';
      current++;
    }

  tcp = 1;
  split = g_strsplit (range_start, ",", 0);
  g_free (range_start);
  point = split;

  while (*point)
    {
      gchar *hyphen, *element;
      range_t *range;

      element = g_strstrip (*point);
      if (strlen (element) >= 2)
        {
          if ((element[0] == 'T') && (element[1] == ':'))
            {
              tcp = 1;
              element = element + 2;
            }
          else if ((element[0] == 'U') && (element[1] == ':'))
            {
              tcp = 0;
              element = element + 2;
            }
          /* Else tcp stays as it is. */
        }

      /* Skip any space that followed the type specifier. */
      while (*element && isblank (*element)) element++;

      hyphen = strchr (element, '-');
      if (hyphen)
        {
          *hyphen = '\0';
          hyphen++;
          while (*hyphen && isblank (*hyphen)) hyphen++;
          assert (*hyphen);  /* Validation checks this. */

          /* A range. */

          range = (range_t*) g_malloc0 (sizeof (range_t));

          range->start = atoi (element);
          range->end = atoi (hyphen);
          range->type = tcp ? PORT_PROTOCOL_TCP : PORT_PROTOCOL_UDP;
          range->exclude = 0;

          array_add (ranges, range);
        }
      else if (*element)
        {
          /* A single port. */

          range = (range_t*) g_malloc0 (sizeof (range_t));

          range->start = atoi (element);
          range->end = range->start;
          range->type = tcp ? PORT_PROTOCOL_TCP : PORT_PROTOCOL_UDP;
          range->exclude = 0;

          array_add (ranges, range);
        }
      /* Else skip over empty range. */
      point += 1;
    }
  g_strfreev (split);
  return ranges;
}

/**
 * @brief Create a port list having a unique name.
 *
 * Caller must provide transaction.
 *
 * @param[in]   name            Name of port list.
 * @param[in]   comment         Comment on port list.
 * @param[in]   port_range      Traditional OTP style port range.  NULL for "default".
 * @param[out]  port_list       Created port list.
 *
 * @return 0 success, 4 error in port range.
 */
int
create_port_list_unique (const char *name, const char *comment,
                         const char* port_range, port_list_t* port_list)
{
  gchar *quoted_name;
  array_t *ranges;
  int suffix, ret;

  assert (current_credentials.uuid);

  if (port_range == NULL || (strcmp (port_range, "default") == 0))
    {
      if (find_port_list (PORT_LIST_UUID_DEFAULT, port_list)
          || (*port_list == 0))
        return -1;
      return 0;
    }

  if (validate_port_range (port_range))
    return 4;

  ranges = port_range_ranges (port_range);

  /* Check whether a port list with the same name exists already. */
  suffix = 1;
  quoted_name = sql_quote (name);
  while (sql_int (0, 0,
                  "SELECT COUNT(*) FROM port_lists"
                  " WHERE name = '%s'"
                  " AND ((owner IS NULL) OR (owner ="
                  " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                  quoted_name,
                  current_credentials.uuid))
    {
      gchar *new_name;
      new_name = g_strdup_printf ("%s %i", name, suffix);
      g_free (quoted_name);
      quoted_name = sql_quote (new_name);
      g_free (new_name);
      suffix++;
    }

  ret = create_port_list_lock (NULL, quoted_name, comment, ranges, port_list);

  array_free (ranges);

  return ret;
}

/**
 * @brief Create a port_list.
 *
 * @param[in]   id                ID of port list.  Only used with \p ranges.
 * @param[in]   name              Name of port list.
 * @param[in]   comment           Comment on port list.
 * @param[in]   port_ranges       OMP port range string.
 * @param[in]   ranges            Array of port ranges of type range_t.
 *                                Overrides port_ranges.
 * @param[out]  port_list_return  Created port list.
 *
 * @return 0 success, 1 port list exists already, 4 error in port_ranges,
 *         -1 error.
 */
int
create_port_list (const char* id, const char* name, const char* comment,
                  const char* port_ranges, array_t *ranges,
                  port_list_t* port_list_return)
{
  gchar *quoted_name;
  port_list_t port_list;
  int ret;

  if (ranges)
    {
      int suffix;
      gchar *quoted_id;

      if (id == NULL)
        return -1;

      sql ("BEGIN IMMEDIATE;");

      assert (current_credentials.uuid);

      /* Check whether this port list exists already. */

      quoted_id = sql_quote (id);
      if (sql_int (0, 0,
                   "SELECT COUNT(*) FROM port_lists"
                   " WHERE uuid = '%s'"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                   quoted_id,
                   current_credentials.uuid))
        {
          g_free (quoted_id);
          sql ("ROLLBACK;");
          return 1;
        }

      if (sql_int (0, 0,
                   "SELECT COUNT(*) FROM port_lists_trash"
                   " WHERE uuid = '%s'"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                   quoted_id,
                   current_credentials.uuid))
        {
          g_free (quoted_id);
          sql ("ROLLBACK;");
          return 2;
        }

      /* Ensure the name is unique. */
      quoted_name = sql_quote (name);
      suffix = 1;
      while (sql_int (0, 0,
                      "SELECT COUNT(*) FROM port_lists"
                       " WHERE name = '%s'"
                       " AND ((owner IS NULL) OR (owner ="
                       " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                       quoted_name,
                       current_credentials.uuid))
        {
          gchar *new_name;
          g_free (quoted_name);
          new_name = g_strdup_printf ("%s %i", name, suffix++);
          quoted_name = sql_quote (new_name);
          g_free (new_name);
        }

      ret = create_port_list_lock (quoted_id, quoted_name,
                                   comment ? comment : "", ranges, &port_list);
      g_free (quoted_name);
      if (ret)
        {
          sql ("ROLLBACK;");
          return ret;
        }

      if (port_list_return)
        *port_list_return = port_list;

      sql ("COMMIT;");
      return 0;
    }

  quoted_name = sql_quote (name);

  if (port_ranges == NULL)
    port_ranges = "default";

  if (validate_port_range (port_ranges))
    {
      g_free (quoted_name);
      return 4;
    }

  sql ("BEGIN IMMEDIATE;");

  assert (current_credentials.uuid);

  /* Check whether a port_list with the same name exists already. */
  if (sql_int (0, 0,
               "SELECT COUNT(*) FROM port_lists"
               " WHERE name = '%s'"
               " AND ((owner IS NULL) OR (owner ="
               " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
               quoted_name,
               current_credentials.uuid))
    {
      g_free (quoted_name);
      sql ("ROLLBACK;");
      return 1;
    }

  if (port_ranges == NULL || (strcmp (port_ranges, "default") == 0))
    {
      gchar *quoted_comment, *quoted_name;

      quoted_name = sql_quote (name);
      quoted_comment = sql_quote (comment ? comment : "");
      sql ("INSERT INTO port_lists"
           " (uuid, owner, name, comment, creation_time, modification_time)"
           " VALUES"
           " (make_uuid (), (SELECT ROWID FROM users WHERE uuid = '%s'), '%s',"
           "  '%s', now (), now ());",
           current_credentials.uuid,
           quoted_name,
           quoted_comment);
      g_free (quoted_comment);
      g_free (quoted_name);

      port_list = sqlite3_last_insert_rowid (task_db);
      make_port_ranges_openvas_default (port_list);
    }
  else
    {
      ranges = port_range_ranges (port_ranges);
      ret = create_port_list_lock (NULL, quoted_name, comment ? comment : "",
                                   ranges, &port_list);
      array_free (ranges);
      if (ret)
        {
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return ret;
        }
    }

  if (port_list_return)
    *port_list_return = port_list;

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Create Port List from an existing Port List.
 *
 * @param[in]  name             Name of new Port List. NULL to copy from
 *                              existing.
 * @param[in]  comment          Comment on new Port List. NULL to copy from
 *                              existing.
 * @param[in]  port_list_id     UUID of existing Port List.
 * @param[out] new_port_list    New Port List.
 *
 * @return 0 success, 1 Port List exists already, 2 failed to find existing
 *         Port List, -1 error.
 */
int
copy_port_list (const char* name, const char* comment,
                const char* port_list_id, port_list_t* port_list)
{
  port_list_t new_port_list;
  gchar *quoted_name, *quoted_comment, *quoted_uuid, *uniquify;
  user_t owner;

  assert (current_credentials.uuid);

  if (port_list_id == NULL)
    return -1;

  sql ("BEGIN IMMEDIATE");

  if (find_user (current_credentials.username, &owner)
      || owner == 0)
    {
      sql ("ROLLBACK;");
      return -1;
    }

  /* Check that name doesn't exist already */
  if (name && strlen (name))
    {
      quoted_name = sql_quote (name);
      if (sql_int (0, 0,
                   "SELECT COUNT (*) from port_lists WHERE name = '%s'"
                   " AND ((owner IS NULL) OR (owner = %llu));",
                   quoted_name,
                   owner))
        {
          tracef ("  Port List \"%s\" exists already\n", name);
          sql ("ROLLBACK");
          g_free (quoted_name);
          return 1;
        }
    }
  else
    quoted_name = NULL;

  /* Check that Port List to copy exists */
  quoted_uuid = sql_quote (port_list_id);
  if (sql_int (0, 0,
               "SELECT COUNT (*) from port_lists WHERE uuid = '%s'"
               " AND ((owner IS NULL) OR (owner = %llu));",
               quoted_uuid,
               owner)
      == 0)
    {
      sql ("ROLLBACK");
      g_free (quoted_name);
      g_free (quoted_uuid);
      return 2;
    }

  /* Copy Port List */

  if (comment && strlen (comment) > 0)
    quoted_comment = sql_nquote (comment, strlen (comment));
  else
    quoted_comment = NULL;

  uniquify = g_strdup_printf ("uniquify ('port_list', name, %llu, ' Clone')",
                              owner);
  sql ("INSERT INTO port_lists (uuid, owner, name, comment,"
       " creation_time, modification_time) "
       " SELECT make_uuid (),%llu,"
       "  %s%s%s, %s%s%s, now (), now ()"
       "  FROM port_lists WHERE uuid = '%s';",
       owner,
       quoted_name ? "'" : "",
       quoted_name ? quoted_name : uniquify,
       quoted_name ? "'" : "",
       quoted_comment ? "'" : "",
       quoted_comment ? quoted_comment : "comment",
       quoted_comment ? "'" : "",
       quoted_uuid);

  new_port_list = sqlite3_last_insert_rowid (task_db);

  /* Copy Port Ranges */

  sql ("INSERT INTO port_ranges "
       " (uuid, port_list, type, start, end, comment, exclude)"
       " SELECT make_uuid(), %llu, type, start, end, comment, exclude"
       "  FROM port_ranges WHERE port_list = "
       "   (SELECT port_lists.ROWID FROM port_lists"
       "    WHERE port_lists.uuid = '%s');",
       new_port_list,
       port_list_id);

  sql ("COMMIT");
  g_free (quoted_name);
  g_free (quoted_comment);
  g_free (quoted_uuid);
  g_free (uniquify);
  if (port_list) *port_list = new_port_list;
  return 0;
}

/**
 * @brief Modify a Port List.
 *
 * @param[in]   port_list_id    UUID of Port List.
 * @param[in]   name            Name of Port List.
 * @param[in]   comment         Comment on Port List.
 *
 * @return 0 success, 1 failed to find port list, 2 port list with new name,
 *         exists, 3 port_list_id required, -1 internal error.
 */
int
modify_port_list (const char *port_list_id, const char *name,
                  const char *comment)
{
  gchar *quoted_name, *quoted_comment;
  port_list_t port_list;

  if (port_list_id == NULL)
    return 3;

  sql ("BEGIN IMMEDIATE;");

  assert (current_credentials.uuid);

  port_list = 0;
  if (find_port_list (port_list_id, &port_list))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (port_list == 0)
    {
      sql ("ROLLBACK;");
      return 1;
    }

  /* Check whether a Port List with the same name exists already. */
  if (name)
    {
      quoted_name = sql_quote (name);
      if (sql_int (0, 0,
                   "SELECT COUNT(*) FROM port_lists"
                   " WHERE name = '%s'"
                   " AND ROWID != %llu"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                   quoted_name,
                   port_list,
                   current_credentials.uuid))
        {
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return 2;
        }
    }
  else
    quoted_name = sql_quote("");

  quoted_comment = sql_quote (comment ? comment : "");

  sql ("UPDATE port_lists SET"
       " name = '%s',"
       " comment = '%s',"
       " modification_time = now ()"
       " WHERE ROWID = %llu;",
       quoted_name,
       quoted_comment,
       port_list);

  g_free (quoted_comment);
  g_free (quoted_name);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Create a port range in a port list.
 *
 * @param[in]   port_list_id      Port list UUID.
 * @param[in]   type              Type.
 * @param[in]   start             Start port.
 * @param[in]   end               End port.
 * @param[in]   comment           Comment.
 * @param[out]  port_range_return  Created port range.
 *
 * @return 0 success, 1 syntax error in start, 2 syntax error in end, 3 failed
 *         to find port list, 4 syntax error in type, 5 port list in use,
 *         6 new range overlaps an existing range, -1 error.
 */
int
create_port_range (const char *port_list_id, const char *type,
                   const char *start, const char *end, const char *comment,
                   port_range_t *port_range_return)
{
  int first, last;
  port_list_t port_list;
  port_protocol_t port_type;
  gchar *quoted_comment;

  first = atoi (start);
  if (first < 1 || first > 65535)
    return 1;

  last = atoi (end);
  if (last < 1 || last > 65535)
    return 2;

  if (strcasecmp (type, "TCP") == 0)
    port_type = PORT_PROTOCOL_TCP;
  else if (strcasecmp (type, "UDP") == 0)
    port_type = PORT_PROTOCOL_UDP;
  else
    return 4;

  if (last < first)
    {
      int tem;
      tem = first;
      first = last;
      last = tem;
    }

  sql ("BEGIN IMMEDIATE;");

  port_list = 0;

  if (find_port_list (port_list_id, &port_list))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (port_list == 0)
    {
      sql ("ROLLBACK;");
      return 3;
    }

  if (port_list_in_use (port_list))
    {
      sql ("ROLLBACK;");
      return 5;
    }

  if (sql_int (0, 0,
               "SELECT count (*) FROM port_ranges"
               " WHERE port_list = %llu"
               " AND type = %i"
               " AND ((start <= %i AND end >= %i)"
               "      OR (start <= %i AND end >= %i)"
               "      OR (start >= %i AND start <= %i)"
               "      OR (end >= %i AND end <= %i))",
               port_list,
               port_type,
               first,
               first,
               last,
               last,
               first,
               last,
               first,
               last))
    {
      sql ("ROLLBACK;");
      return 6;
    }

  quoted_comment = comment ? sql_quote (comment) : g_strdup ("");
  sql ("INSERT INTO port_ranges"
       " (uuid, port_list, type, start, end, comment, exclude)"
       " VALUES"
       " (make_uuid (), %llu, %i, %i, %i, '', 0);",
       port_list, port_type, first, last, quoted_comment);
  g_free (quoted_comment);

  if (port_range_return)
    *port_range_return = sqlite3_last_insert_rowid (task_db);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Delete a port list.
 *
 * @param[in]  port_list_id  UUID of port_list.
 * @param[in]  ultimate      Whether to remove entirely, or to trashcan.
 *
 * @return 0 success, 1 fail because a target refers to the port list, 2 failed
 *         to find port list, 3 predefined port list, -1 error.
 */
int
delete_port_list (const char *port_list_id, int ultimate)
{
  port_list_t port_list = 0;

  sql ("BEGIN IMMEDIATE;");

  if (find_port_list (port_list_id, &port_list))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (port_list
      && port_list_is_predefined (port_list))
    {
      sql ("ROLLBACK;");
      return 3;
    }

  if (port_list == 0)
    {
      if (find_trash ("port_list", port_list_id, &port_list))
        {
          sql ("ROLLBACK;");
          return -1;
        }
      if (port_list == 0)
        {
          sql ("ROLLBACK;");
          return 2;
        }
      if (ultimate == 0)
        {
          /* It's already in the trashcan. */
          sql ("COMMIT;");
          return 0;
        }

      /* Check if it's in use by a target in the trashcan. */
      if (sql_int (0, 0,
                   "SELECT count(*) FROM targets_trash"
                   " WHERE port_range = %llu"
                   " AND port_list_location"
                   " = " G_STRINGIFY (LOCATION_TRASH) ";",
                   port_list))
        {
          sql ("ROLLBACK;");
          return 1;
        }

      sql ("DELETE FROM port_lists_trash WHERE ROWID = %llu;", port_list);
      sql ("DELETE FROM port_ranges_trash WHERE port_list = %llu;", port_list);
      sql ("COMMIT;");
      return 0;
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM targets"
               " WHERE port_range = %llu;",
               port_list))
    {
      sql ("ROLLBACK;");
      return 1;
    }

  if (ultimate == 0)
    {
      port_list_t trash_port_list;

      sql ("INSERT INTO port_lists_trash"
           " (uuid, owner, name, comment, creation_time, modification_time)"
           " SELECT uuid, owner, name, comment, creation_time,"
           "        modification_time"
           " FROM port_lists WHERE ROWID = %llu;",
           port_list);

      trash_port_list = sqlite3_last_insert_rowid (task_db);

      sql ("INSERT INTO port_ranges_trash"
           " (uuid, port_list, type, start, end, comment, exclude)"
           " SELECT uuid, %llu, type, start, end, comment, exclude"
           " FROM port_ranges WHERE port_list = %llu;",
           trash_port_list,
           port_list);

      /* Update the location of the port_list in any trashcan targets. */
      sql ("UPDATE targets_trash"
           " SET port_range = %llu,"
           "     port_list_location = " G_STRINGIFY (LOCATION_TRASH)
           " WHERE port_range = %llu"
           " AND port_list_location = " G_STRINGIFY (LOCATION_TABLE) ";",
           trash_port_list,
           port_list);
    }

  sql ("DELETE FROM port_lists WHERE ROWID = %llu;", port_list);
  sql ("DELETE FROM port_ranges WHERE port_list = %llu;", port_list);

  sql ("COMMIT;");
  return 0;
}

/**
 * @brief Delete a port range.
 *
 * @param[in]  port_range_id  UUID of port_range.
 *
 * @return 0 success, 1 failed to find port range, 2 port range is part of
 *         predefined port list, -1 error.
 */
int
delete_port_range (const char *port_range_id)
{
  port_range_t port_range = 0;

  sql ("BEGIN IMMEDIATE;");

  if (find_port_range (port_range_id, &port_range))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (port_range == 0)
    {
      sql ("ROLLBACK;");
      return 1;
    }

  if (sql_int
       (0, 0,
        "SELECT count (*) FROM port_lists WHERE"
        " ROWID = (SELECT port_list FROM port_ranges"
        "          WHERE port_ranges.ROWID = %llu)"
        " AND"
        " (uuid == " G_STRINGIFY (PORT_LIST_UUID_DEFAULT)
        "  OR uuid == " G_STRINGIFY (PORT_LIST_UUID_ALL_TCP_NMAP_5_51_TOP_100)
        "  OR uuid == " G_STRINGIFY (PORT_LIST_UUID_ALL_TCP_NMAP_5_51_TOP_1000)
        "  OR uuid == " G_STRINGIFY (PORT_LIST_UUID_ALL_PRIV_TCP)
        "  OR uuid == " G_STRINGIFY (PORT_LIST_UUID_ALL_PRIV_TCP_UDP)
        "  OR uuid == " G_STRINGIFY (PORT_LIST_UUID_ALL_IANA_TCP_2012)
        "  OR uuid == " G_STRINGIFY (PORT_LIST_UUID_ALL_IANA_TCP_UDP_2012)
        "  OR uuid"
        "     == " G_STRINGIFY (PORT_LIST_UUID_NMAP_5_51_TOP_2000_TOP_100) ");",
        port_range))
    return 2;

  sql ("DELETE FROM port_ranges WHERE ROWID = %llu;", port_range);

  sql ("COMMIT;");
  return 0;
}

/**
 * @brief Filter columns for Port List iterator.
 */
#define PORT_LIST_ITERATOR_FILTER_COLUMNS                                     \
 { GET_ITERATOR_FILTER_COLUMNS,  "total", "tcp", "udp", NULL }

/**
 * @brief Port List iterator columns.
 */
#define PORT_LIST_ITERATOR_COLUMNS GET_ITERATOR_COLUMNS                         \
    /* COUNT ALL ports */                                                       \
  ", (SELECT"                                                                   \
  "   sum ((CASE"                                                               \
  "         WHEN end IS NULL THEN start ELSE end"                               \
  "         END)"                                                               \
  "        - start"                                                             \
  "        + 1)"                                                                \
  "   FROM port_ranges WHERE port_list = port_lists.ROWID)"                     \
  "  AS total"                                                                  \
    /* COUNT TCP ports */                                                       \
  ", (SELECT"                                                                   \
  "   sum ((CASE"                                                               \
  "         WHEN end IS NULL THEN start ELSE end"                               \
  "         END)"                                                               \
  "        - start"                                                             \
  "        + 1)"                                                                \
  "   FROM port_ranges WHERE port_list = port_lists.ROWID"                      \
  "                    AND   type = 0 )"                                        \
  "  AS tcp"                                                                    \
    /* COUNT UDP ports */                                                       \
  ", (SELECT"                                                                   \
  "   sum ((CASE"                                                               \
  "         WHEN end IS NULL THEN start ELSE end"                               \
  "         END)"                                                               \
  "        - start"                                                             \
  "        + 1)"                                                                \
  "   FROM port_ranges WHERE port_list = port_lists.ROWID"                      \
  "                    AND   type = 1)"                                         \
  "  AS udp"

/**
 * @brief Port List iterator columns for trash case.
 */
#define PORT_LIST_ITERATOR_TRASH_COLUMNS GET_ITERATOR_COLUMNS                   \
    /* COUNT ALL ports */                                                       \
  ", (SELECT"                                                                   \
  "   sum ((CASE"                                                               \
  "         WHEN end IS NULL THEN start ELSE end"                               \
  "         END)"                                                               \
  "        - start"                                                             \
  "        + 1)"                                                                \
  "   FROM port_ranges WHERE port_list = port_lists_trash.ROWID)"               \
  "  AS total"                                                                  \
    /* COUNT TCP ports */                                                       \
  ", (SELECT"                                                                   \
  "   sum ((CASE"                                                               \
  "         WHEN end IS NULL THEN start ELSE end"                               \
  "         END)"                                                               \
  "        - start"                                                             \
  "        + 1)"                                                                \
  "   FROM port_ranges WHERE port_list = port_lists_trash.ROWID"                \
  "                    AND   type = 0 )"                                        \
  "  AS tcp"                                                                    \
    /* COUNT UDP ports */                                                       \
  ", (SELECT"                                                                   \
  "   sum ((CASE"                                                               \
  "         WHEN end IS NULL THEN start ELSE end"                               \
  "         END)"                                                               \
  "        - start"                                                             \
  "        + 1)"                                                                \
  "   FROM port_ranges WHERE port_list = port_lists_trash.ROWID"                \
  "                    AND   type = 1)"                                         \
  "  AS udp"

/**
 * @brief Count the number of Port Lists.
 *
 * @param[in]  get  GET params.
 *
 * @return Total number of Port Lists filtered set.
 */
int
port_list_count (const get_data_t *get)
{
  static const char *extra_columns[] = PORT_LIST_ITERATOR_FILTER_COLUMNS;
  return count ("port_list", get, PORT_LIST_ITERATOR_COLUMNS,
                extra_columns, 0, 0, 0, TRUE);
}

/**
 * @brief Initialise a Port List  iterator, including observed Port Lists.
 *
 * @param[in]  iterator    Iterator.
 * @param[in]  get         GET data.
 *
 * @return 0 success, 1 failed to find Port List, 2 failed to find filter,
 *         -1 error.
 */
int
init_port_list_iterator (iterator_t* iterator, const get_data_t *get)
{
  static const char *filter_columns[] = PORT_LIST_ITERATOR_FILTER_COLUMNS;

  return init_get_iterator (iterator,
                            "port_list",
                            get,
                            /* Columns. */
                            PORT_LIST_ITERATOR_COLUMNS,
                            /* Columns for trashcan. */
                            PORT_LIST_ITERATOR_TRASH_COLUMNS,
                            filter_columns,
                            NULL,
                            0,
                            NULL,
                            NULL,
                            TRUE);
}

/**
 * @brief Get the port_list from a port_list iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Port_List.
 */
port_list_t
port_list_iterator_port_list (iterator_t* iterator)
{
  if (iterator->done) return 0;
  return (port_list_t) sqlite3_column_int64 (iterator->stmt, 0);
}

/**
 * @brief Get the UUID of the port_list from a port_list iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return UUID of the port_list or NULL if iteration is complete.
 */
DEF_ACCESS (port_list_iterator_uuid, 1);

/**
 * @brief Get the name of the port_list from a port_list iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Name of the port_list or NULL if iteration is complete.
 */
DEF_ACCESS (port_list_iterator_name, 2);

/**
 * @brief Get the comment from a port_list iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Comment.
 */
const char*
port_list_iterator_comment (iterator_t* iterator)
{
  const char *ret;
  if (iterator->done) return "";
  ret = (const char*) sqlite3_column_text (iterator->stmt, 3);
  return ret ? ret : "";
}

/**
 * @brief Get the port count from a port_list iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return Port count.
 */
int
port_list_iterator_count_all (iterator_t* iterator)
{
  if (iterator->done) return -1;
  return sqlite3_column_int (iterator->stmt,
                             GET_ITERATOR_COLUMN_COUNT);
}

/**
 * @brief Get the TCP port count from a port_list iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return TCP port count.
 */
int
port_list_iterator_count_tcp (iterator_t* iterator)
{
  if (iterator->done) return -1;
  return sqlite3_column_int (iterator->stmt,
                             GET_ITERATOR_COLUMN_COUNT + 1);
}

/**
 * @brief Get the UDP port count from a port_list iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return UDP port count.
 */
int
port_list_iterator_count_udp (iterator_t* iterator)
{
  if (iterator->done) return -1;
  return sqlite3_column_int (iterator->stmt,
                             GET_ITERATOR_COLUMN_COUNT + 2);
}

/**
 * @brief Return the UUID of a port_list.
 *
 * @param[in]  port_list  Port_List.
 *
 * @return Newly allocated UUID if available, else NULL.
 */
char*
port_list_uuid (port_list_t port_list)
{
  return sql_string (0, 0,
                     "SELECT uuid FROM port_lists WHERE ROWID = %llu;",
                     port_list);
}

/**
 * @brief Return the UUID of a port_range.
 *
 * @param[in]  port_range  Port_Range.
 *
 * @return Newly allocated UUID if available, else NULL.
 */
char*
port_range_uuid (port_range_t port_range)
{
  return sql_string (0, 0,
                     "SELECT uuid FROM port_ranges WHERE ROWID = %llu;",
                     port_range);
}

int
port_list_is_predefined (port_list_t port_list)
{
  return !!sql_int
            (0, 0,
             "SELECT COUNT (*) FROM port_lists"
             " WHERE ROWID = %llu AND"
             " (uuid = " G_STRINGIFY (PORT_LIST_UUID_DEFAULT)
             "  OR uuid = " G_STRINGIFY (PORT_LIST_UUID_ALL_TCP)
             "  OR uuid = "
             G_STRINGIFY (PORT_LIST_UUID_ALL_TCP_NMAP_5_51_TOP_100)
             "  OR uuid = "
             G_STRINGIFY (PORT_LIST_UUID_ALL_TCP_NMAP_5_51_TOP_1000)
             "  OR uuid = " G_STRINGIFY (PORT_LIST_UUID_ALL_PRIV_TCP)
             "  OR uuid = " G_STRINGIFY (PORT_LIST_UUID_ALL_PRIV_TCP_UDP)
             "  OR uuid = " G_STRINGIFY (PORT_LIST_UUID_ALL_IANA_TCP_2012)
             "  OR uuid = "
             G_STRINGIFY (PORT_LIST_UUID_NMAP_5_51_TOP_2000_TOP_100)
             "  OR uuid = "
             G_STRINGIFY (PORT_LIST_UUID_ALL_IANA_TCP_UDP_2012) ");",
             port_list);
}

/**
 * @brief Return whether a port_list is in use by a task.
 *
 * @param[in]  port_list  Port_List.
 *
 * @return 1 if in use, else 0.
 */
int
port_list_in_use (port_list_t port_list)
{
  if (port_list_is_predefined (port_list))
    return 1;

  return sql_int (0, 0,
                  "SELECT count(*) FROM targets"
                  " WHERE port_range = %llu",
                  port_list);
}

/**
 * @brief Check whether a trashcan Port List is in use.
 *
 * @param[in]  port_list Port List.
 *
 * @return 1 yes, 0 no.
 */
int
trash_port_list_in_use (port_list_t port_list)
{
  return (sql_int (0, 0,
                   "SELECT count (*) FROM targets_trash"
                   " WHERE port_range = %llu"
                   " AND port_list_location = "
                   G_STRINGIFY (LOCATION_TRASH) ";",
                   port_list) > 0);
}

/**
 * @brief Check whether a Port List is writable.
 *
 * @param[in]  port_list  Port List.
 *
 * @return 1 yes, 0 no.
 */
int
port_list_writable (port_list_t port_list)
{
  if (port_list_is_predefined (port_list))
    return 0;
  return (port_list_in_use (port_list) == 0);
}

/**
 * @brief Check whether a trashcan Port List is writable.
 *
 * @param[in]  port_list  Port List.
 *
 * @return 1 yes, 0 no.
 */
int
trash_port_list_writable (port_list_t port_list)
{
  return (trash_port_list_in_use (port_list) == 0);
}

/**
 * @brief Initialise a port_range iterator.
 *
 * @param[in]  iterator    Iterator.
 * @param[in]  port_list   Port list.
 * @param[in]  trash       Whether port_list is in the trashcan.
 * @param[in]  ascending   Whether to sort ascending or descending.
 * @param[in]  sort_field  Field to sort on, or NULL for type then start.
 */
void
init_port_range_iterator (iterator_t* iterator, port_list_t port_list,
                          int trash, int ascending, const char* sort_field)
{
  assert (current_credentials.uuid);

  if (port_list)
    init_iterator (iterator,
                   "SELECT uuid, comment, start, end, type, exclude"
                   " FROM port_ranges%s"
                   " WHERE port_list = %llu"
                   " AND"
                   " (((SELECT owner FROM port_lists WHERE ROWID = port_list)"
                   "   IS NULL)"
                   "  OR ((SELECT owner FROM port_lists WHERE ROWID = port_list)"
                   "      = (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                   " ORDER BY %s %s;",
                   trash ? "_trash" : "",
                   port_list,
                   current_credentials.uuid,
                   sort_field ? sort_field : "type, CAST (start AS INTEGER)",
                   ascending ? "ASC" : "DESC");
  else
    init_iterator (iterator,
                   "SELECT uuid, comment, start, end, type, exclude"
                   " FROM port_ranges%s"
                   " WHERE"
                   " (((SELECT owner FROM port_lists WHERE ROWID = port_list)"
                   "   IS NULL)"
                   "  OR ((SELECT owner FROM port_lists WHERE ROWID = port_list)"
                   "      = (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                   " ORDER BY %s %s;",
                   trash ? "_trash" : "",
                   current_credentials.uuid,
                   sort_field ? sort_field : "type, CAST (start AS INTEGER)",
                   ascending ? "ASC" : "DESC");
}

/**
 * @brief Get the UUID from a port range iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The UUID of the range, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (port_range_iterator_uuid, 0);

/**
 * @brief Get the comment from a port range iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The comment of the range, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
const char*
port_range_iterator_comment (iterator_t* iterator)
{
  const char *ret;
  if (iterator->done) return "";
  ret = (const char*) sqlite3_column_text (iterator->stmt, 1);
  return ret ? ret : "";
}

/**
 * @brief Get the comment from a port range iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The comment of the range, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (port_range_iterator_start, 2);

/**
 * @brief Get the comment from a port range iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The comment of the range, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (port_range_iterator_end, 3);

/**
 * @brief Get the type from a port range iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The type of the range, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
const char*
port_range_iterator_type (iterator_t* iterator)
{
  if (iterator->done) return "";
  switch ((port_protocol_t) sqlite3_column_int (iterator->stmt, 4))
    {
      case PORT_PROTOCOL_TCP:
        return "tcp";
      case PORT_PROTOCOL_UDP:
        return "udp";
      default:
        return "";
    }
}

/**
 * @brief Get the type from a port range iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The type of the range, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
port_protocol_t
port_range_iterator_type_int (iterator_t* iterator)
{
  if (iterator->done) return PORT_PROTOCOL_OTHER;
  return (port_protocol_t) sqlite3_column_int (iterator->stmt, 4);
}

/**
 * @brief Get the exclude flag from a port range iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The exclude flag of the range, or NULL if iteration is complete.
 *         Freed by cleanup_iterator.
 */
int
port_range_iterator_exclude (iterator_t* iterator)
{
  int ret;
  if (iterator->done) return -1;
  ret = (int) sqlite3_column_int (iterator->stmt, 5);
  return ret;
}

/**
 * @brief Initialise a port_range iterator.
 *
 * @param[in]  iterator    Iterator.
 * @param[in]  port_list   Port list.
 * @param[in]  ascending   Whether to sort ascending or descending.
 */
void
init_port_list_target_iterator (iterator_t* iterator, port_list_t port_list,
                                int ascending)
{
  assert (current_credentials.uuid);

  if (port_list)
    init_iterator (iterator,
                   "SELECT uuid, name FROM targets"
                   " WHERE port_range = %llu"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                   " ORDER BY name %s;",
                   port_list,
                   current_credentials.uuid,
                   ascending ? "ASC" : "DESC");
  else
    init_iterator (iterator,
                   "SELECT uuid, name FROM targets"
                   " WHERE ((owner IS NULL) OR (owner ="
                   " (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                   " ORDER BY name %s;",
                   current_credentials.uuid,
                   ascending ? "ASC" : "DESC");
}

/**
 * @brief Get the UUID from a port list target iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The UUID of the target, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (port_list_target_iterator_uuid, 0);

/**
 * @brief Get the name from a port list target iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The name of the target, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (port_list_target_iterator_name, 1);


/* Filters. */

/**
 * @brief Find a filter given a UUID.
 *
 * @param[in]   uuid    UUID of filter.
 * @param[out]  filter  Filter return, 0 if succesfully failed to find filter.
 *
 * @return FALSE on success (including if failed to find filter), TRUE on error.
 */
gboolean
find_filter (const char* uuid, filter_t* filter)
{
  return find_resource ("filter", uuid, filter);
}

/**
 * @brief Find a filter for a set of actions, given a UUID.
 *
 * @param[in]   uuid     UUID of filter.
 * @param[out]  filter   Filter return, 0 if succesfully failed to find filter.
 * @param[in]   actions  Actions.
 *
 * @return FALSE on success (including if failed to find filter), TRUE on error.
 */
gboolean
find_filter_for_actions (const char* uuid, filter_t* filter,
                         const char *actions)
{
  return find_resource_for_actions ("filter", uuid, filter, actions);
}

/**
 * @brief Return the UUID of a filter.
 *
 * @param[in]  filter  Filter.
 *
 * @return Newly allocated UUID if available, else NULL.
 */
char*
filter_uuid (filter_t filter)
{
  return sql_string (0, 0,
                     "SELECT uuid FROM filters WHERE ROWID = %llu;",
                     filter);
}

/**
 * @brief Return the UUID of a trashcan filter.
 *
 * @param[in]  filter  Filter.
 *
 * @return Newly allocated UUID if available, else NULL.
 */
char*
trash_filter_uuid (filter_t filter)
{
  return sql_string (0, 0,
                     "SELECT uuid FROM filters_trash WHERE ROWID = %llu;",
                     filter);
}

/**
 * @brief Return the name of a filter.
 *
 * @param[in]  filter  Filter.
 *
 * @return name of filter.
 */
char*
filter_name (filter_t filter)
{
  return sql_string (0, 0,
                     "SELECT name FROM filters WHERE ROWID = %llu;",
                     filter);
}

/**
 * @brief Return the name of a trashcan filter.
 *
 * @param[in]  filter  Filter.
 *
 * @return name of filter.
 */
char*
trash_filter_name (filter_t filter)
{
  return sql_string (0, 0,
                     "SELECT name FROM filters_trash WHERE ROWID = %llu;",
                     filter);
}

/**
 * @brief Return the term of a filter.
 *
 * @param[in]  uuid  Filter UUID.
 *
 * @return Newly allocated term if available, else NULL.
 */
gchar*
filter_term (const char *uuid)
{
  gchar *quoted_uuid, *ret;
  quoted_uuid = sql_quote (uuid);
  ret = sql_string (0, 0,
                    "SELECT term FROM filters WHERE uuid = '%s';",
                    quoted_uuid);
  g_free (quoted_uuid);
  return ret;
}

/**
 * @brief Return the value of a column keyword of a filter term.
 *
 * @param[in]  term    Filter term.
 * @param[in]  column  Column name.
 *
 * @return Value of column keyword if one exists, else NULL.
 */
gchar*
filter_term_value (const char *term, const char *column)
{
  keyword_t **point;
  array_t *split;

  if (term == NULL)
    return NULL;

  split = split_filter (term);
  point = (keyword_t**) split->pdata;
  while (*point)
    {
      keyword_t *keyword;

      keyword = *point;
      if (keyword->column && (strcasecmp (keyword->column, column) == 0))
        {
          gchar *ret = g_strdup (keyword->string);
          filter_free (split);
          return ret;
        }
      point++;
    }
  filter_free (split);
  return NULL;
}

/**
 * @brief Create a filter.
 *
 * @param[in]   name            Name of filter.
 * @param[in]   comment         Comment on filter.
 * @param[in]   type            Type of resource.
 * @param[in]   term            Filter term.
 * @param[in]   make_name_unique  Whether to make name unique.
 * @param[out]  filter          Created filter.
 *
 * @return 0 success, 1 filter exists already, 2 error in type.
 */
int
create_filter (const char *name, const char *comment, const char *type,
               const char *term, int make_name_unique, filter_t* filter)
{
  gchar *quoted_name, *quoted_comment, *quoted_term;

  assert (current_credentials.uuid);

  type = type_db_name (type);
  if (type && !((strcmp (type, "") == 0) || valid_type (type)))
    return 2;

  sql ("BEGIN IMMEDIATE;");

  if (make_name_unique)
    {
      int suffix;
      /* Ensure the name is unique. */
      quoted_name = sql_quote (name);
      suffix = 1;
      while (sql_int (0, 0,
                      "SELECT COUNT(*) FROM filters"
                       " WHERE name = '%s'"
                       " AND ((owner IS NULL) OR (owner ="
                       " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                       quoted_name,
                       current_credentials.uuid))
        {
          gchar *new_name;
          g_free (quoted_name);
          new_name = g_strdup_printf ("%s %i", name, suffix++);
          quoted_name = sql_quote (new_name);
          g_free (new_name);
        }
    }
  else
    {
      /* Check whether a filter with the same name exists already. */
      quoted_name = sql_quote (name);
      if (sql_int (0, 0,
                   "SELECT COUNT(*) FROM filters"
                   " WHERE name = '%s'"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                   quoted_name,
                   current_credentials.uuid))
        {
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return 1;
        }
    }

  quoted_term = sql_quote (term ? term : "");

  if (comment)
    {
      quoted_comment = sql_quote (comment);
      sql ("INSERT INTO filters"
           " (uuid, name, owner, comment, type, term, creation_time,"
           "  modification_time)"
           " VALUES (make_uuid (), '%s',"
           " (SELECT ROWID FROM users WHERE users.uuid = '%s'),"
           " '%s', %s%s%s, '%s', now (), now ());",
           quoted_name,
           current_credentials.uuid,
           quoted_comment,
           type ? "lower ('" : "",
           type ? type : "''",
           type ? "')" : "",
           quoted_term);
      g_free (quoted_comment);
    }
  else
    sql ("INSERT INTO filters"
         " (uuid, name, owner, comment, type, term, creation_time,"
         "  modification_time)"
         " VALUES (make_uuid (), '%s',"
         " (SELECT ROWID FROM users WHERE users.uuid = '%s'),"
         " '', %s%s%s, '%s', now (), now ());",
         quoted_name,
         current_credentials.uuid,
         type ? "lower ('" : "",
         type ? type : "''",
         type ? "')" : "",
         quoted_term);

  if (filter)
    *filter = sqlite3_last_insert_rowid (task_db);

  g_free (quoted_name);
  g_free (quoted_term);

  sql ("COMMIT;");

  return 0;
}

/**
 * @brief Create a filter from an existing filter.
 *
 * @param[in]  name        Name of new filter.  NULL to copy from existing.
 * @param[in]  comment     Comment on new filter.  NULL to copy from existing.
 * @param[in]  filter_id   UUID of existing filter.
 * @param[out] new_filter  New filter.
 *
 * @return 0 success, 1 filter exists already, 2 failed to find existing
 *         filter, -1 error.
 */
int
copy_filter (const char* name, const char* comment, const char *filter_id,
             filter_t* new_filter)
{
  return copy_resource ("filter", name, comment, filter_id, "term, type",
                        new_filter);
}

/**
 * @brief Delete a filter.
 *
 * @param[in]  filter_id  UUID of filter.
 * @param[in]  ultimate   Whether to remove entirely, or to trashcan.
 *
 * @return 0 success, 1 fail because a task refers to the filter, 2 failed
 *         to find filter, 3 predefined filter, -1 error.
 */
int
delete_filter (const char *filter_id, int ultimate)
{
  filter_t filter = 0;

  sql ("BEGIN IMMEDIATE;");

  if (find_filter (filter_id, &filter))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (filter == 0)
    {
      if (find_trash ("filter", filter_id, &filter))
        {
          sql ("ROLLBACK;");
          return -1;
        }
      if (filter == 0)
        {
          sql ("ROLLBACK;");
          return 2;
        }
      if (ultimate == 0)
        {
          /* It's already in the trashcan. */
          sql ("COMMIT;");
          return 0;
        }

      /* Check if it's in use by an alert in the trashcan. */
      if (sql_int (0, 0,
                   "SELECT count(*) FROM alerts_trash"
                   " WHERE filter = %llu"
                   " AND filter_location = " G_STRINGIFY (LOCATION_TRASH) ";",
                   filter))
        {
          sql ("ROLLBACK;");
          return 1;
        }

      sql ("DELETE FROM filters_trash WHERE ROWID = %llu;", filter);
      sql ("COMMIT;");
      return 0;
    }

  if (sql_int (0, 0,
               "SELECT count(*) FROM alerts"
               " WHERE filter = %llu;",
               filter))
    {
      sql ("ROLLBACK;");
      return 1;
    }

  if (ultimate == 0)
    {
      sql ("INSERT INTO filters_trash"
           " (uuid, owner, name, comment, type, term, creation_time,"
           "  modification_time)"
           " SELECT uuid, owner, name, comment, type, term, creation_time,"
           "  modification_time"
           " FROM filters WHERE ROWID = %llu;",
           filter);

      /* Update the location of the filter in any trashcan alerts. */
      sql ("UPDATE alerts_trash"
           " SET filter = %llu,"
           "     filter_location = " G_STRINGIFY (LOCATION_TRASH)
           " WHERE filter = %llu"
           " AND filter_location = " G_STRINGIFY (LOCATION_TABLE) ";",
           sqlite3_last_insert_rowid (task_db),
           filter);
    }

  sql ("DELETE FROM filters WHERE ROWID = %llu;", filter);

  sql ("COMMIT;");
  return 0;
}

/**
 * @brief Check whether a filter is in use.
 *
 * @param[in]  filter  Filter.
 *
 * @return 1 yes, 0 no.
 */
int
filter_in_use (filter_t filter)
{
  return !!sql_int (0, 0,
                    "SELECT count (*) FROM alerts WHERE filter = %llu;",
                    filter);
}

/**
 * @brief Check whether a trashcan filter is in use.
 *
 * @param[in]  filter  Filter.
 *
 * @return 1 yes, 0 no.
 */
int
trash_filter_in_use (filter_t filter)
{
  return !!sql_int (0, 0,
                    "SELECT count (*) FROM alerts_trash"
                    " WHERE filter = %llu"
                    " AND filter_location = " G_STRINGIFY (LOCATION_TRASH) ";",
                    filter);
}

/**
 * @brief Check whether a filter is writable.
 *
 * @param[in]  filter  Filter.
 *
 * @return 1 yes, 0 no.
 */
int
filter_writable (filter_t filter)
{
  return 1;
}

/**
 * @brief Check whether a trashcan filter is writable.
 *
 * @param[in]  filter  Filter.
 *
 * @return 1 yes, 0 no.
 */
int
trash_filter_writable (filter_t filter)
{
  return 1;
}

/**
 * @brief Filter columns for filter iterator.
 */
#define FILTER_ITERATOR_FILTER_COLUMNS                        \
 { GET_ITERATOR_FILTER_COLUMNS, "type", "term", NULL }

/**
 * @brief Filter iterator columns.
 */
#define FILTER_ITERATOR_COLUMNS                               \
  GET_ITERATOR_COLUMNS ", type, term"

/**
 * @brief Filter iterator columns for trash case.
 */
#define FILTER_ITERATOR_TRASH_COLUMNS                         \
  GET_ITERATOR_COLUMNS ", type, term"

/**
 * @brief Count number of filters.
 *
 * @param[in]  get  GET params.
 *
 * @return Total number of filters in filtered set.
 */
int
filter_count (const get_data_t *get)
{
  static const char *extra_columns[] = FILTER_ITERATOR_FILTER_COLUMNS;
  return count ("filter", get, FILTER_ITERATOR_COLUMNS, extra_columns, 0, 0, 0,
                TRUE);
}

/**
 * @brief Initialise a filter iterator, including observed filters.
 *
 * @param[in]  iterator    Iterator.
 * @param[in]  get         GET data.
 *
 * @return 0 success, 1 failed to find filter, failed to find filter (filt_id),
 *         -1 error.
 */
int
init_filter_iterator (iterator_t* iterator, const get_data_t *get)
{
  static const char *filter_columns[] = FILTER_ITERATOR_FILTER_COLUMNS;

  return init_get_iterator (iterator,
                            "filter",
                            get,
                            /* Columns. */
                            FILTER_ITERATOR_COLUMNS,
                            /* Columns for trashcan. */
                            FILTER_ITERATOR_TRASH_COLUMNS,
                            filter_columns,
                            NULL,
                            0,
                            NULL,
                            NULL,
                            TRUE);
}

/**
 * @brief Get the type from a filter iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The type of the filter, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.  "" for any type.
 */
const char*
filter_iterator_type (iterator_t* iterator)
{
  const char *ret;
  if (iterator->done) return NULL;
  ret = (const char*) sqlite3_column_text (iterator->stmt,
                                           GET_ITERATOR_COLUMN_COUNT);
  return ret ? type_pretty_name (ret) : "";
}

/**
 * @brief Get the term from a filter iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The term of the filter, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (filter_iterator_term, GET_ITERATOR_COLUMN_COUNT + 1);

/**
 * @brief Initialise a filter alert iterator.
 *
 * Iterates over all alerts that use the filter.
 *
 * @param[in]  iterator   Iterator.
 * @param[in]  filter     Filter.
 */
void
init_filter_alert_iterator (iterator_t* iterator, filter_t filter)
{
  assert (current_credentials.uuid);

  init_iterator (iterator,
                 "SELECT name, uuid FROM alerts"
                 " WHERE filter = %llu"
                 " AND ((owner IS NULL) OR (owner ="
                 " (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                 " ORDER BY name ASC;",
                 filter,
                 current_credentials.uuid);
}

/**
 * @brief Get the name from a filter_alert iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The name of the host, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (filter_alert_iterator_name, 0);

/**
 * @brief Get the UUID from a filter_alert iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The UUID of the host, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (filter_alert_iterator_uuid, 1);

/**
 * @brief Modify a filter.
 *
 * @param[in]   filter_id       UUID of filter.
 * @param[in]   name            Name of filter.
 * @param[in]   comment         Comment on filter.
 * @param[in]   term            Filter term.
 * @param[in]   type            Type of filter.
 *
 * @return 0 success, 1 failed to find filter, 2 filter with new name exists,
 *         3 error in type name, 4 filter_id required, 5 filter is in use so
 *         type must be "report" if specified, -1 internal error.
 */
int
modify_filter (const char *filter_id, const char *name, const char *comment,
               const char *term, const char *type)
{
  gchar *quoted_name, *quoted_comment, *quoted_term, *quoted_type;
  filter_t filter;

  if (filter_id == NULL)
    return 4;

  type = type_db_name (type);
  if (type && !((strcmp (type, "") == 0) || valid_type (type)))
    return 3;

  sql ("BEGIN IMMEDIATE;");

  assert (current_credentials.uuid);

  filter = 0;
  if (find_filter (filter_id, &filter))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (filter == 0)
    {
      sql ("ROLLBACK;");
      return 1;
    }

  /* If the filter is linked to an alert, check that the type is valid. */
  if (filter_in_use (filter)
      && type
      && strcasecmp (type, "report"))
    {
      sql ("ROLLBACK;");
      return 5;
    }

  /* Check whether a filter with the same name exists already. */
  if (name)
    {
      quoted_name = sql_quote (name);
      if (sql_int (0, 0,
                   "SELECT COUNT(*) FROM filters"
                   " WHERE name = '%s'"
                   " AND ROWID != %llu"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT users.ROWID FROM users WHERE users.uuid = '%s')));",
                   quoted_name,
                   filter,
                   current_credentials.uuid))
        {
          g_free (quoted_name);
          sql ("ROLLBACK;");
          return 2;
        }
    }
  else
    quoted_name = sql_quote("");

  quoted_term = sql_quote (term ? term : "");
  quoted_comment = sql_quote (comment ? comment : "");
  quoted_type = sql_quote (type ? type : "");

  sql ("UPDATE filters SET"
       " name = '%s',"
       " comment = '%s',"
       " term = '%s',"
       " type = lower ('%s'),"
       " modification_time = now ()"
       " WHERE ROWID = %llu;",
       quoted_name,
       quoted_comment,
       quoted_term,
       quoted_type,
       filter);

  g_free (quoted_comment);
  g_free (quoted_name);
  g_free (quoted_term);
  g_free (quoted_type);

  sql ("COMMIT;");

  return 0;
}


/* Schema. */

/**
 * @brief Generate the OMP schema.
 *
 * @param[in]  format         Name of schema format, "XML" or NULL for XML.
 * @param[out] output_return  NULL or location for output.
 * @param[out] output_length  NULL or location for length of output.
 * @param[out] extension      NULL or location for schema extension.
 * @param[out] content_type   NULL or location for schema content type.
 *
 * @return 0 success, 1 failed to find schema format, -1 error.
 */
int
manage_schema (gchar *format, gchar **output_return, gsize *output_length,
               gchar **extension, gchar **content_type)
{
  /* Pass the XML file to the schema generate script, sending the output
   * to a file. */

  {
    gchar *script, *script_dir;
    gchar *uuid_format;
    char output_dir[] = "/tmp/openvasmd_schema_XXXXXX";

    if (mkdtemp (output_dir) == NULL)
      {
        g_warning ("%s: mkdtemp failed\n", __FUNCTION__);
        return -1;
      }

    /* Setup file names. */

    if (format == NULL)
      {
        if (extension)
          *extension = g_strdup ("xml");
        if (content_type)
          *content_type = g_strdup ("text/xml");
        uuid_format = "18e826fc-dab6-11df-b913-002264764cea";
      }
    else if (strcasecmp (format, "HTML") == 0)
      {
        if (extension)
          *extension = g_strdup ("html");
        if (content_type)
          *content_type = g_strdup ("text/html");
        uuid_format = "02052818-dab6-11df-9be4-002264764cea";
      }
    else if (strcasecmp (format, "RNC") == 0)
      {
        if (extension)
          *extension = g_strdup ("rnc");
        if (content_type)
          *content_type = g_strdup ("text/x-rnc");
        uuid_format = "787a4a18-dabc-11df-9486-002264764cea";
      }
    else if (strcasecmp (format, "XML") == 0)
      {
        if (extension)
          *extension = g_strdup ("xml");
        if (content_type)
          *content_type = g_strdup ("text/xml");
        uuid_format = "18e826fc-dab6-11df-b913-002264764cea";
      }
    else
      return 1;

    script_dir = g_build_filename (OPENVAS_DATA_DIR,
                                   "openvasmd",
                                   "global_schema_formats",
                                   uuid_format,
                                   NULL);

    script = g_build_filename (script_dir, "generate", NULL);

    if (!g_file_test (script, G_FILE_TEST_EXISTS))
      {
        g_free (script);
        g_free (script_dir);
        if (extension) g_free (*extension);
        if (content_type) g_free (*content_type);
        return -1;
      }

    {
      gchar *output_file, *command;
      char *previous_dir;
      int ret;

      /* Change into the script directory. */

      /** @todo NULL arg is glibc extension. */
      previous_dir = getcwd (NULL, 0);
      if (previous_dir == NULL)
        {
          g_warning ("%s: Failed to getcwd: %s\n",
                     __FUNCTION__,
                     strerror (errno));
          g_free (previous_dir);
          g_free (script);
          g_free (script_dir);
          if (extension) g_free (*extension);
          if (content_type) g_free (*content_type);
          return -1;
        }

      if (chdir (script_dir))
        {
          g_warning ("%s: Failed to chdir: %s\n",
                     __FUNCTION__,
                     strerror (errno));
          g_free (previous_dir);
          g_free (script);
          g_free (script_dir);
          if (extension) g_free (*extension);
          if (content_type) g_free (*content_type);
          return -1;
        }
      g_free (script_dir);

      output_file = g_strdup_printf ("%s/report.out", output_dir);

      /* Call the script. */

      command = g_strdup_printf ("/bin/sh %s " OPENVAS_DATA_DIR
                                 "/openvasmd/global_schema_formats"
                                 "/18e826fc-dab6-11df-b913-002264764cea/OMP.xml"
                                 " > %s"
                                 " 2> /dev/null",
                                 script,
                                 output_file);
      g_free (script);

      g_debug ("   command: %s\n", command);

      /* RATS: ignore, command is defined above. */
      if (ret = system (command),
          /** @todo ret is always -1. */
          0 && ((ret) == -1
                || WEXITSTATUS (ret)))
        {
          g_warning ("%s: system failed with ret %i, %i, %s\n",
                     __FUNCTION__,
                     ret,
                     WEXITSTATUS (ret),
                     command);
          if (chdir (previous_dir))
            g_warning ("%s: and chdir failed\n",
                       __FUNCTION__);
          g_free (previous_dir);
          g_free (command);
          g_free (output_file);
          if (extension) g_free (*extension);
          if (content_type) g_free (*content_type);
          return -1;
        }

      {
        GError *get_error;
        gchar *output;
        gsize output_len;

        g_free (command);

        /* Change back to the previous directory. */

        if (chdir (previous_dir))
          {
            g_warning ("%s: Failed to chdir back: %s\n",
                       __FUNCTION__,
                       strerror (errno));
            g_free (previous_dir);
            if (extension) g_free (*extension);
            if (content_type) g_free (*content_type);
            return -1;
          }
        g_free (previous_dir);

        /* Read the script output from file. */

        get_error = NULL;
        g_file_get_contents (output_file,
                             &output,
                             &output_len,
                             &get_error);
        g_free (output_file);
        if (get_error)
          {
            g_warning ("%s: Failed to get output: %s\n",
                       __FUNCTION__,
                       get_error->message);
            g_error_free (get_error);
            if (extension) g_free (*extension);
            if (content_type) g_free (*content_type);
            return -1;
          }

        /* Remove the output directory. */

        openvas_file_remove_recurse (output_dir);

        /* Return the output. */

        if (output_length) *output_length = output_len;

        if (output_return) *output_return = output;
        return 0;
      }
    }
  }
}


/* Trashcan. */

/**
 * @brief Restore a resource from the trashcan.
 *
 * @param[in]  id  UUID of resource.
 *
 * @return 0 success, 1 fail because the resource refers to another resource
 *         in the trashcan, 2 failed to find resource in trashcan, 3 fail
 *         because resource with such name exists already, -1 error.
 */
int
manage_restore (const char *id)
{
  resource_t resource = 0;

  assert (current_credentials.uuid);

  sql ("BEGIN IMMEDIATE;");

  /* Agent. */

  if (find_trash ("agent", id, &resource))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (resource)
    {
      if (sql_int (0, 0,
                   "SELECT count(*) FROM agents"
                   " WHERE name ="
                   " (SELECT name FROM agents_trash WHERE ROWID = %llu)"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT ROWID FROM users WHERE users.uuid = '%s')));",
                   resource,
                   current_credentials.uuid))
        {
          sql ("ROLLBACK;");
          return 3;
        }

      sql ("INSERT INTO agents"
           " (uuid, owner, name, comment, installer, installer_64,"
           "  installer_filename, installer_signature_64, installer_trust,"
           "  installer_trust_time, howto_install, howto_use, creation_time,"
           "  modification_time)"
           " SELECT"
           "  uuid, owner, name, comment, installer, installer_64,"
           "  installer_filename, installer_signature_64, installer_trust,"
           "  installer_trust_time, howto_install, howto_use, creation_time,"
           "  modification_time"
           " FROM agents_trash WHERE ROWID = %llu;",
           resource);

      sql ("DELETE FROM agents_trash WHERE ROWID = %llu;", resource);
      sql ("COMMIT;");
      return 0;
    }

  /* Config. */

  if (find_trash ("config", id, &resource))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (resource)
    {
      config_t config;

      if (sql_int (0, 0,
                   "SELECT count(*) FROM configs"
                   " WHERE name ="
                   " (SELECT name FROM configs_trash WHERE ROWID = %llu)"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT ROWID FROM users WHERE users.uuid = '%s')));",
                   resource,
                   current_credentials.uuid))
        {
          sql ("ROLLBACK;");
          return 3;
        }

      sql ("INSERT INTO configs"
           " (uuid, owner, name, nvt_selector, comment, family_count, nvt_count,"
           "  families_growing, nvts_growing, creation_time, modification_time)"
           " SELECT uuid, owner, name, nvt_selector, comment, family_count,"
           "        nvt_count, families_growing, nvts_growing,"
           "        creation_time, modification_time"
           " FROM configs_trash WHERE ROWID = %llu;",
           resource);

      config = sqlite3_last_insert_rowid (task_db);

      sql ("INSERT INTO config_preferences"
           " (config, type, name, value)"
           " SELECT %llu, type, name, value"
           " FROM config_preferences_trash WHERE config = %llu;",
           config,
           resource);

      /* Update the config in any trashcan tasks. */
      sql ("UPDATE tasks"
           " SET config = %llu,"
           "     config_location = " G_STRINGIFY (LOCATION_TABLE)
           " WHERE config = %llu"
           " AND config_location = " G_STRINGIFY (LOCATION_TRASH),
           config,
           resource);

      sql ("DELETE FROM config_preferences_trash WHERE config = %llu;",
           resource);
      sql ("DELETE FROM configs_trash WHERE ROWID = %llu;", resource);
      sql ("COMMIT;");
      return 0;
    }

  /* Alert. */

  if (find_trash ("alert", id, &resource))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (resource)
    {
      alert_t alert;

      if (sql_int (0, 0,
                   "SELECT count(*) FROM alerts"
                   " WHERE name ="
                   " (SELECT name FROM alerts_trash WHERE ROWID = %llu)"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT ROWID FROM users WHERE users.uuid = '%s')));",
                   resource,
                   current_credentials.uuid))
        {
          sql ("ROLLBACK;");
          return 3;
        }

      /* Check if it uses a filter in the trashcan. */
      if (sql_int (0, 0,
                   "SELECT filter_location = " G_STRINGIFY (LOCATION_TRASH)
                   " FROM alerts_trash WHERE ROWID = %llu;",
                   resource))
        {
          sql ("ROLLBACK;");
          return 1;
        }

      sql ("INSERT INTO alerts"
           " (uuid, owner, name, comment, event, condition, method, filter,"
           "  creation_time, modification_time)"
           " SELECT uuid, owner, name, comment, event, condition, method,"
           "        filter, creation_time, modification_time"
           " FROM alerts_trash WHERE ROWID = %llu;",
           resource);

      alert = sqlite3_last_insert_rowid (task_db);

      sql ("INSERT INTO alert_condition_data"
           " (alert, name, data)"
           " SELECT %llu, name, data"
           " FROM alert_condition_data_trash WHERE alert = %llu;",
           alert,
           resource);

      sql ("INSERT INTO alert_event_data"
           " (alert, name, data)"
           " SELECT %llu, name, data"
           " FROM alert_event_data_trash WHERE alert = %llu;",
           alert,
           resource);

      sql ("INSERT INTO alert_method_data"
           " (alert, name, data)"
           " SELECT %llu, name, data"
           " FROM alert_method_data_trash WHERE alert = %llu;",
           alert,
           resource);

      /* Update the alert in any trashcan tasks. */
      sql ("UPDATE task_alerts"
           " SET alert = %llu,"
           "     alert_location = " G_STRINGIFY (LOCATION_TABLE)
           " WHERE alert = %llu"
           " AND alert_location = " G_STRINGIFY (LOCATION_TRASH),
           alert,
           resource);

      sql ("DELETE FROM alert_condition_data_trash WHERE alert = %llu;",
           resource);
      sql ("DELETE FROM alert_event_data_trash WHERE alert = %llu;",
           resource);
      sql ("DELETE FROM alert_method_data_trash WHERE alert = %llu;",
           resource);
      sql ("DELETE FROM alerts_trash WHERE ROWID = %llu;",
           resource);
      sql ("COMMIT;");
      return 0;
    }

  /* Filter. */

  if (find_trash ("filter", id, &resource))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (resource)
    {
      if (sql_int (0, 0,
                   "SELECT count(*) FROM filters"
                   " WHERE name ="
                   " (SELECT name FROM filters_trash WHERE ROWID = %llu)"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT ROWID FROM users WHERE users.uuid = '%s')));",
                   resource,
                   current_credentials.uuid))
        {
          sql ("ROLLBACK;");
          return 3;
        }

      sql ("INSERT INTO filters"
           " (uuid, owner, name, comment, type, term, creation_time,"
           "  modification_time)"
           " SELECT uuid, owner, name, comment, type, term, creation_time,"
           "        modification_time"
           " FROM filters_trash WHERE ROWID = %llu;",
           resource);

      /* Update the filter in any trashcan alerts. */
      sql ("UPDATE alerts_trash"
           " SET filter = %llu,"
           "     filter_location = " G_STRINGIFY (LOCATION_TABLE)
           " WHERE filter = %llu"
           " AND filter_location = " G_STRINGIFY (LOCATION_TRASH),
           sqlite3_last_insert_rowid (task_db),
           resource);

      sql ("DELETE FROM filters_trash WHERE ROWID = %llu;", resource);
      sql ("COMMIT;");
      return 0;
    }

  /* LSC credential. */

  if (find_trash ("lsc_credential", id, &resource))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (resource)
    {
      lsc_credential_t credential;

      if (sql_int (0, 0,
                   "SELECT count(*) FROM lsc_credentials"
                   " WHERE name ="
                   " (SELECT name FROM lsc_credentials_trash WHERE ROWID = %llu)"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT ROWID FROM users WHERE users.uuid = '%s')));",
                   resource,
                   current_credentials.uuid))
        {
          sql ("ROLLBACK;");
          return 3;
        }

      sql ("INSERT INTO lsc_credentials"
           " (uuid, owner, name, login, password, comment, public_key,"
           "  private_key, rpm, deb, exe, creation_time, modification_time)"
           " SELECT uuid, owner, name, login, password, comment, public_key,"
           "  private_key, rpm, deb, exe, creation_time, modification_time"
           " FROM lsc_credentials_trash WHERE ROWID = %llu;",
           resource);

      /* Update the credentials in any trashcan targets. */
      credential = sqlite3_last_insert_rowid (task_db);
      sql ("UPDATE targets_trash"
           " SET ssh_location = " G_STRINGIFY (LOCATION_TABLE) ","
           "     lsc_credential = %llu"
           " WHERE lsc_credential = %llu"
           " AND ssh_location = " G_STRINGIFY (LOCATION_TRASH) ";",
           credential,
           resource);
      sql ("UPDATE targets_trash"
           " SET smb_location = " G_STRINGIFY (LOCATION_TABLE) ","
           "     smb_lsc_credential = %llu"
           " WHERE smb_lsc_credential = %llu"
           " AND smb_location = " G_STRINGIFY (LOCATION_TRASH) ";",
           credential,
           resource);

      sql ("DELETE FROM lsc_credentials_trash WHERE ROWID = %llu;", resource);
      sql ("COMMIT;");
      return 0;
    }

  /* Note. */

  if (find_trash ("note", id, &resource))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (resource)
    {
      sql ("INSERT INTO notes"
           " (uuid, owner, nvt, creation_time, modification_time, text, hosts,"
           "  port, threat, task, result, end_time)"
           " SELECT uuid, owner, nvt, creation_time, modification_time, text,"
           "        hosts, port, threat, task, result, end_time"
           " FROM notes_trash WHERE ROWID = %llu;",
           resource);
      sql ("DELETE FROM notes_trash WHERE ROWID = %llu;", resource);
      sql ("COMMIT;");
      return 0;
    }

  /* Override. */

  if (find_trash ("override", id, &resource))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (resource)
    {
      sql ("INSERT INTO overrides"
           " (uuid, owner, nvt, creation_time, modification_time, text, hosts,"
           "  port, threat, new_threat, task, result, end_time)"
           " SELECT uuid, owner, nvt, creation_time, modification_time, text,"
           "        hosts, port, threat, new_threat, task, result, end_time"
           " FROM overrides_trash WHERE ROWID = %llu;",
           resource);
      sql ("DELETE FROM overrides_trash WHERE ROWID = %llu;", resource);
      reports_clear_count_cache (1);
      sql ("COMMIT;");
      return 0;
    }

  /* Port list. */

  if (find_trash ("port_list", id, &resource))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (resource)
    {
      port_list_t table_port_list;

      if (sql_int (0, 0,
                   "SELECT count(*) FROM port_lists"
                   " WHERE name ="
                   " (SELECT name FROM port_lists_trash WHERE ROWID = %llu)"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT ROWID FROM users WHERE users.uuid = '%s')));",
                   resource,
                   current_credentials.uuid))
        {
          sql ("ROLLBACK;");
          return 3;
        }

      sql ("INSERT INTO port_lists"
           " (uuid, owner, name, comment, creation_time, modification_time)"
           " SELECT uuid, owner, name, comment, creation_time, modification_time"
           " FROM port_lists_trash WHERE ROWID = %llu;",
           resource);

      table_port_list = sqlite3_last_insert_rowid (task_db);

      sql ("INSERT INTO port_ranges"
           " (uuid, port_list, type, start, end, comment, exclude)"
           " SELECT uuid, %llu, type, start, end, comment, exclude"
           " FROM port_ranges_trash WHERE port_list = %llu;",
           table_port_list,
           resource);

      /* Update the port_list in any trashcan targets. */
      sql ("UPDATE targets_trash"
           " SET port_range = %llu,"
           "     port_list_location = " G_STRINGIFY (LOCATION_TABLE)
           " WHERE port_range = %llu"
           " AND port_list_location = " G_STRINGIFY (LOCATION_TRASH),
           table_port_list,
           resource);

      sql ("DELETE FROM port_lists_trash WHERE ROWID = %llu;", resource);
      sql ("DELETE FROM port_ranges_trash WHERE port_list = %llu;", resource);
      sql ("COMMIT;");
      return 0;
    }

  /* Report format. */

  if (find_trash ("report_format", id, &resource))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (resource)
    {
      iterator_t params;
      report_format_t report_format;
      gchar *dir, *trash_dir, *resource_string;
      int global;
      char *trash_uuid;

      if (sql_int (0, 0,
                   "SELECT count(*) FROM report_formats"
                   " WHERE name ="
                   " (SELECT name FROM report_formats_trash WHERE ROWID = %llu)"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT ROWID FROM users WHERE users.uuid = '%s')));",
                   resource,
                   current_credentials.uuid))
        {
          sql ("ROLLBACK;");
          return 3;
        }

      /* Move to "real" tables. */

      sql ("INSERT INTO report_formats"
           " (uuid, owner, name, extension, content_type, summary,"
           "  description, signature, trust, trust_time, flags,"
           "  creation_time, modification_time)"
           " SELECT"
           "  original_uuid, owner, name, extension, content_type, summary,"
           "  description, signature, trust, trust_time, flags,"
           "  creation_time, modification_time"
           " FROM report_formats_trash"
           " WHERE ROWID = %llu;",
           resource);

      report_format = sqlite3_last_insert_rowid (task_db);

      init_report_format_param_iterator (&params, resource, 1, 1, NULL);
      while (next (&params))
        {
          report_format_param_t param, trash_param;

          trash_param = report_format_param_iterator_param (&params);

          sql ("INSERT INTO report_format_params"
               " (report_format, name, type, value, type_min, type_max,"
               "  type_regex, fallback)"
               " SELECT"
               "  %llu, name, type, value, type_min, type_max,"
               "  type_regex, fallback"
               " FROM report_format_params_trash"
               " WHERE ROWID = %llu;",
               report_format,
               trash_param);

          param = sqlite3_last_insert_rowid (task_db);

          sql ("INSERT INTO report_format_param_options"
               " (report_format_param, value)"
               " SELECT %llu, value"
               " FROM report_format_param_options_trash"
               " WHERE report_format_param = %llu;",
               param,
               trash_param);
        }
      cleanup_iterator (&params);

      global = report_format_trash_global (resource);

      trash_uuid = sql_string (0, 0,
                               "SELECT original_uuid FROM report_formats_trash"
                               " WHERE ROWID = %llu;",
                               resource);
      if (trash_uuid == NULL)
        abort ();

      /* Remove from trash tables. */

      sql ("DELETE FROM report_formats_trash WHERE ROWID = %llu;",
           resource);
      sql ("DELETE FROM report_format_param_options_trash"
           " WHERE report_format_param"
           " IN (SELECT ROWID from report_format_params_trash"
           "     WHERE report_format = %llu);",
           resource);
      sql ("DELETE FROM report_format_params_trash WHERE report_format = %llu;",
           resource);

      /* Move the dir last, in case any SQL rolls back. */

      if (global)
        dir = g_build_filename (OPENVAS_DATA_DIR,
                                "openvasmd",
                                "global_report_formats",
                                trash_uuid,
                                NULL);
      else
        dir = g_build_filename (OPENVAS_STATE_DIR,
                                "openvasmd",
                                "report_formats",
                                current_credentials.uuid,
                                trash_uuid,
                                NULL);
      free (trash_uuid);

      resource_string = g_strdup_printf ("%llu", resource);
      trash_dir = g_build_filename (OPENVAS_DATA_DIR,
                                    "openvasmd",
                                    "report_formats_trash",
                                    resource_string,
                                    NULL);
      g_free (resource_string);
      if (g_file_test (trash_dir, G_FILE_TEST_EXISTS))
        {
          if (rename (trash_dir, dir))
            {
              g_warning ("%s: rename %s to %s: %s\n",
                         __FUNCTION__, dir, trash_dir, strerror (errno));
              g_free (dir);
              g_free (trash_dir);
              sql ("ROLLBACK;");
              return -1;
            }
        }
      else
        {
          g_warning ("%s: report trash dir missing: %s\n",
                     __FUNCTION__, trash_dir);
          g_free (dir);
          g_free (trash_dir);
          sql ("ROLLBACK;");
          return -1;
        }
      g_free (dir);
      g_free (trash_dir);

      sql ("COMMIT;");
      return 0;
    }

  /* Schedule. */

  if (find_trash ("schedule", id, &resource))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (resource)
    {
      if (sql_int (0, 0,
                   "SELECT count(*) FROM schedules"
                   " WHERE name ="
                   " (SELECT name FROM schedules_trash WHERE ROWID = %llu)"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT ROWID FROM users WHERE users.uuid = '%s')));",
                   resource,
                   current_credentials.uuid))
        {
          sql ("ROLLBACK;");
          return 3;
        }

      sql ("INSERT INTO schedules"
           " (uuid, owner, name, comment, first_time, period, period_months,"
           "  duration, timezone, initial_offset, creation_time,"
           "  modification_time)"
           " SELECT uuid, owner, name, comment, first_time, period,"
           "        period_months, duration, timezone, initial_offset,"
           "        creation_time, modification_time"
           " FROM schedules_trash WHERE ROWID = %llu;",
           resource);

      /* Update the schedule in any trashcan tasks. */
      sql ("UPDATE tasks"
           " SET schedule = %llu,"
           "     schedule_location = " G_STRINGIFY (LOCATION_TABLE)
           " WHERE schedule = %llu"
           " AND schedule_location = " G_STRINGIFY (LOCATION_TRASH),
           sqlite3_last_insert_rowid (task_db),
           resource);

      sql ("DELETE FROM schedules_trash WHERE ROWID = %llu;", resource);
      sql ("COMMIT;");
      return 0;
    }

  /* Slave. */

  if (find_trash ("slave", id, &resource))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (resource)
    {
      if (sql_int (0, 0,
                   "SELECT count(*) FROM slaves"
                   " WHERE name ="
                   " (SELECT name FROM slaves_trash WHERE ROWID = %llu)"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT ROWID FROM users WHERE users.uuid = '%s')));",
                   resource,
                   current_credentials.uuid))
        {
          sql ("ROLLBACK;");
          return 3;
        }

      sql ("INSERT INTO slaves"
           "  (uuid, owner, name, comment, host, port, login, password,"
           "   creation_time, modification_time)"
           " SELECT"
           "  uuid, owner, name, comment, host, port, login, password,"
           "  creation_time, modification_time"
           " FROM slaves_trash WHERE ROWID = %llu;",
           resource);

      /* Update the slave in any trashcan tasks. */
      sql ("UPDATE tasks"
           " SET slave = %llu,"
           "     slave_location = " G_STRINGIFY (LOCATION_TABLE)
           " WHERE slave = %llu"
           " AND slave_location = " G_STRINGIFY (LOCATION_TRASH),
           sqlite3_last_insert_rowid (task_db),
           resource);

      sql ("DELETE FROM slaves_trash WHERE ROWID = %llu;", resource);
      sql ("COMMIT;");
      return 0;
    }

  /* Target. */

  if (find_trash ("target", id, &resource))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (resource)
    {
      if (sql_int (0, 0,
                   "SELECT count(*) FROM targets"
                   " WHERE name ="
                   " (SELECT name FROM targets_trash WHERE ROWID = %llu)"
                   " AND ((owner IS NULL) OR (owner ="
                   " (SELECT ROWID FROM users WHERE users.uuid = '%s')));",
                   resource,
                   current_credentials.uuid))
        {
          sql ("ROLLBACK;");
          return 3;
        }

      /* Check if it uses a credential or port list in the trashcan. */
      if (sql_int (0, 0,
                   "SELECT ssh_location = " G_STRINGIFY (LOCATION_TRASH)
                   " OR smb_location = " G_STRINGIFY (LOCATION_TRASH)
                   " OR port_list_location = " G_STRINGIFY (LOCATION_TRASH)
                   " FROM targets_trash WHERE ROWID = %llu;",
                   resource))
        {
          sql ("ROLLBACK;");
          return 1;
        }

      sql ("INSERT INTO targets"
           " (uuid, owner, name, hosts, comment, lsc_credential, ssh_port,"
           "  smb_lsc_credential, port_range, creation_time, modification_time)"
           " SELECT uuid, owner, name, hosts, comment, lsc_credential, ssh_port,"
           "        smb_lsc_credential, port_range, creation_time,"
           "        modification_time"
           " FROM targets_trash WHERE ROWID = %llu;",
           resource);

      /* Update the target in any trashcan tasks. */
      sql ("UPDATE tasks"
           " SET target = %llu,"
           "     target_location = " G_STRINGIFY (LOCATION_TABLE)
           " WHERE target = %llu"
           " AND target_location = " G_STRINGIFY (LOCATION_TRASH),
           sqlite3_last_insert_rowid (task_db),
           resource);

      sql ("DELETE FROM targets_trash WHERE ROWID = %llu;", resource);
      sql ("COMMIT;");
      return 0;
    }

  /* Task. */

  if (find_trash_task (id, &resource))
    {
      sql ("ROLLBACK;");
      return -1;
    }

  if (resource)
    {
      /* Check if it's in use by a resource in the trashcan. */
      if (sql_int (0, 0,
                   "SELECT (target_location = " G_STRINGIFY (LOCATION_TRASH) ")"
                   " OR (config_location = " G_STRINGIFY (LOCATION_TRASH) ")"
                   " OR (schedule_location = " G_STRINGIFY (LOCATION_TRASH) ")"
                   " OR (slave_location = " G_STRINGIFY (LOCATION_TRASH) ")"
                   " OR (SELECT count(*) > 0 FROM task_alerts"
                   "     WHERE task = tasks.ROWID"
                   "     AND alert_location = " G_STRINGIFY (LOCATION_TRASH) ")"
                   " FROM tasks WHERE ROWID = %llu;",
                   resource))
        {
          sql ("ROLLBACK;");
          return 1;
        }

      sql ("UPDATE tasks SET hidden = 0 WHERE ROWID = %llu;", resource);
      sql ("COMMIT;");
      return 0;
    }

  sql ("ROLLBACK;");
  return 2;
}

/**
 * @brief Empty the trashcan.
 *
 * @return 0 success, -1 error.
 */
int
manage_empty_trashcan ()
{
  gchar *dir;

  sql ("BEGIN IMMEDIATE;");
  sql ("DELETE FROM agents_trash;");
  sql ("DELETE FROM nvt_selectors WHERE name IN"
       " (SELECT nvt_selector FROM configs_trash);");
  sql ("DELETE FROM config_preferences_trash;");
  sql ("DELETE FROM configs_trash;");
  sql ("DELETE FROM alert_condition_data_trash;");
  sql ("DELETE FROM alert_event_data_trash;");
  sql ("DELETE FROM alert_method_data_trash;");
  sql ("DELETE FROM alerts_trash;");
  sql ("DELETE FROM filters_trash;");
  sql ("DELETE FROM lsc_credentials_trash;");
  sql ("DELETE FROM notes_trash;");
  sql ("DELETE FROM overrides_trash;");
  sql ("DELETE FROM port_ranges_trash;");
  sql ("DELETE FROM port_lists_trash;");
  sql ("DELETE FROM schedules_trash;");
  sql ("DELETE FROM slaves_trash;");
  sql ("DELETE FROM targets_trash;");
  if (delete_trash_tasks ())
    {
      sql ("ROLLBACK;");
      return -1;
    }

  sql ("DELETE FROM report_formats_trash;");

  /* Remove the report formats dir last, in case any SQL rolls back. */

  dir = g_build_filename (OPENVAS_DATA_DIR,
                          "openvasmd",
                          "report_formats_trash",
                          NULL);

  if (g_file_test (dir, G_FILE_TEST_EXISTS) && openvas_file_remove_recurse (dir))
    {
      g_warning ("%s: failed to remove trash dir %s", __FUNCTION__, dir);
      g_free (dir);
      sql ("ROLLBACK;");
      return -1;
    }

  if (g_mkdir_with_parents (dir, 0755 /* "rwxr-xr-x" */))
    {
      g_warning ("%s: failed to create trash dir %s", __FUNCTION__, dir);
      g_free (dir);
      sql ("ROLLBACK;");
      return -1;
    }

  g_free (dir);

  sql ("COMMIT;");
  return 0;
}


/* Assets. */

/**
 * @brief Add host details to a report host.
 *
 * @param[in]  report  UUID of resource.
 * @param[in]  host    Host.
 * @param[in]  entity  XML entity containing details.
 *
 * @return 0 success, -1 failed to parse XML.
 */
int
manage_report_host_details (report_t report, const char *host, entity_t entity)
{
  entities_t details;
  entity_t detail;

  details = entity->entities;
  while ((detail = first_entity (details)))
    {
      if (strcmp (entity_name (detail), "detail") == 0)
        {
          entity_t source, source_type, source_name, source_desc, name, value;
          gchar *quoted_host, *quoted_source_name, *quoted_source_type;
          gchar *quoted_source_desc, *quoted_name, *quoted_value;

          source = entity_child (detail, "source");
          if (source == NULL)
            return -1;
          source_type = entity_child (source, "type");
          if (source_type == NULL)
            return -1;
          source_name = entity_child (source, "name");
          if (source_name == NULL)
            return -1;
          source_desc = entity_child (source, "description");
          if (source_desc == NULL)
            return -1;
          name = entity_child (detail, "name");
          if (name == NULL)
            return -1;
          value = entity_child (detail, "value");
          if (value == NULL)
            return -1;

          quoted_host = sql_quote (host);
          quoted_source_type = sql_quote (entity_text (source_type));
          quoted_source_name = sql_quote (entity_text (source_name));
          quoted_source_desc = sql_quote (entity_text (source_desc));
          quoted_name = sql_quote (entity_text (name));
          quoted_value = sql_quote (entity_text (value));
          sql ("INSERT INTO report_host_details"
               " (report_host, source_type, source_name, source_description,"
               "  name, value)"
               " VALUES"
               " ((SELECT ROWID FROM report_hosts"
               "   WHERE report = %llu AND host = '%s'),"
               "  '%s', '%s', '%s', '%s', '%s');",
               report, quoted_host, quoted_source_type, quoted_source_name,
               quoted_source_desc, quoted_name, quoted_value);
          g_free (quoted_host);
          g_free (quoted_source_type);
          g_free (quoted_source_name);
          g_free (quoted_source_desc);
          g_free (quoted_name);
          g_free (quoted_value);
        }
      details = next_entities (details);
    }

  return 0;
}

/**
 * @brief Add a host detail to a report host.
 *
 * @param[in]  report  UUID of resource.
 * @param[in]  host    Host.
 * @param[in]  xml     Report host detail XML.
 *
 * @return 0 success, -1 failed to parse XML, -2 host was NULL.
 */
int
manage_report_host_detail (report_t report, const char *host, const char *xml)
{
  int ret;
  entity_t entity;

  if (host == NULL)
    return -2;

  entity = NULL;
  if (parse_entity (xml, &entity))
    return -1;

  ret = manage_report_host_details (report, host, entity);
  free_entity (entity);
  return ret;
}


/* Settings. */

/**
 * @brief Extra columns for setting iterator.
 */
#define SETTING_ITERATOR_EXTRA_COLS \
 { NULL }

/**
 * @brief Count number of settings.
 *
 * @param[in]  filter           Filter term.
 *
 * @return Total number of settings in filtered set.
 */
int
setting_count (const char *filter)
{
  static const char *extra_columns[] = SETTING_ITERATOR_EXTRA_COLS;
  gchar *clause;
  int ret;

  assert (current_credentials.uuid);

  clause = filter_clause ("setting", filter, extra_columns, 0, NULL, NULL,
                          NULL);

  ret = sql_int (0, 0,
                 "SELECT count (*)"
                 " FROM settings"
                 " WHERE"
                 " (owner == (SELECT ROWID FROM users WHERE uuid = '%s')"
                 "  OR (owner IS NULL"
                 "      AND uuid"
                 "      NOT IN (SELECT uuid FROM settings"
                 "              WHERE owner == (SELECT ROWID FROM users"
                 "                              WHERE uuid = '%s'))))"
                 "%s%s;",
                 current_credentials.uuid,
                 current_credentials.uuid,
                 clause ? " AND " : "",
                 clause ? clause : "");

  g_free (clause);

  return ret;
}

/**
 * @brief Return the uuid of a resource filter from settings.
 *
 * @param[in]  resource  Resource.
 *
 * @return resource filter uuid in settings if it exists, "" otherwise.
 */
char *
setting_filter (const char *resource)
{
  return sql_string (0, 0,
                     "SELECT value FROM settings WHERE name = '%s Filter'"
                     " AND ((owner IS NULL)"
                     "      OR (owner ="
                     "          (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                     " ORDER BY owner DESC;",
                     resource,
                     current_credentials.uuid);
}

/**
 * @brief Initialise a setting iterator, including observed settings.
 *
 * @param[in]  iterator    Iterator.
 * @param[in]  uuid        UUID of setting to limit iteration to.  0 for all.
 * @param[in]  filter      Filter term.
 * @param[in]  first       First setting.
 * @param[in]  max         Maximum number of settings returned.
 * @param[in]  ascending   Whether to sort ascending or descending.
 * @param[in]  sort_field  Field to sort on, or NULL for "ROWID".
 */
void
init_setting_iterator (iterator_t *iterator, const char *uuid,
                       const char *filter, int first, int max, int ascending,
                       const char *sort_field)
{
  static const char *extra_columns[] = SETTING_ITERATOR_EXTRA_COLS;
  gchar *clause, *quoted_uuid;

  assert (current_credentials.uuid);

  if (first < 0)
    first = 0;
  if (max < 1)
    max = -1;

  clause = filter_clause ("setting", filter, extra_columns, 0, NULL, NULL,
                          NULL);

  quoted_uuid = uuid ? sql_quote (uuid) : NULL;

  if (quoted_uuid)
    init_iterator (iterator,
                   "SELECT ROWID, uuid, name, comment, value"
                   " FROM settings"
                   " WHERE uuid = '%s'"
                   " AND (owner IS NULL)"
                   " OR (owner ="
                   "     (SELECT ROWID FROM users WHERE users.uuid = '%s'))"
                   /* Force the user's setting to come before the default. */
                   " ORDER BY owner DESC;",
                   quoted_uuid,
                   current_credentials.uuid);
  else
    init_iterator (iterator,
                   "SELECT ROWID, uuid, name, comment, value"
                   " FROM settings"
                   " WHERE"
                   " (owner == (SELECT ROWID FROM users WHERE uuid = '%s')"
                   "  OR (owner IS NULL"
                   "      AND uuid"
                   "      NOT IN (SELECT uuid FROM settings"
                   "              WHERE owner == (SELECT ROWID FROM users"
                   "                              WHERE uuid = '%s'))))"
                   "%s%s"
                   " ORDER BY %s %s"
                   " LIMIT %i OFFSET %i;",
                   current_credentials.uuid,
                   current_credentials.uuid,
                   clause ? " AND " : "",
                   clause ? clause : "",
                   sort_field ? sort_field : "ROWID",
                   ascending ? "ASC" : "DESC",
                   max,
                   first);

  g_free (clause);
}

/**
 * @brief Get the UUID from a setting iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The UUID of the setting, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (setting_iterator_uuid, 1);

/**
 * @brief Get the name from a setting iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The name of the setting, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (setting_iterator_name, 2);

/**
 * @brief Get the comment from a setting iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The comment of the setting, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (setting_iterator_comment, 3);

/**
 * @brief Get the value from a setting iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The value of the setting, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (setting_iterator_value, 4);

/**
 * @brief Get the value of a setting.
 *
 * @param[in]   uuid   UUID of setting.
 * @param[out]  value  Value.
 *
 * @return 0 success, -1 error.
 */
int
setting_value_int (const char *uuid, int *value)
{
  gchar *quoted_uuid;

  if (value == NULL || uuid == NULL)
    return -1;

  quoted_uuid = sql_quote (uuid);

  if (sql_int (0, 0,
               "SELECT count (*)"
               " FROM settings"
               " WHERE uuid = '%s'"
               " AND (owner IS NULL)"
               " OR (owner ="
               "     (SELECT ROWID FROM users WHERE users.uuid = '%s'));",
               quoted_uuid,
               current_credentials.uuid)
      == 0)
    {
      *value = -1;
      g_free (quoted_uuid);
      return -1;
    }

  *value = sql_int (0, 0,
                    "SELECT value"
                    " FROM settings"
                    " WHERE uuid = '%s'"
                    " AND ((owner IS NULL)"
                    "      OR (owner ="
                    "       (SELECT ROWID FROM users WHERE users.uuid = '%s')))"
                    /* Force the user's setting to come before the default. */
                    " ORDER BY owner DESC;",
                    quoted_uuid,
                    current_credentials.uuid);

  g_free (quoted_uuid);

  return 0;
}

/**
 * @brief Set the value of a setting.
 *
 * @param[in]  uuid      UUID of setting.
 * @param[in]  name      Setting name.  For Timezone and Password.
 * @param[in]  value_64  New setting value, base64 encoded.
 * @param[out] r_errdesc If not NULL the address of a variable to receive
 *                       a malloced string with the error description.  Will
 *                       always be set to NULL on success.
 *
 * @return 0 success, 1 failed to find setting, 2 syntax error in value, -1 on
 *         error.
 */
int
manage_set_setting (const gchar *uuid, const gchar *name,
                    const gchar *value_64, gchar **r_errdesc)
{
  char *filter_name;

  if (r_errdesc)
    *r_errdesc = NULL;

  assert (current_credentials.uuid);

  if (name && (strcmp (name, "Timezone") == 0))
    {
      gsize value_size;
      gchar *quoted_timezone, *value;
      if (value_64 && strlen (value_64))
        value = (gchar*) g_base64_decode (value_64, &value_size);
      else
        {
          value = g_strdup ("");
          value_size = 0;
        }
      quoted_timezone = sql_quote (value);
      sql ("UPDATE users SET timezone = '%s' WHERE uuid = '%s';",
           quoted_timezone,
           current_credentials.uuid);
      g_free (quoted_timezone);
      return 0;
    }

  if (name && (strcmp (name, "Password") == 0))
    {
      gsize value_size;
      gchar *value;
      gchar *errstr;

      assert (current_credentials.username);

      if (value_64 && strlen (value_64))
        value = (gchar*) g_base64_decode (value_64, &value_size);
      else
        {
          value = g_strdup ("");
          value_size = 0;
        }

      if ((errstr = openvas_validate_password (value,
                                               current_credentials.username)))
        {
          g_warning ("new password for '%s' rejected: %s",
                     current_credentials.username, errstr);
          if (r_errdesc)
            *r_errdesc = errstr;
          else
            g_free (errstr);
          return -1;
        }
      return openvas_user_modify (current_credentials.username, value,
                                  NULL, NULL, 0, OPENVAS_USERS_DIR, NULL);
    }

  if (uuid && (strcmp (uuid, "5f5a8712-8017-11e1-8556-406186ea4fc5") == 0
               || strcmp (uuid, "20f3034c-e709-11e1-87e7-406186ea4fc5") == 0))
    {
      gsize value_size;
      gchar *value, *quoted_uuid, *quoted_value;

      assert (current_credentials.username);

      quoted_uuid = sql_quote (uuid);

      if (sql_int (0, 0,
                   "SELECT count(*) FROM settings"
                   " WHERE uuid = '%s'"
                   " AND owner IS NULL;",
                   quoted_uuid,
                   current_credentials.uuid)
          == 0)
        {
          g_free (quoted_uuid);
          return 1;
        }

      if (value_64 && strlen (value_64))
        value = (gchar*) g_base64_decode (value_64, &value_size);
      else
        {
          value = g_strdup ("");
          value_size = 0;
        }

      if (strcmp (uuid, "5f5a8712-8017-11e1-8556-406186ea4fc5") == 0)
        {
          const gchar *val;
          /* Rows Per Page. */
          val = value;
          while (*val && isdigit (*val)) val++;
          if (*val && strcmp (value, "-1"))
            {
              g_free (quoted_uuid);
              return 2;
            }
        }

      quoted_value = sql_quote (value);

      if (sql_int (0, 0,
                   "SELECT count(*) FROM settings"
                   " WHERE uuid = '%s'"
                   " AND owner = (SELECT ROWID FROM users WHERE uuid = '%s');",
                   quoted_uuid,
                   current_credentials.uuid))
        sql ("UPDATE settings SET value = '%s'"
             " WHERE uuid = '%s'"
             " AND owner = (SELECT ROWID FROM users WHERE uuid = '%s');",
             quoted_value,
             quoted_uuid,
             current_credentials.uuid);
      else
        sql ("INSERT INTO settings (uuid, owner, name, comment, value)"
             " VALUES"
             " ('%s',"
             "  (SELECT ROWID FROM users WHERE uuid = '%s'),"
             "  (SELECT name FROM settings"
             "   WHERE uuid = '%s' AND owner IS NULL),"
             "  (SELECT comment FROM settings"
             "   WHERE uuid = '%s' AND owner IS NULL),"
             "  '%s');",
             quoted_uuid,
             current_credentials.uuid,
             quoted_uuid,
             quoted_uuid,
             quoted_value);

      g_free (quoted_uuid);
      g_free (quoted_value);

      return 0;
    }

  /* Resources filters. */

  if (uuid)
    {
      if (strcmp (uuid, "4a1334c1-cb93-4a79-8634-103b0a50bdcd") == 0)
        filter_name = g_strdup ("Agents Filter");
      else if (strcmp (uuid, "b833a6f2-dcdc-4535-bfb0-a5154b5b5092") == 0)
        filter_name = g_strdup ("Alerts Filter");
      else if (strcmp (uuid, "1a9fbd91-0182-44cd-bc88-a13a9b3b1bef") == 0)
        filter_name = g_strdup ("Configs Filter");
      else if (strcmp (uuid, "186a5ac8-fe5a-4fb1-aa22-44031fb339f3") == 0)
        filter_name = g_strdup ("Credentials Filter");
      else if (strcmp (uuid, "f9691163-976c-47e7-ad9a-38f2d5c81649") == 0)
        filter_name = g_strdup ("Filters Filter");
      else if (strcmp (uuid, "96abcd5a-9b6d-456c-80b8-c3221bfa499d") == 0)
        filter_name = g_strdup ("Notes Filter");
      else if (strcmp (uuid, "eaaaebf1-01ef-4c49-b7bb-955461c78e0a") == 0)
        filter_name = g_strdup ("Overrides Filter");
      else if (strcmp (uuid, "7d52d575-baeb-4d98-bb68-e1730dbc6236") == 0)
        filter_name = g_strdup ("Port Lists Filter");
      else if (strcmp (uuid, "48ae588e-9085-41bc-abcb-3d6389cf7237") == 0)
        filter_name = g_strdup ("Reports Filter");
      else if (strcmp (uuid, "249c7a55-065c-47fb-b453-78e11a665565") == 0)
        filter_name = g_strdup ("Report Formats Filter");
      else if (strcmp (uuid, "a83e321b-d994-4ae8-beec-bfb5fe3e7336") == 0)
        filter_name = g_strdup ("Schedules Filter");
      else if (strcmp (uuid, "2681c32a-8dfd-40c9-a9c6-8d4e2c7799eb") == 0)
        filter_name = g_strdup ("Slaves Filter");
      else if (strcmp (uuid, "236e2e41-9771-4e7a-8124-c432045985e0") == 0)
        filter_name = g_strdup ("Targets Filter");
      else if (strcmp (uuid, "1c981851-8244-466c-92c4-865ffe05e721") == 0)
        filter_name = g_strdup ("Tasks Filter");
      else if (strcmp (uuid, "3414a107-ae46-4dea-872d-5c4479a48e8f") == 0)
        filter_name = g_strdup ("CPE Filter");
      else if (strcmp (uuid, "def63b5a-41ef-43f4-b9ef-03ef1665db5d") == 0)
        filter_name = g_strdup ("CVE Filter");
      else if (strcmp (uuid, "bef08b33-075c-4f8c-84f5-51f6137e40a3") == 0)
        filter_name = g_strdup ("NVT Filter");
      else if (strcmp (uuid, "adb6ffc8-e50e-4aab-9c31-13c741eb8a16") == 0)
        filter_name = g_strdup ("OVAL Filter");
      else if (strcmp (uuid, "312350ed-bc06-44f3-8b3f-ab9eb828b80b") == 0)
        filter_name = g_strdup ("DFN-CERT Filter");
      else
        filter_name = g_strdup ("");
    }

  if (uuid && (strcmp (filter_name, "Agents Filter") == 0
               || strcmp (filter_name, "Alerts Filter") == 0
               || strcmp (filter_name, "Configs Filter") == 0
               || strcmp (filter_name, "Credentials Filter") == 0
               || strcmp (filter_name, "Filters Filter") == 0
               || strcmp (filter_name, "Notes Filter") == 0
               || strcmp (filter_name, "Overrides Filter") == 0
               || strcmp (filter_name, "Port Lists Filter") == 0
               || strcmp (filter_name, "Reports Filter") == 0
               || strcmp (filter_name, "Report Formats Filter") == 0
               || strcmp (filter_name, "Schedules Filter") == 0
               || strcmp (filter_name, "Slaves Filter") == 0
               || strcmp (filter_name, "Targets Filter") == 0
               || strcmp (filter_name, "Tasks Filter") == 0
               || strcmp (filter_name, "CPE Filter") == 0
               || strcmp (filter_name, "CVE Filter") == 0
               || strcmp (filter_name, "NVT Filter") == 0
               || strcmp (filter_name, "OVAL Filter") == 0
               || strcmp (filter_name, "DFN-CERT Filter") == 0))
    {
      gchar *quoted_value;

      assert (current_credentials.username);

      /* Use value directly as it is not base64 encoded. */
      quoted_value = sql_quote (value_64);

      if (sql_int (0, 0,
                   "SELECT count(*) FROM settings"
                   " WHERE uuid = '%s'"
                   " AND owner = (SELECT ROWID FROM users WHERE uuid = '%s');",
                   uuid,
                   current_credentials.uuid))
        sql ("UPDATE settings SET value = '%s'"
             " WHERE uuid = '%s'"
             " AND owner = (SELECT ROWID FROM users WHERE uuid = '%s');",
             quoted_value,
             uuid,
             current_credentials.uuid);
      else
        sql ("INSERT INTO settings (uuid, owner, name, comment, value)"
             " VALUES"
             " ('%s',"
             "  (SELECT ROWID FROM users WHERE uuid = '%s'),"
             "  '%s',"
             "  (SELECT comment FROM settings"
             "   WHERE uuid = '%s' AND owner IS NULL),"
             "  '%s');",
             uuid,
             current_credentials.uuid,
             filter_name,
             uuid,
             quoted_value);

      g_free (quoted_value);

      return 0;
    }

  return 1;
}


/* SCAP. */

/**
 * @brief Filter columns for CVE iterator.
 */
#define CVE_INFO_ITERATOR_FILTER_COLUMNS                         \
 { "uuid", "name", "comment", "published", "modified", "vector", \
   "complexity", "authentication", "confidentiality_impact",     \
   "integrity_impact", "availability_impact", "products",        \
   "cvss", "description", NULL }

/**
 * @brief CVE iterator columns.
 */
#define CVE_INFO_ITERATOR_COLUMNS                               \
   "ROWID, uuid, name, comment, iso_time (creation_time),"      \
   " iso_time (modification_time), creation_time AS published," \
   " modification_time AS modified,"                            \
   " vector, complexity,"                                       \
   " authentication, confidentiality_impact,"                   \
   " integrity_impact, availability_impact, products,"          \
   " cvss, description"

/**
 * @brief Filter columns for CVE iterator.
 */
#define CPE_INFO_ITERATOR_FILTER_COLUMNS                    \
 { GET_ITERATOR_FILTER_COLUMNS, "title", "status",          \
   "deprecated_by_id", "max_cvss", "cves",  NULL }

/**
 * @brief CPE iterator columns.
 */
#define CPE_INFO_ITERATOR_COLUMNS                           \
  GET_ITERATOR_COLUMNS ", title, status, deprecated_by_id," \
  "max_cvss, cve_refs AS cves"

/**
 * @brief Filter columns for OVALDEF iterator.
 */
#define OVALDEF_INFO_ITERATOR_FILTER_COLUMNS                \
 { GET_ITERATOR_FILTER_COLUMNS, "version", "deprecated",    \
   "def_class", "title", "description", "xml_file",         \
   "status", NULL }

/**
 * @brief OVALDEF iterator columns.
 */
#define OVALDEF_INFO_ITERATOR_COLUMNS                       \
  GET_ITERATOR_COLUMNS ", version, deprecated, def_class,"  \
  "title, description, xml_file, status"

/**
 * @brief Filter columns for DFN_CERT_ADV iterator.
 */
#define DFN_CERT_ADV_INFO_ITERATOR_FILTER_COLUMNS           \
 { GET_ITERATOR_FILTER_COLUMNS, "title", "summary",         \
   "cves",  NULL }

/**
 * @brief DFN_CERT_ADV iterator columns.
 */
#define DFN_CERT_ADV_INFO_ITERATOR_COLUMNS                       \
  GET_ITERATOR_COLUMNS ", title, summary, cve_refs AS cves"


/**
 * @brief Check whether SCAP is available.
 *
 * @return 1 if SCAP database is loaded, else 0.
 */
int
manage_scap_loaded ()
{
  if (access (OPENVAS_STATE_DIR "/scap-data/scap.db", R_OK))
    switch (errno)
      {
        case ENOENT:
          return 0;
          break;
        default:
          g_warning ("%s: failed to stat SCAP database: %s\n",
                     __FUNCTION__,
                     strerror (errno));
          return 0;
      }

  return !!sql_int (0, 0,
                    "SELECT count(*) FROM scap.sqlite_master"
                    " WHERE type = 'table' AND name = 'cves';");
}

/**
 * @brief Check whether CERT is available.
 *
 * @return 1 if CERT database is loaded, else 0.
 */
int
manage_cert_loaded ()
{
  if (access (OPENVAS_STATE_DIR "/cert-data/cert.db", R_OK))
    switch (errno)
      {
        case ENOENT:
          return 0;
          break;
        default:
          g_warning ("%s: failed to stat CERT database: %s\n",
                     __FUNCTION__,
                     strerror (errno));
          return 0;
      }

  return !!sql_int (0, 0,
                    "SELECT count(*) FROM cert.sqlite_master"
                    " WHERE type = 'table' AND name = 'dfn_cert_advs';");
}

/**
 * @brief Initialise an CVE iterator, for CVEs reported for a certain CPE.
 *
 * @param[in]  iterator    Iterator.
 * @param[in]  cve         CVE.
 * @param[in]  ascending   Whether to sort ascending or descending.
 * @param[in]  sort_field  Field to sort on, or NULL for "ROWID".
 */
void
init_cpe_cve_iterator (iterator_t *iterator, const char *cve, int ascending,
                       const char *sort_field)
{
  gchar *quoted_cpe;
  assert (cve);
  quoted_cpe = sql_quote (cve);
  init_iterator (iterator,
                 "SELECT ROWID, name, cvss FROM cves WHERE ROWID IN"
                 " (SELECT cve FROM affected_products"
                 "  WHERE cpe ="
                 "  (SELECT ROWID FROM cpes WHERE name = '%s'))"
                 " ORDER BY %s %s;",
                 quoted_cpe,
                 sort_field ? sort_field : "cvss DESC, name",
                 ascending ? "ASC" : "DESC");
  g_free (quoted_cpe);
}

/**
 * @brief Get the name from a CVE iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The name of the CVE, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (cve_iterator_name, 1);

/**
 * @brief Get the CVSS from a CVE iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The CVSS of the CVE, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (cve_iterator_cvss, 2);

/**
 * @brief Count number of cpe.
 *
 * @param[in]  get  GET params.
 *
 * @return Total number of cpes in filtered set.
 */
int
cpe_info_count (const get_data_t *get)
{
  static const char *extra_columns[] = CPE_INFO_ITERATOR_FILTER_COLUMNS;
  return count ("cpe", get, CPE_INFO_ITERATOR_COLUMNS, extra_columns, 0, 0, 0,
                FALSE);
}

/**
 * @brief Initialise a info iterator.
 *
 * @param[in]  iterator        Iterator.
 * @param[in]  get             GET data.
 * @param[in]  name            Name of the info
 *
 * @return 0 success, 1 failed to find target, 2 failed to find filter,
 *         -1 error.
 */
int
init_cpe_info_iterator (iterator_t* iterator, get_data_t *get, const char *name)
{
  static const char *filter_columns[] = CPE_INFO_ITERATOR_FILTER_COLUMNS;
  gchar *clause = NULL;
  int ret;

  if (get->id)
    {
      gchar *quoted = sql_quote (get->id);
      clause = g_strdup_printf (" AND uuid = '%s'", quoted);
      g_free (quoted);
    }
  else if (name)
    {
      gchar *quoted = sql_quote (name);
      clause = g_strdup_printf (" AND name = '%s'", quoted);
      g_free (quoted);
      /* The entry is specified by name, so filtering just gets in the way. */
      g_free (get->filter);
      get->filter = NULL;
    }
  ret = init_get_iterator (iterator,
                           "cpe",
                           get,
                           /* Columns. */
                           CPE_INFO_ITERATOR_COLUMNS,
                           NULL,
                           filter_columns,
                           NULL,
                           0,
                           NULL,
                           clause,
                           FALSE);
  g_free (clause);
  return ret;
}

/**
 * @brief Count number of cve.
 *
 * @param[in]  get  GET params.
 *
 * @return Total number of cpes in filtered set.
 */
int
cve_info_count (const get_data_t *get)
{
  static const char *extra_columns[] = CVE_INFO_ITERATOR_FILTER_COLUMNS;
  return count ("cve", get, CVE_INFO_ITERATOR_COLUMNS, extra_columns, 0, 0, 0,
                FALSE);
}

/**
 * @brief Initialise a info iterator.
 *
 * @param[in]  iterator        Iterator.
 * @param[in]  get             GET data.
 * @param[in]  name            Name of the info
 *
 * @return 0 success, 1 failed to find target, 2 failed to find filter,
 *         -1 error.
 */
int
init_cve_info_iterator (iterator_t* iterator, get_data_t *get, const char *name)
{
  static const char *filter_columns[] = CVE_INFO_ITERATOR_FILTER_COLUMNS;
  gchar *clause = NULL;
  int ret;

  if (get->id)
    {
      gchar *quoted = sql_quote (get->id);
      clause = g_strdup_printf (" AND uuid = '%s'", quoted);
      g_free (quoted);
    }
  else if (name)
    {
      gchar *quoted = sql_quote (name);
      clause = g_strdup_printf (" AND name = '%s'", quoted);
      g_free (quoted);
      /* The entry is specified by name, so filtering just gets in the way. */
      g_free (get->filter);
      get->filter = NULL;
    }
  ret = init_get_iterator (iterator,
                           "cve",
                           get,
                           /* Columns. */
                           CVE_INFO_ITERATOR_COLUMNS,
                           NULL,
                           filter_columns,
                           NULL,
                           0,
                           NULL,
                           clause,
                           FALSE);
  g_free (clause);
  return ret;
}
/**
 * @brief Get the title from a CPE iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The Title of the CPE, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (cpe_info_iterator_title, GET_ITERATOR_COLUMN_COUNT);

/**
 * @brief Get the status from a CPE iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The Status of the CPE, or NULL if iteration is complete.  Freed by
 *         cleanup_iterator.
 */
DEF_ACCESS (cpe_info_iterator_status, GET_ITERATOR_COLUMN_COUNT + 1);

/**
 * @brief Get the id of the deprecating CPE from a CPE iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The deprecated_by CVD ID, or NULL if iteration is complete.
 *         Freed by cleanup_iterator.
 */
DEF_ACCESS (cpe_info_iterator_deprecated_by, GET_ITERATOR_COLUMN_COUNT + 2);

/**
 * @brief Get the Highest CVSS Score of all CVE's referencing this cpe.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The Highest CVSS of the CPE, or NULL if iteration is complete.
 *         Freed by cleanup_iterator.
 */
DEF_ACCESS (cpe_info_iterator_max_cvss, GET_ITERATOR_COLUMN_COUNT + 3);

/**
 * @brief Get the Number of CVE's referencing this cpe from a CPE iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The Number of references to the CPE, or NULL if iteration is
 *         complete. Freed by cleanup_iterator.
 */
DEF_ACCESS (cpe_info_iterator_cve_refs, GET_ITERATOR_COLUMN_COUNT + 4);

/**
 * @brief Get the CVSS attack vector for this CVE.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The CVSS attack vector of this CVE, or NULL if iteration is
 *         complete. Freed by cleanup_iterator.
 */
DEF_ACCESS (cve_info_iterator_vector, GET_ITERATOR_COLUMN_COUNT);

/**
 * @brief Get the CVSS attack complexity for this CVE.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The CVSS attack complexity of this CVE, or NULL if iteration is
 *         complete. Freed by cleanup_iterator.
 */
DEF_ACCESS (cve_info_iterator_complexity, GET_ITERATOR_COLUMN_COUNT + 1);

/**
 * @brief Get the CVSS attack authentication for this CVE.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The CVSS attack authentication of this CVE, or NULL if iteration is
 *         complete. Freed by cleanup_iterator.
 */
DEF_ACCESS (cve_info_iterator_authentication, GET_ITERATOR_COLUMN_COUNT + 2);

/**
 * @brief Get the CVSS confidentiality impact for this CVE.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The CVSS confidentiality impact of this CVE, or NULL if iteration is
 *         complete. Freed by cleanup_iterator.
 */
DEF_ACCESS (cve_info_iterator_confidentiality_impact, GET_ITERATOR_COLUMN_COUNT + 3);

/**
 * @brief Get the CVSS integrity impact for this CVE.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The CVSS integrity impact of this CVE, or NULL if iteration is
 *         complete. Freed by cleanup_iterator.
 */
DEF_ACCESS (cve_info_iterator_integrity_impact, GET_ITERATOR_COLUMN_COUNT + 4);

/**
 * @brief Get the CVSS availability impact for this CVE.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The CVSS availability impact of this CVE, or NULL if iteration is
 *         complete. Freed by cleanup_iterator.
 */
DEF_ACCESS (cve_info_iterator_availability_impact, GET_ITERATOR_COLUMN_COUNT + 5);

/**
 * @brief Get a space seperated list of CPEs affected by this CVE.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return A space seperated list of CPEs or NULL if iteration is
 *         complete. Freed by cleanup_iterator.
 */
DEF_ACCESS (cve_info_iterator_products, GET_ITERATOR_COLUMN_COUNT + 6);

/**
 * @brief Get the CVSS base score for this CVE.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The CVSS base score of this CVE, or NULL if iteration is
 *         complete. Freed by cleanup_iterator.
 */
DEF_ACCESS (cve_info_iterator_cvss, GET_ITERATOR_COLUMN_COUNT + 7);

/**
 * @brief Get the Summary for this CVE.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The Summary of this CVE, or NULL if iteration is
 *         complete. Freed by cleanup_iterator.
 */
DEF_ACCESS (cve_info_iterator_description, GET_ITERATOR_COLUMN_COUNT + 8);

/* OVAL data */
/**
 * @brief Initialise an OVAL definition (ovaldef) info iterator.
 *
 * @param[in]  iterator        Iterator.
 * @param[in]  get             GET data.
 * @param[in]  name            Name of the info
 *
 * @return 0 success, 1 failed to find target, 2 failed to find filter,
 *         -1 error.
 */
int
init_ovaldef_info_iterator (iterator_t* iterator, get_data_t *get,
                            const char *name)
{
  static const char *filter_columns[] = OVALDEF_INFO_ITERATOR_FILTER_COLUMNS;
  gchar *clause = NULL;
  int ret;

  if (get->id)
    {
      gchar *quoted = sql_quote (get->id);
      clause = g_strdup_printf (" AND uuid = '%s'", quoted);
      g_free (quoted);
    }
  else if (name)
    {
      gchar *quoted = sql_quote (name);
      clause = g_strdup_printf (" AND name = '%s'", quoted);
      g_free (quoted);
      /* The entry is specified by name, so filtering just gets in the way. */
      g_free (get->filter);
      get->filter = NULL;
    }
  ret = init_get_iterator (iterator,
                           "ovaldef",
                           get,
                           /* Columns. */
                           OVALDEF_INFO_ITERATOR_COLUMNS,
                           NULL,
                           filter_columns,
                           NULL,
                           0,
                           NULL,
                           clause,
                           FALSE);
  g_free (clause);
  return ret;
}

/**
 * @brief Count number of ovaldef.
 *
 * @param[in]  get  GET params.
 *
 * @return Total number of OVAL definitions in filtered set.
 */
int
ovaldef_info_count (const get_data_t *get)
{
  static const char *extra_columns[] = OVALDEF_INFO_ITERATOR_FILTER_COLUMNS;
  return count ("ovaldef", get, OVALDEF_INFO_ITERATOR_COLUMNS, extra_columns,
                0, 0, 0, FALSE);
}

/**
 * @brief Get the version number from an OVALDEF iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The version number of the OVAL definition,
 *         or NULL if iteration is complete.
 *         Freed by cleanup_iterator.
 */
DEF_ACCESS (ovaldef_info_iterator_version, GET_ITERATOR_COLUMN_COUNT);

/**
 * @brief Get the deprecation status from an OVALDEF iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return True if the OVAL definition is deprecated, false if not,
 *         or NULL if iteration is complete.
 *         Freed by cleanup_iterator.
 */
DEF_ACCESS (ovaldef_info_iterator_deprecated, GET_ITERATOR_COLUMN_COUNT + 1);

/**
 * @brief Get the definition class from an OVALDEF iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The definition class (e.g. 'patch' or 'vulnerability') of the OVAL
 *         definition, or NULL if iteration is complete.
 *         Freed by cleanup_iterator.
 */
DEF_ACCESS (ovaldef_info_iterator_def_class, GET_ITERATOR_COLUMN_COUNT + 2);

/**
 * @brief Get the title from an OVALDEF iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The title / short description of the OVAL definition,
 *         or NULL if iteration is complete.
 *         Freed by cleanup_iterator.
 */
DEF_ACCESS (ovaldef_info_iterator_title, GET_ITERATOR_COLUMN_COUNT + 3);

/**
 * @brief Get the description from an OVALDEF iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The long description of the OVAL definition,
 *         or NULL if iteration is complete.
 *         Freed by cleanup_iterator.
 */
DEF_ACCESS (ovaldef_info_iterator_description, GET_ITERATOR_COLUMN_COUNT + 4);

/**
 * @brief Get the source xml file from an OVALDEF iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The short xml source file name of the OVAL definition,
 *         or NULL if iteration is complete.
 *         Freed by cleanup_iterator.
 */
DEF_ACCESS (ovaldef_info_iterator_xml_file, GET_ITERATOR_COLUMN_COUNT + 5);

/**
 * @brief Get the repository entry status from an OVALDEF iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The repository entry status of the OVAL definition,
 *         or NULL if iteration is complete.
 *         Freed by cleanup_iterator.
 */
DEF_ACCESS (ovaldef_info_iterator_status, GET_ITERATOR_COLUMN_COUNT + 6);

/* CERT data */

/* DFN-CERT data */
/**
 * @brief Initialise an DFN-CERT advisory (dfn_cert_adv) info iterator.
 *
 * @param[in]  iterator        Iterator.
 * @param[in]  get             GET data.
 * @param[in]  name            Name of the info
 *
 * @return 0 success, 1 failed to find target, 2 failed to find filter,
 *         -1 error.
 */
int
init_dfn_cert_adv_info_iterator (iterator_t* iterator, get_data_t *get,
                            const char *name)
{
  static const char *filter_columns[] =
      DFN_CERT_ADV_INFO_ITERATOR_FILTER_COLUMNS;
  gchar *clause = NULL;
  int ret;

  if (get->id)
    {
      gchar *quoted = sql_quote (get->id);
      clause = g_strdup_printf (" AND uuid = '%s'", quoted);
      g_free (quoted);
    }
  else if (name)
    {
      gchar *quoted = sql_quote (name);
      clause = g_strdup_printf (" AND name = '%s'", quoted);
      g_free (quoted);
      /* The entry is specified by name, so filtering just gets in the way. */
      g_free (get->filter);
      get->filter = NULL;
    }
  ret = init_get_iterator (iterator,
                           "dfn_cert_adv",
                           get,
                           /* Columns. */
                           DFN_CERT_ADV_INFO_ITERATOR_COLUMNS,
                           NULL,
                           filter_columns,
                           NULL,
                           0,
                           NULL,
                           clause,
                           FALSE);
  g_free (clause);
  return ret;
}

/**
 * @brief Count number of dfn_cert_adv.
 *
 * @param[in]  get  GET params.
 *
 * @return Total number of DFN-CERT advisories in filtered set.
 */
int
dfn_cert_adv_info_count (const get_data_t *get)
{
  static const char *extra_columns[] =
                      DFN_CERT_ADV_INFO_ITERATOR_FILTER_COLUMNS;
  return count ("dfn_cert_adv", get, DFN_CERT_ADV_INFO_ITERATOR_COLUMNS,
                extra_columns, 0, 0, 0, FALSE);
}

/**
 * @brief Get the title from an DFN_CERT_ADV iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The title of the DFN-CERT advisory,
 *         or NULL if iteration is complete.
 *         Freed by cleanup_iterator.
 */
DEF_ACCESS (dfn_cert_adv_info_iterator_title, GET_ITERATOR_COLUMN_COUNT);

/**
 * @brief Get the summary from an DFN_CERT_ADV iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The summary of the DFN-CERT advisory,
 *         or NULL if iteration is complete.
 *         Freed by cleanup_iterator.
 */
DEF_ACCESS (dfn_cert_adv_info_iterator_summary, GET_ITERATOR_COLUMN_COUNT + 1);

/**
 * @brief Get the number of cves from an DFN_CERT_ADV iterator.
 *
 * @param[in]  iterator  Iterator.
 *
 * @return The number of CVEs referenced in the DFN-CERT advisory,
 *         or NULL if iteration is complete.
 *         Freed by cleanup_iterator.
 */
DEF_ACCESS (dfn_cert_adv_info_iterator_cve_refs, GET_ITERATOR_COLUMN_COUNT + 2);

/**
 * @brief Initialise CVE iterator, for CVEs referenced by a DFN-CERT advisory.
 *
 * @param[in]  iterator    Iterator.
 * @param[in]  adv         Name of the DFN-CERT advisory.
 * @param[in]  ascending   Whether to sort ascending or descending.
 * @param[in]  sort_field  Field to sort on, or NULL for "ROWID".
 */
void
init_cve_dfn_cert_adv_iterator (iterator_t *iterator, const char *cve,
                                int ascending, const char *sort_field)
{
  assert (cve);
  init_iterator (iterator,
                 "SELECT " DFN_CERT_ADV_INFO_ITERATOR_COLUMNS
                 " FROM dfn_cert_advs"
                 " WHERE id IN (SELECT adv_id FROM dfn_cert_cves"
                 "              WHERE cve_name = '%s')"
                 " ORDER BY %s %s;",
                 cve,
                 sort_field ? sort_field : "name",
                 ascending ? "ASC" : "DESC");
}

/**
 * @brief Initialise an DFN-CERT iterator, for advisories relevant to a NVT.
 *
 * @param[in]  iterator    Iterator.
 * @param[in]  oid         OID of the NVT.
 * @param[in]  ascending   Whether to sort ascending or descending.
 * @param[in]  sort_field  Field to sort on, or NULL for "ROWID".
 */
void
init_nvt_dfn_cert_adv_iterator (iterator_t *iterator, const char *oid,
                                int ascending, const char *sort_field)
{
  assert (oid);
  init_iterator (iterator,
                 "SELECT " DFN_CERT_ADV_INFO_ITERATOR_COLUMNS
                 " FROM dfn_cert_advs"
                 " WHERE id IN (SELECT adv_id FROM dfn_cert_cves"
                 "              WHERE (SELECT cve FROM nvts WHERE oid='%s')"
                 "                    LIKE ('%%' || cve_name || '%%'))"
                 " ORDER BY %s %s;",
                 oid,
                 sort_field ? sort_field : "name",
                 ascending ? "ASC" : "DESC");
}

/**
 * @brief Get the short file name for an OVALDEF.
 *
 * @param[in]  name  Full OVAL identifier.
 *
 * @return The file name of the OVAL definition relative to the SCAP directory,
 *         Freed by g_free.
 */
gchar*
get_ovaldef_short_filename (char* oval_id)
{
  return sql_string (0, 0,
                     "SELECT xml_file FROM ovaldefs WHERE name = '%s';",
                     oval_id);
}
